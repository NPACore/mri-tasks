'
'
'
'	C:\Users\nstem\Documents\Notes_WF\TOL\TOL072723_EyeLink2024-04-02WF.ebs3
'	Generated on: 4/2/2024	16:15:17
'
'
'	This experiment has been generated with E-Prime version: 3.0.3.214
'
'	This file generated with the E-Studio interface.
'	E-Prime Â© 1996-2022 Psychology Software Tools. All rights reserved.
'
'	Legal use of this experiment script requires a full E-Prime or Runtime License.
'
'
'	Author:
'		Neil P. Jones
'
'
'
'

Option CStrings On
Dim ebContext as Context


'--------------------------------------------------------------------------
' Class Declarations
'--------------------------------------------------------------------------



























'--------------------------------------------------------------------------
' Instance Declarations
'--------------------------------------------------------------------------
Dim Display As DisplayDevice
Dim Keyboard As KeyboardDevice
Dim Mouse As MouseDevice
Dim Socket As SocketDevice
Dim Button As ButtonDevice
Dim Serial As SerialDevice
Dim Plan As Slide
Dim PlanEchoClients As EchoClientCollection
Dim Plan_State As SlideState
Dim Plan_SlideText As SlideText
Dim Plan_SlideImage As SlideImage

Dim SessionProc As Procedure

Dim planproc As Procedure

Dim Fixation As TextDisplay

' List Attribute Constants
Const attrib_weight = ebUCase_W & ebLCase_e & ebLCase_i & ebLCase_g & ebLCase_h & ebLCase_t
Const attrib_nested = ebUCase_N & ebLCase_e & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_d
Const attrib_procedure = ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_d & ebLCase_u & ebLCase_r & ebLCase_e
Const attrib_eyesuffix = ebLCase_e & ebLCase_y & ebLCase_e & ebLCase_s & ebLCase_u & ebLCase_f & ebLCase_f & ebLCase_i & ebLCase_x
Const attrib_startstate = ebUCase_S & ebLCase_t & ebLCase_a & ebLCase_r & ebLCase_t & ebUCase_S & ebLCase_t & ebLCase_a & ebLCase_t & ebLCase_e
Const attrib_posgoal = ebLCase_p & ebLCase_o & ebLCase_s & ebUCase_G & ebLCase_o & ebLCase_a & ebLCase_l
Const attrib_correctmoves = ebLCase_c & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_m & ebLCase_o & ebLCase_v & ebLCase_e & ebLCase_s
Const attrib_difficulty = ebUCase_D & ebLCase_i & ebLCase_f & ebLCase_f & ebLCase_i & ebLCase_c & ebLCase_u & ebLCase_l & ebLCase_t & ebLCase_y
Const attrib_res2 = ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_2
Const attrib_res3 = ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_3
Const attrib_res4 = ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_4
Const attrib_res5 = ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_5
Const attrib_res6 = ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_6
Const attrib_cue = ebLCase_c & ebLCase_u & ebLCase_e
Const attrib_plandur = ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_n & ebLCase_d & ebLCase_u & ebLCase_r
Const attrib_feeddur = ebLCase_f & ebLCase_e & ebLCase_e & ebLCase_d & ebLCase_d & ebLCase_u & ebLCase_r
Const attrib_iti = ebUCase_I & ebUCase_T & ebUCase_I
Const attrib_shock = ebUCase_S & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k
Const attrib_ashock = ebUCase_A & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k
Const attrib_plannummov = ebUCase_P & ebLCase_l & ebLCase_a & ebLCase_n & ebLCase_n & ebLCase_u & ebLCase_m & ebLCase_m & ebLCase_o & ebLCase_v
Const attrib_pcountdown = ebLCase_p & ebLCase_c & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebLCase_d & ebLCase_o & ebLCase_w & ebLCase_n
Const attrib_trialnum = ebUCase_T & ebLCase_r & ebLCase_i & ebLCase_a & ebLCase_l & ebLCase_n & ebLCase_u & ebLCase_m

Dim MenuList As List

Dim Menu As Procedure

Dim TowerTask As Procedure

Dim MenuText As TextDisplay

Dim goodbye As Procedure

Dim Goodbyetxt As TextDisplay

Dim Breakproc As Procedure

Dim Standby As TextDisplay
Dim StandbyEchoClients As EchoClientCollection

Dim Waitingforpup As TextDisplay
Dim WaitingforpupEchoClients As EchoClientCollection

Dim TOLconditions As List

Dim Instruct As TextDisplay
Dim InstructEchoClients As EchoClientCollection

Dim mask As TextDisplay

Dim Intelligence As TextDisplay
Dim IntelligenceEchoClients As EchoClientCollection

Dim Block1 As List

Dim Incorrect As Slide
Dim Incorrect_State As SlideState
Dim Incorrect_SlideText As SlideText

Dim Correct As Slide
Dim Correct_State As SlideState
Dim Correct_SlideText As SlideText
Dim Correct_SlideImage As SlideImage

Dim Fixation2 As Slide
Dim Fixation2_State As SlideState
Dim Fixation2_SlideImage As SlideImage

Dim Block2 As List

Dim Block3 As List

Dim Instruct2 As TextDisplay
Dim Instruct2EchoClients As EchoClientCollection

Dim Beakprocshock As Procedure
Dim Beakprocshock_nObject As Long
Dim Beakprocshock_bCanExit As Boolean
Dim Beakprocshock_theCollection As RteCollection
Dim Beakprocshock_theInputObject As RteRunnableInputObject

Dim Block4 As List

Dim SAMDdid As Slide
Dim SAMDdidEchoClients As EchoClientCollection
Dim SAMDdid_State As SlideState
Dim SAMDdid_SlideImage As SlideImage

Dim Intelligence1 As TextDisplay
Dim Intelligence1EchoClients As EchoClientCollection

Dim CD5 As Slide
Dim CD5_State As SlideState
Dim CD5_SlideText As SlideText

Dim CD1 As Slide
Dim CD1_State As SlideState
Dim CD1_SlideText As SlideText

Dim CD2 As Slide
Dim CD2_State As SlideState
Dim CD2_SlideText As SlideText

Dim CD3 As Slide
Dim CD3_State As SlideState
Dim CD3_SlideText As SlideText

Dim CD4 As Slide
Dim CD4_State As SlideState
Dim CD4_SlideText As SlideText

Dim Fixation3 As Slide
Dim Fixation3_State As SlideState
Dim Fixation3_SlideImage As SlideImage

Dim shockcheck As TextDisplay
Dim shockcheckEchoClients As EchoClientCollection

Dim shockscale As Slide
Dim shockscaleEchoClients As EchoClientCollection
Dim shockscale_State As SlideState
Dim shockscale_SlideImage As SlideImage

Dim Moreshock As TextDisplay
Dim MoreshockEchoClients As EchoClientCollection

Dim Beakprocshock3 As Procedure
Dim Beakprocshock3_nObject As Long
Dim Beakprocshock3_bCanExit As Boolean
Dim Beakprocshock3_theCollection As RteCollection
Dim Beakprocshock3_theInputObject As RteRunnableInputObject

Dim Beakprocshock4 As Procedure
Dim Beakprocshock4_nObject As Long
Dim Beakprocshock4_bCanExit As Boolean
Dim Beakprocshock4_theCollection As RteCollection
Dim Beakprocshock4_theInputObject As RteRunnableInputObject

Dim elInstructions As TextDisplay
Dim elInstructionsEchoClients As EchoClientCollection

Dim calibrate As Procedure
Dim calibrate_nObject As Long
Dim calibrate_bCanExit As Boolean
Dim calibrate_theCollection As RteCollection
Dim calibrate_theInputObject As RteRunnableInputObject

Dim cleanup As Procedure
Dim cleanup_nObject As Long
Dim cleanup_bCanExit As Boolean
Dim cleanup_theCollection As RteCollection
Dim cleanup_theInputObject As RteRunnableInputObject



'--------------------------------------------------------------------------
' Package Declare Script
'--------------------------------------------------------------------------



'--------------------------------------------------------------------------
' User Script - BEGIN
'--------------------------------------------------------------------------
Dim Difficulty As String
Dim pupfname As String
Dim nStartTime As Long
Dim pStartTime As Long
Dim currt As Long
Dim prestimtime As Long
Dim planprestimtime As Long
Dim slidedur As Long
Dim countdown As String
Dim countdown2 As Long
Dim slidedurs As Long
Dim slidesolvs As Long
Dim elapsedtime As Long
Dim pdur As Integer
Dim countdowns As String
Dim extra As Integer
Dim pscore As Integer
Dim sscore As Integer
Dim tscore As Integer
Dim tleft As Double
Dim fudge As Double
Dim tset As Long
Dim slop As Long
Dim solved As Integer
Dim plancorr As Integer
Dim finalhit As Long
Dim feedbck As String
Dim posGoal As String
Dim posCurrent As String
Dim res1 As String
Dim res2 As String
Dim res3 As String
Dim res4 As String
Dim res5 As String
Dim res6 As String
Dim res7 As String
Dim res8 As String
Dim posA As String
Dim posB As String
Dim posC As String
Dim Shock As String
Dim planState As SlideState
Dim theState As SlideState 
Dim strHit As String
Dim keyboardMask As KeyboardResponseData
Dim switchfile As String
Dim switchfile2 As String 
Dim switchfile3 As String
Dim switchfile4 As String
Dim Checkshock As String
Dim plannummov As Integer
Dim posAvar As String
Dim posBvar As String
Dim posCvar As String
Dim dposGoal As String
Dim dposA As String
Dim dposB As String
Dim dposC As String
Dim exit1 As String
Dim value As String
Dim toggle As Boolean
Dim stable As Boolean
Dim TrialStar As Long
Dim Qval As Integer
Dim RT As Long
Dim Response As Double
Dim GotAns As Integer
Dim start As Integer
Dim x As Integer
Dim last As Integer
Dim juststarting As Integer
Dim tosend As Integer
Dim TrialNum As Integer
Dim fixon As Long
Dim fbon As Long
Dim maskon As Long
Dim breakfix As Long
Dim bytesThatMakePulseConfigCommand(5) As Integer
Dim bytesToRaiseStimTrackerLines(3) As Integer

Const PupilometerPresent = 1
Const NumInaRow=7
Const Screenres=13.333 'Monitor Resolution: 60 Hz use 16.6667; 75Hz use 13.333' 


' Config Device Flags. 2024-02-20WF
Dim USE_SERIAL As Boolean ' Stim device?
Dim TRACKERHARDWARE As String




'''  //////////////////////////////////////////-------------------------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ '''
'''  ////////////////////////////////////////// <EyeLink Company Code>  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ '''
'''  //////////////////////////////////////////-------------------------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ '''

' Copyright (c) 1997 - 2021 by SR Research Ltd., All Rights Reserved        
'                                                                           
' This software is provided as is without warranty of any kind.  The entire 
' risk as to the results and performance of this software is assumed by the 
' user. SR Research Ltd. disclaims all warranties, either express or implied,
' including but not limited to, the implied warranties of merchantability,    
' fitness for a particular purpose, title and noninfringement, with respect 
' to this software.
'
' For non-commercial use by Eyelink licencees only
'
'-------------------------------------------------------------------------------
'
' The following routines provide drawing/input support for calibration,
'validation, drift check, and camera setup features.

'If using E-Prime 3, please be sure to use at a minimum EP3's update 2 (version
'3.0.3.80) for proper function.
'
'
'-------------------------------------------------------------------------------
'
Dim elCameraSetupType As Integer 'see elConnect script
Dim useSuspend As Integer	 'controls use of suspend/resume calls.
							 'See elConnect script.
Dim usePriority As Integer	 'controls use of thread priority calls.
							 'See elConnect script.
Dim nPriority As Integer	 'Holds elevated priority value if usePriority > 0.
Dim tracker As Object        'global reference to hold tracker object
Dim elutil As Object         'global reference to hold elutil object
Dim cal_background As String 'calibration background color
Dim cal_foreground As String 'calibration foreground
Dim cal_target_size As Integer 'calibration target size, see elConnect
Dim cal_pen_width As Integer   'calibration pen width, see elConnect
Dim use_cust_cal As Integer  'whether to use custom calibration stimuli
Dim cust_cal_stim As String	 'custom calibration image/video to use
Dim calibrationSoundsOn As Integer 'whether or not to enable calibration sounds
Dim dummyMode As Integer     'whether to use active or dummy tracker connection
Dim incount As Integer       'global integer to hold input count
Dim edfFileName As String	 'global variable for edfname
Dim edfShortName As String	 'global var for edfname sans .edf
Dim trialCounter As Integer	 'global var for sequential trial number

'-----EDF filename input--------------------------------------------------------

'This function requests a name for the EyeLink Data File (.edf) to which the
'gaze and trial data will be recorded.  The filename must adhere to the DOS
'naming convention of 8.3 (8 characters plus extension).  The function will
'automatically append the .edf extension, so you can use at most 8 characters
'for the name.  Special characters other than underscore are not allowed.  The
'function checks the validity of the requested .edf name and will bring up a
'dialog box if an invalid name is given.  If the chosen .edf name already exists
'on the Display PC for this project, a warning will be presented asking if you'd
'like to overwrite the existing file or choose a new name.

Sub getEDFName		'Request .edf name & check whether .edf name is acceptable
	Dim edfcheck As Integer 'set to 1 if name is okay
	Dim nmAscChar As String 'holds ASCII code of each character in proposed name
	Dim nmIter As Integer 'used to iterate through and check each character
	Dim spChars As Integer 'number of special characters found in proposed name

	Do While edfcheck = 0 'Keep askbox up until we have a proper .edf name
		edfcheck = 0
		spChars = 0 'reset number of special characters found for new attempts
		edfFileName = AskBox("Please enter eye tracking name\n(up to 7 " &_
		"alphanumeric characters; short name for eye tracker only)" , "Test")
		
		If len(edfFileName) = 0 Then
			edfFileName = "Test" 'if nothing entered, use Test.edf
		End If
		If UCase(Right(edfFileName, 4)) <> ".EDF" Then 'if entered name doesn't
			edfFileName = edfFileName & ".edf"  'end in .edf, append with .edf
		End If
		
		edfShortName = left(edfFileName,len(edfFileName)-4) 'separate variable
				'with the proposed name without ".edf" -- done so we can check
				'the name and not have the . trip the check.
	
		For nmIter = len(edfShortName) To 1 Step -1 'iterate through once per
													'character in edfShortName
			nmAscChar = Asc(UCase(Mid(edfShortName,nmIter, 1))) 'set to ASCII
					'value of character.  If a text character, set to ASCII
					'value of uppercase version.
			If (nmAscChar > 64 And nmAscChar < 91) Or (nmAscChar > 47 And _
				nmAscChar < 58) Or (nmAscChar = 95) = True Then
					'if character checked is standard letter/number, or
					'underscore, do nothing
				Else 'otherwise, add 1 to spChars so we can reject the name.
					spChars=spChars+1
			End If
		Next nmIter ' loop to check next character
	
		If spChars = 0 And len(edfFileName) <=13 Then 'If there are no special
			edfcheck = 1		'characters and the name length is okay, accept
		End If 					'the name and continue with the project.
		If spChars > 0 Then	'if there are special characters, reject name and
			edfcheck = 0	'pull up dialog box before trying again.
			MsgBox "\nName contains special characters.\nTry again with " &_
			"only letters, numbers, and/or underscores.\n"
		End If
		If len(edfFileName) > 11 Then	'if name is too long, reject it -- pull
			edfcheck = 0				'up dialog box before trying again.
			MsgBox "\nName is too long.\nUp to 7 alphanumeric characters " &_
			"(including underscores) can be used.\n"
		End If
		If edfcheck = 1 And fileexists("./EyeData/" & edfShortName & "/" _
		& edfFileName) Then	'if requested file already in project's save folder,
			Dim answer As Integer	'ask if user wants to overwrite or rename.
			answer = AnswerBox("An .edf of the same name already exists.  " &_
			"Overwrite?", "Overwrite", "Choose New Name")
			If answer = 2 Then
				edfcheck=0
			End If
		End If
	Loop
	On Error Resume Next 'ignore errors -- without this, if the Results folder
	'being generated below already exists, the project will error out.
	Debug.Print "Creating Eye data folders"
	mkdir "EyeData"	'setting up the .edf save directory (within the project
	chdir "EyeData"	'directory, we'll have ./Results/<filename>/<filename.edf>
	mkdir edfShortName
	chdir ".."
	Debug.Print "Done creating folders"
End Sub
'Sub setMouseState
'Input: vis (True or False)
'Output:None
'Calibration graphics handler: Both GDICal and busyCal
'Purpose: Set visibility of mouse cursor to visible (True) or not (False).
' E-Prime does not automatically update mouse cursor visibility on-screen until
' the cursor object updates, so this sub simply forces an update by setting the
' mouse cursor position to its current location.

Sub setMouseState(vis As Boolean)
	Dim p As Point
	Mouse.GetCursorPos p.x, p.y
	If vis = True Then
		Mouse.ShowCursor True
	Else
		Mouse.ShowCursor False
	End If
	Mouse.SetCursorPos p.x, p.y
End Sub

'################### start calibration/validation/drift check items ############

'
'Sub checkKeyInput
'Input: None
'Output:None
'Calibration graphics handler: busyCal only
'Purpose: Check for and forward any input keypresses to the tracker.  Only
'needed while in Calibration/Validation/Drift Check modes.
'
Sub checkKeyInput() 
	'Retrieves the responses stored in the KeyboardDevice's History property.
	Dim kb_count As Integer
	Dim kb_resp As String

	kb_count = Keyboard.History.Count
	If (kb_count = 0) Then Exit Sub
	kb_resp = Keyboard.History(kb_count).RESP
	If (Len(kb_resp) = 1) Then  ' normal character
		tracker.sendKeybutton Asc(kb_resp), 0, 0
	Else  ' special character
		Select Case kb_resp
		Case "{SPACE}"
			tracker.sendKeybutton Asc(" "), 0, 0
		Case "{BACKSPACE}"
			tracker.sendKeybutton 08, 0, 0
		Case "{ENTER}"
			tracker.sendKeybutton 13, 0, 0
		Case "{ESCAPE}"
			tracker.sendKeybutton 27, 0, 0
		Case Else
			Debug.Print "ignoring kbd: " & kb_resp
		End Select
	End If
	Keyboard.History.RemoveAll
End Sub


'
'Sub doTrackerDrawings
'Input: 
'	bcal - reference to BusyCal object
'	customDrift - Optional argument, if custom drift check target needed.
'Output: None
'Calibration graphics handler: busyCal only
'Purpose: In a busy loop, check the job state of bcal, and draw target, 
'play target beeps accordingly.
'
Sub doTrackerDrawings(bcal As Object, Optional customDrift As Variant)
	Dim cnvs As Canvas
	Dim ofillColor As String 'original fill color
	Dim oPenColor As String 'original pen color
	Dim oPenWidth As Integer 'original pen Width
	Dim ELSoundBufferInfo As SoundBufferInfo
	Dim ELSoundBuffer As SoundBuffer

	Dim need_looping As Integer 'used for custom calibration video
	need_looping = 0
	
	Set cnvs = Display.Canvas
	If use_cust_cal=1 Then
		Dim calImg As ImageDisplay
		Set calImg = New ImageDisplay
		Set calImg.Filename = cust_cal_stim
		Set calImg.BackColor = CColor(cal_background)
	End If

	If use_cust_cal=2 Then
		Dim calMov1 As MovieDisplay
		Set calMov1 = New MovieDisplay
		Set calMov1.Filename = cust_cal_stim
		Set calMov1.BackColor = CColor(cal_background)
	End If

	ELSoundBufferInfo.MaxLength = 5000
	'Set ELSoundBuffer = Sound.CreateBuffer(ELSoundBufferInfo)

	If usePriority > 0 Then
		nPriority = GetOSThreadPriority()

		'Temporarily set the thread priority to a normal application
		SetOSThreadPriority 3
	End If

	Do While Not bcal Is Nothing 
	    Dim job As Integer
		Dim  connected As Boolean
		connected = tracker.isConnected()
	    job = bcal.job
	    If job = -1 Or Not connected Then ' Exit
	        Set bcal = Nothing
	    Else
			Select Case job
			Case 0
				'do nothing
			Case 1 'Setup Cal Display
				'save color and pen info so that we can reset when we return.
				oPenWidth= cnvs.PenWidth
				oPenColor= cnvs.PenColor
				ofillColor = cnvs.FillColor
				
				'set the pen and color
				cnvs.PenWidth = cal_pen_width
				cnvs.PenColor = CColor(cal_foreground)
				cnvs.FillColor = CColor(cal_background)
			Case 2 ' Exit Cal Display
				'Reset anything that was changed in Setup Cal Display
				cnvs.PenWidth=oPenWidth
				cnvs.PenColor=oPenColor
				cnvs.FillColor=ofillColor
				If Not IsMissing(customDrift) Then
					Dim cd As TextDisplay
					Set cd = customDrift
					cd.draw
					Set cd = Nothing
 				End If
			Case 5, 6 'Clear Cal Display / Erase Cal Target
				If use_cust_cal = 2 Then
					need_looping = 0
					calMov1.Stop
					cnvs.clear
				Else
					cnvs.Clear
				End If
			Case 7, 8, 14, 15, 18, 19
			'Cal Target Beep or DC Target Beep or cal done beep or dc done beep 
				'Enable the following block if you need audio feedback
				If calibrationSoundsOn = 1 Then
					ELSoundBuffer.Filename = Switch( _
						(job <= 8), "Stimuli/EL_type.wav", _
						(job <= 15), "Stimuli/EL_beep.wav", _
						(job <= 19), "Stimuli/EL_error.wav" )
					ELSoundBuffer.Load
					ELSoundBuffer.Play
				End If
	        Case 9 ' Draw Cal Target
	            Dim x As Integer
	            Dim y As Integer
				If use_cust_cal = 1 Then
					cnvs.clear
					bcal.getCalLocation x, y
					Set calImg.X = x
					Set calImg.Y = Y
					calImg.Load
					calImg.Draw
				ElseIf use_cust_cal = 2 Then
					need_looping = 1
					cnvs.clear
					bcal.getCalLocation x, y
					Set calMov1.X = x
					Set calMov1.Y = y
					calMov1.Load
					calMov1.Play
				Else
		            bcal.getCalLocation x, y
					cnvs.Clear
					cnvs.Circle x, y, cal_target_size
				End If
			Case 10 To 13
				Debug.print "Camera Image Not available"
			Case Else
				Debug.print "Unhandled job " & job
	        End Select
	    End If
		checkKeyInput
		If need_looping = 1 Then
			If calMov1.Status = ebMovieStatusStopped Then
				calMov1.load
				calMov1.play
			End If
		End If
	Loop
	Set bcal = Nothing
	Set ELSoundBuffer = Nothing
	Set cnvs = Nothing
	If usePriority > 0 Then
		'Reset the thread priority
		SetOSThreadPriority nPriority
	End If
End Sub

'
'Sub doCameraSetup
'Input: None
'Output:None
'Calibration graphics handler: Both GDICal and busyCal
'Purpose: Call this subroutine to do camera setup. 
'		  busyCal - Setup busycal and calls doTrackerDrawings to perform busyCal
'		 	output.
'		  GDICal - Setup GDICal and calls doTrackerSetup to perform camera setup
'
'Note: Camera image transfer to the Display PC is not available under busyCal.
'
'
Sub doCameraSetup
	setMouseState False
	If tracker.isConnected <> -1 Then 'If not in dummy mode
		If elCameraSetupType = 1 Then 'If using GDICal
			Dim gcal As Object
			Dim theHistory As RteCollection
			Set theHistory = Keyboard.History ' ignore keys pressed while in
											  '   calibration.
			theHistory.RemoveAll

			If useSuspend = 1 Then
				Rte.DeviceManager.Suspend 'This code may switch the resolution
									  	  'back to the previous resolution
			End If

			Set gcal = elutil.getGDICal()

			'The following turns off calibration sounds.
			If calibrationSoundsOn = 0 Then
				gcal.setCalibrationBeepSound "off",0
			End If
	
			gcal.enableKeyCollection True 'tell the com interface to start
										  '  collecting keyboard
			gcal.setCalibrationTargetSize cal_pen_width,cal_target_size
			gcal.setCalibrationColors CColor(cal_foreground), _
			 CColor(cal_background)

			'The following indicates what stimuli to use for calibration,
			'if custom stimuli have been defined in elConnect.
			If use_cust_cal = 2 Then
				gcal.initAnimationCalibration cust_cal_stim, 0
			ElseIf use_cust_cal = 1 Then
				gcal.setCalibrationTarget cust_cal_stim
			End If

			gcal.setCalibrationWindow -1
			tracker.doTrackerSetup

			If useSuspend = 1 Then
				Rte.DeviceManager.Resume
			End If
			
			gcal.enableKeyCollection False ' tell the com interface to stop
			Set gcal = Nothing			   ' collecting keyboard.
		
			theHistory.RemoveAll
		Else 'If using busyCal
			If tracker.isConnected <> -1 Then 'skip if we're in dummy mode
				Dim bcal As Object
				Set bcal = elutil.getBusyCal()
				bcal.startCameraSetup
				doTrackerDrawings bcal
	
				Set bcal = Nothing
			End If
		End If
	End If
End Sub

'
'Sub doDriftCheck
'Input: 
'	xloc - xlocation of the drift check target
'	yloc - ylocation of the drift check target
'   draw - if false, no target is drawn.  If false, can optionally pass in
'           customDrift TextDisplay, so that custom target can be re-drawn if
'           drift check is cancelled and calibration is performed.
'	allow_setup - if false, pressing escape does not perform a calibration.
'	customDrift - optional argument (TextDisplay type) to re-draw custom target.
'Output:None
'Calibration graphics handler: Both GDICal and busyCal
'Purpose: Call this subroutine to do drift check.
'		  busyCal - Setup busycal and call doTrackerDrawings to perform busyCal
'		    output.
'		  GDICal - Setup GDICal and calls doDriftCorrectEX to perform drift
'		    check.

'Note: Camera image transfer to the Display PC is not available under busyCal.
'
'
Sub doDriftCheck(xloc As Integer, yloc As Integer, draw As Boolean, _
allow_setup As Boolean,Optional customDrift As Variant)
	Dim theHistory As RteCollection
	Set theHistory = Keyboard.History
	theHistory.RemoveAll ' remove all key presses prior to drift check

	If elCameraSetupType = 1 Then 'If using GDICal
		Dim gcal As Object

		Dim cd As TextDisplay
	
		Set gcal = elutil.getGDICal()

		'The following indicates what stimuli to use for calibration, if custom
		'stimuli have been defined in elConnect.
		If use_cust_cal = 2 Then
			gcal.initAnimationCalibration cust_cal_stim, 0
		ElseIf use_cust_cal = 1 Then
			gcal.setCalibrationTarget cust_cal_stim
		End If

		'The following turns off drift check sounds.
		If calibrationSoundsOn = 0 Then
			gcal.setCalibrationBeepSound "off",0
		End If

		gcal.enableKeyCollection True 'tell the com interface to start
									  '  collecting keyboard
			
		' Call do drift check.
		' If the return value is 27 and allow setup value is 1 then 
		' switch to camera setup.
		' Once the camera setup is done, return to this drift check.
	
		If Not isMissing(customDrift)  Then
			Set cd = customDrift
			cd.draw
				
			Dim ret As Integer
			ret = tracker.doDriftCorrectEx( xloc, yloc, 0, 0)			
	
			Do While ret=27 And allow_setup = True 		
				If useSuspend = 1 Then
					Rte.DeviceManager.Suspend  'This code may switch the
							   '  resolution back to the previous resolution
				End If
		
				gcal.enableKeyCollection True 'tell the com interface to start
											  '  collecting keyboard
				gcal.setCalibrationTargetSize cal_pen_width,cal_target_size
				gcal.setCalibrationColors CColor(cal_foreground), _
					CColor(cal_background) 'cd.BackColor				

				gcal.setCalibrationWindow -1
				tracker.doTrackerSetup
				gcal.setCalibrationWindow 0
				If useSuspend = 1 Then
					Rte.DeviceManager.Resume
				End If
			
				cd.draw
				ret = tracker.doDriftCorrectEx( xloc, yloc, draw, 0)			
			Loop
		Else
			If useSuspend = 1 Then
				Rte.DeviceManager.Suspend
			End If
			gcal.setCalibrationTargetSize cal_pen_width,cal_target_size
			gcal.setCalibrationColors CColor(cal_foreground), _
				CColor(cal_background)
			gcal.setCalibrationWindow -1
			tracker.doDriftCorrect xloc, yloc,draw,allow_setup
			If useSuspend = 1 Then
				Rte.DeviceManager.Resume
			End If
		End If
	
		gcal.enableKeyCollection False ' tell the com interface to stop
									   '   collecting keyboard
		Set gcal = Nothing
	Else 'If using busyCal
		Dim bcal As Object
		Set bcal = elutil.getBusyCal()
		bcal.startDriftCorrect xloc,yloc,draw,allow_setup
		doTrackerDrawings bcal,customDrift
		Set bcal = Nothing
	End If

	theHistory.RemoveAll ' remove keys pressed during drift check
End Sub

'######################## end calibration/validation/drift check ###############

'Below function is to be called if we require keyboard input during an inline
'script's execution.

Function GetLastResponseData(strResponse As String) As ResponseData

	'Clone input history collection so the script can enumerate through the
	'responses without the collection changing while the script is running
	'(e.g., if the subject presses another key during this time).
	Dim theHistoryCollection As RteCollection
	Set theHistoryCollection = Keyboard.History.Clone

	'Enumerate through the collection in reverse order to determine
	'the last state of the specified key.
	Dim theResponseData As ResponseData

	If theHistoryCollection.Count > incount And theHistoryCollection.Count > 0 _
	Then
		incount = theHistoryCollection.Count 'so we don't get multiple keys
		Set theResponseData = CResponseData(theHistoryCollection(1))
		If Not theResponseData Is Nothing Then
'			'Check if press matches what we're looking for.
			If UCase(strResponse) = UCase(theResponseData.Resp) Then
				Set GetLastResponseData = theResponseData
				Exit Function
			End If
		End If
	End If

	'If the script gets to this point, the key is assumed to have never been
	'pressed (assumed release).
	Set GetLastResponseData = Nothing
	Keyboard.History.RemoveAll
	incount = 0

End Function




'''  //////////////////////////////////////////-------------------------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ '''
'''  //////////////////////////////////////////   <EyeLink Variables>   \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ '''
'''  //////////////////////////////////////////-------------------------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ '''
Dim sent As Integer					'Used to initiate functions sending messages to Host - numeric return.
'Dim TrialNum As Integer				'TrialNumber
'Dim elMessageManipulation As String	'Message Manipulation variable, determines to pull from neutral or reward lists
'Dim elWakeNum As Integer			'Code for wakefulness of eyes; 1=Awake, 2=Droopy(eyes)
'Dim SlideInputCount As Integer		'Counts number of inputs for each slide, used for keyboard subroutines
Dim EDFInputCount As Integer		'Counts total number of inputs for in EDF File, used for staff input message functions.






'''  //////////////////////////////////////////-------------------------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ '''
'''  ////////////////////////////////////////<EyeLink Messaging Functions>\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ '''
'''  //////////////////////////////////////////-------------------------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ '''
''' "Tracker.SendMessage" Files write information into the datafile. "Tracker.SendCommand" writes information onto the
''' Host PC Monitor during testing.

'TrialID Messages initiate a Trial for the EDF File
Function elSendTrialID(TrialNum As Integer) As Integer
	tracker.sendMessage "TRIALID " & TrialNum & " 0 "  & " " & TOLconditions.GetCurrentAttrib("Procedure")
End Function


' 202040402WF - send message if have eyelink. used to notify if shock or reponse
Function elMaybeMsg( mymsg As String) As Integer
	If TRACKERHARDWARE = "EyeLink" Then
		tracker.sendMessage mymsg
		tracker.sendCommand "record_status_message '" & mymsg & "'"
		sent = 1
	Else
		sent = 0
	End If
End Function


'EventID Messages write event codes into the data file
Function elSendEventID(code As Integer) As Integer
	tracker.sendCommand "record_status_message 'EventID " & TrialNum & " " & code 
	tracker.sendMessage "EventID " & TrialNum & " " & code
	sent=1
End Function

' 20240402WF - close current file and save localy
Sub elCloseFileMaybe(el_local_filename As String)
	If TRACKERHARDWARE = "EyeLink" Then
		tracker.closeDataFile ' close data file 
		tracker.setOfflineMode  ' set offline mode so we can transfer file 
		sleep 500 ' delay so tracker is ready 
		Dim output_edf As String
		'output_edf = c.GetAttrib("Subject") & "_" & c.GetAttrib("Session") & "_" & c.GetAttrib("Procedure") & "TIME"
		output_edf = el_local_filename & "_" & Clock.Read & ".edf" ' & "_" & Session.Time 
		tracker.receiveDataFile edfFileName, "./EyeData/" & edfShortName & "/" & output_edf ' get the edf file to display pc
	End If
End Sub

' 20240402WF - how to start recording a new file at the start of each block
Dim EYDPREAMBLE As String
'EYDPREAMBLE = RECORDED BY E-Prime Project " & c.GetAttrib("Experiment") & "_" & c.GetAttrib("Subject")
Sub OpenBlockFile(el_block_num As Integer)
	tracker.closeDataFile ' just in case
	edfFileName = edfShortName & el_block_num & ".EDF" ' shortname in getEDFName called at start
	tracker.openDataFile edfFileName ' open edf file
	' preamble_str =& c.GetAttrib("Experiment")
	tracker.sendCommand "add_file_preamble_text '" & EYDPREAMBLE & "'"
	tracker.startRecording True, True, True, True
    tracker.sendCommand "record_status_message 'STARTING'" 
End Sub

'--------------------------------------------------------------------------
' User Script - END
'--------------------------------------------------------------------------



'--------------------------------------------------------------------------
' Package Global Script
'--------------------------------------------------------------------------



'--------------------------------------------------------------------------
' Implementation
'--------------------------------------------------------------------------


Sub SessionProc_Run(c as Context)
	SessionProc.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	SessionProc.ProcedureStart

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	SessionProc.TimelineStart
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - ConfigureDeviceFlags BEGIN <ConfigureDeviceFlags>
	'''''''''''''''''''''''''''''''''''''''''''''
	USE_SERIAL = False

TRACKERHARDWARE = "EyeLink"
' TODO: not sure how to get Enum in EBasic. using strings instead
' expect options:
'   Arrington   ' Arrington software avotec camera @ MRRC 2018?-2024. 
'   EyeLink     ' SR Research. ip 100.1.1.1
'   None        ' just run the script without things attached (testing)



Select Case TRACKERHARDWARE
	Case "Arrington"
		Debug.Print "Arrington ET"
    Case "EyeLink"
		Debug.Print "EyeLink ET"
		' header for eyd files
		EYDPREAMBLE = "RECORDED BY E-Prime Project " & c.GetAttrib("Experiment") & "_" & c.GetAttrib("Subject")
		On Error GoTo EyeLinkErrorHandle ' see elClose
	Case "None"
	    Debug.Print "No eye tracking"
	Case Else
		MsgBox "Bad TRACKER VALUE " & TRACKER
End Select
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - ConfigureDeviceFlags END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Initializecode BEGIN <Initializecode>
	'''''''''''''''''''''''''''''''''''''''''''''
	c.Setattrib "Continue","1"
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Initializecode END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - initialzeoutput BEGIN <initialzeoutput>
	'''''''''''''''''''''''''''''''''''''''''''''
	'Open Tower of London E-Prime Behavioral Output & Write the header line
open "tol-output-" & c.getattrib("Subject") & ".txt" For Append As #1
write #1, "Start\tGoal\tdifficulty\tCormov\tplanmov\tplancorr\trt"
open "tol-timing-" & c.getattrib("Subject") & ".txt" For Append As #2
write #2, "breakfix\tfixon\tplanon\tfbon\tmaskon"
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - initialzeoutput END
	'''''''''''''''''''''''''''''''''''''''''''''
	
		MenuList.Run c
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - StopPupil BEGIN <StopPupil>
	'''''''''''''''''''''''''''''''''''''''''''''
	'-------------------------------------------------------------------------------

'Create a variable for holding the elapsed time since the experimental event
'occurred.  This value will be included as part of the message for the events
'and will be taken into account automatically by Data Viewer to position the
'message at the appropriate point in time.
Dim offsetValue As Long 'Variable to be set to give the offset for our messages

' 20240402WF - "Goodbye" or not eyelink will skip this block
If Not tracker Is Nothing Then
	'-----SET/LOG STIMULUS ONSET TIME-----------------------------------------------
	
	'The below code sends a message to the eye tracker recording the exact time that
	'the Stimulus screen was displayed (start of trial display).  Since the
	'screen was displayed some time ago, to get the correct time we take the current
	'time in milliseconds (Clock.ReadMillisec), and subtract the 'Stimulus'
	'screen onset time as reported by E-Prime (Stimulus.OnsetTime).  This value
	'is included in the message sent to the eye tracking data file as an offset.
	'Data Viewer will automatically subtract this offset time from the EDF timestamp
	'of the message so the 'Stimulus_Onset' message appears in the proper
	'location in the eye data, with the appropriate trial timestamp.  If you do not
	'use Data Viewer, the offset will appear in the Stimulus_Onset message so
	'that you can note proper onset times by subtracting the offset from the message
	'timestamp.
	'''offsetValue = Clock.ReadMillisec - Stimulus.OnsetTime
	'''tracker.sendMessage offsetValue & " Stimulus_Onset"
	
	'-----SET TRIAL IMAGE INFORMATION (for Data Viewer display)---------------------
	
	'The following code is for EyeLink Data Viewer integration purposes.  See
	'section "Protocol for EyeLink Data to Viewer Integration > Image Commands" of
	'the EyeLink Data Viewer User Manual.
	
	'The IMGLOAD command is used to show a background image in Data Viewer.  This
	'will code the time and location at which the image should appear.  You can
	'choose to use a FILL, CENTER, or TOP_LEFT command, descriptions and examples
	'of which are below:
	
	'A FILL command sizes the image to fill the display
	'tracker.sendMessage offsetValue & " !V IMGLOAD FILL " & _
	'c.GetAttrib("imageName")
	
	'A CENTER command places the center of the image at the specified coordinates.
	'The image will only be re-sized if optional width and height parameters are
	'provided after the coordinates.
	'''tracker.sendMessage offsetValue & " !V IMGLOAD CENTER ../../" & _
	''' c.GetAttrib("imageName") & " " & c.GetAttrib("imXLoc") & " " & _
	''' c.GetAttrib("imYLoc") & " " & c.GetAttrib("imWidth") & " " & _
	''' c.GetAttrib("imHeight")
	
	'A TOP_LEFT command places the top left of the image at the specified
	'coordinates.  The image will only be re-sized if optional width and height
	'parameters are provided after the coordinates.
	'tracker.sendMessage offsetValue & " !V IMGLOAD TOP_LEFT " & _
	'c.GetAttrib("imageName") & " 0 0"
	
	
	'----------------SETTING INTEREST AREAS-----------------------------------------
	
	'The following code is for EyeLink Data Viewer integration purposes.  See
	'section "Protocol for EyeLink Data to Viewer Integration > Interest Area
	'Commands" of the EyeLink Data Viewer User Manual
	
	'The following draws a 200 x 200 pixel interest area at screen center:
	'tracker.sendMessage offsetValue & " !V IAREA RECTANGLE 1 " & Display.XRes/2 _
	'-100 & " " & Display.YRes/2 - 100 & " " & Display.XRes/2 + 100 & " " & _
	'Display.YRes/2 + 100 & " center_rect_ia"
	
	'To draw a 100 pixel diameter circular interest area at screen center:
	'tracker.sendMessage offsetValue & " !V IAREA ELLIPSE 2 " & Display.XRes/2 _
	'-50 & " " & Display.YRes/2 - 50 & " " & Display.XRes/2 + 50 & " " & _
	'Display.YRes/2 + 50 & " center_circ_ia"
	
	'The following example draws a freehand interest area (here a diamond).
	'tracker.sendMessage offsetValue & " !V IAREA FREEHAND 3 512,284 612,384 " & _
	'"512,484 412,384 freehand_ia"
	
	'The following draws a rectangular interest area around the presented image.
	'''tracker.sendMessage offsetValue & " !V IAREA RECTANGLE 1 " & _
	''' c.GetAttrib("imXLoc")-(c.GetAttrib("imWidth")/2) & " " & _
	''' c.GetAttrib("imYLoc")-(c.GetAttrib("imHeight")/2) & " " & _
	''' c.GetAttrib("imXLoc")+(c.GetAttrib("imWidth")/2) & " " & _
	''' c.GetAttrib("imYLoc")+(c.GetAttrib("imHeight")/2) & " " & _
	''' "IMAGE_IA"
	
	'-----SET/LOG STIMULUS REMOVAL TIME---------------------------------------------
	
	'Now we want to mark the onset time of the blank screen in the EDF, which tells
	'us when our image presentation ended.  To do so, we first calculate the
	'offsetValue for our message by subtracting the onset time of the "BlankScreen"
	'display (BlankScreen.OnsetTime) from the current time (Clock.ReadMillisec).
	'''offsetValue = Clock.ReadMillisec - BlankScreen.OnsetTime
	
	'Then we send a message that begins with this offsetValue time.
	'''tracker.sendMessage offsetValue & " BlankScreen_Onset"
	
	'Set screen clear message for Data Viewer as well. 192, 192, 192 is the RGB for
	'our slide background colours (see slide properties).
	'''tracker.sendMessage offsetValue & " !V CLEAR 192 192 192"
	
	'-----STOP RECORDING------------------------------------------------------------
	
	'Here we issue the stop recording command to stop the tracker recording gaze
	'location between trials.
	
	sleep 100 'Allow 100 ms for clean up before ending recording
	tracker.stopRecording
	
	'-----SENDING TRIAL VARIABLE VALUES---------------------------------------------
	'The TRIAL_VAR command sets a trial variable and value for the given trial. 
	'Send one message for each trial condition variable and its corresponding value.
	'Examples of trial variables include trial number, stimulus displayed, RT,
	'accuracy, etc.  Format is:
	'!V TRIAL_VAR <edfVarName> <value>
	
	'Adding trial counter and general E-Prime list columns as variables to the .edf
	'''tracker.sendMessage "!V TRIAL_VAR trial_number " & trialCounter
	'''tracker.sendMessage "!V TRIAL_VAR trial_identifier " & c.GetAttrib("trialid")
	'''tracker.sendMessage "!V TRIAL_VAR picture " & c.GetAttrib("imageName")
	'''tracker.sendMessage "!V TRIAL_VAR maxDuration " & c.GetAttrib("duration")
	'''tracker.sendMessage "!V TRIAL_VAR imWidth " & c.GetAttrib("imWidth")
	
	'Including a sleep 1 line after every 5 contiguous messages to ensure we don't
	'flood the Host.
	sleep 1
	
	'''tracker.sendMessage "!V TRIAL_VAR imHeight " & c.GetAttrib("imHeight")
	'''tracker.sendMessage "!V TRIAL_VAR imXLoc " & c.GetAttrib("imXLoc")
	'''tracker.sendMessage "!V TRIAL_VAR imYLoc " & c.GetAttrib("imYLoc")
	
	'Adding trial performance variables (response time, response given, correct
	'response, accuracy).
	
	'''tracker.sendMessage "!V TRIAL_VAR RT " & Stimulus.RT
	'''tracker.sendMessage "!V TRIAL_VAR response " & Stimulus.RESP
	
	sleep 1
	
	'Add a RESPPressed variable to note whether the trial ended via keypress (1) or
	'not (0).
	'''If Stimulus.RT > 0 Then
	'''	tracker.sendMessage "!V TRIAL_VAR RESPPressed 1"
		'Additionally include a KeyPress message in the .edf at the time the
		'response was issued.
	'''	tracker.sendMessage Clock.ReadMillisec - Stimulus.RTTime & " KeyPress"
	''' Else
	'''	tracker.sendMessage "!V TRIAL_VAR RESPPressed 0"
	'''End If
	
	'''tracker.sendMessage "!V TRIAL_VAR corrResp " & Stimulus.CRESP
	'''tracker.sendMessage "!V TRIAL_VAR trialAccuracy " & Stimulus.ACC
	
	'Adding E-Prime subject and session values as variables to the .edf.
	tracker.sendMessage "Var SubjID " & c.GetAttrib("Subject")
	
	sleep 1
	
	tracker.sendMessage "Var SessNo " & c.GetAttrib("Session")
	
	'Adding camera setup type to the .edf.
	tracker.sendMessage "Var camSetupType " & elCameraSetupType
	
	'The variables set with these messages will be available as Trial Variables in
	'Data Viewer, and can be included in any of the output reports.  In the report
	'variable selection dialog, these user-defined variables will be at the bottom
	'of the list, in blue.
	
	'-----DEFINE END OF TRIAL (for Data Viewer)-------------------------------------
	
	'Write TRIAL_RESULT message to EDF: marks the end of a trial for DataViewer.
	'See DataViewer manual section: Protocol for EyeLink Data to Viewer
	'Integration > Defining the Start and End of a Trial
	''' tracker.sendMessage "TRIAL_RESULT 0" 
End If
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - StopPupil END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - elClose BEGIN <elClose>
	'''''''''''''''''''''''''''''''''''''''''''''
	'-------------------------------------------------------------------------------

'Here we are telling the Host PC to close the .edf file, send a copy of the .edf
'to the Display PC, then shut down the tracker objects in preparation for the
'end of the project.

'Clear the Host PC screen
'The command "clear_screen" erases the tracker display to color 0 (black)

' 20240402WF - Can get here with avotech or with "Goodbye." tracker will be undefined
EyeLinkErrorHandle: ' label for any error, set in config
If Not tracker Is Nothing Then
	tracker.sendCommand "clear_screen 0"
	
	tracker.setOfflineMode  ' set offline mode so we can transfer file 
	Sleep 500 ' delay so tracker is ready 
	tracker.closeDataFile ' close data file 
	'receiveDataFile transfers a copy of the .edf file to the Display PC.
	'Usage: receiveDataFile <source name> <optional path> <destination file name>
	'Note: if no path is specified, the .edf will save to the project directory.
	'The below saves the .edf to /ProjectDirectory/Results/edfname/edfname.edf
	If tracker.isConnected <> -1 Then 'Skip file transfer if in dummy mode.
	    Dim output_edf As String
		output_edf = c.GetAttrib("Subject") & "_" & c.GetAttrib("Session")
		tracker.receiveDataFile edfFileName, "./EyeData/" & output_edf ' get the edf file to display pc
	End If
	Set tracker = Nothing ' release tracker object
	Set elutil  = Nothing ' release eyelink util object
End If




	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - elClose END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	SessionProc.TimelineFinish
	MenuList.EndOfProcedure

	SessionProc.EndOfProcedure

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	SessionProc.ProcedureFinish
End Sub

Sub planproc_Run(c as Context)
	planproc.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	planproc.ProcedureStart
		Fixation2.ResetLoggingProperties
		Correct.ResetLoggingProperties
		Incorrect.ResetLoggingProperties

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	planproc.TimelineStart
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Initialize1 BEGIN <Initialize1>
	'''''''''''''''''''''''''''''''''''''''''''''
	
TrialNum=TrialNum+1

'set goal and current state
posGoal = c.getattrib("posGoal")
posCurrent = c.getattrib("StartState")

'initialize response buttons
res2 = c.getattrib("res2")
res3 = c.getattrib("res3")
res4 = c.getattrib("res4")
res5 = c.getattrib("res5")
res6 = c.getattrib("res6")

'initialize threat warning
Shock = c.GetAttrib("Shock")

'Add directory path to image files 
c.setattrib "posGoal", "Goal\\" & posGoal 
c.setattrib "posCurrent", "Goal\\" & posCurrent  
c.setattrib "res2", "Plan\\Not\\" & res2
c.setattrib "res3", "Plan\\Not\\" & res3
c.setattrib "res4", "Plan\\Not\\" & res4
c.setattrib "res5", "Plan\\Not\\" & res5
c.setattrib "res6", "Plan\\Not\\" & res6
c.setattrib "Shock", "Feed\\" & Shock 

'Start Timing
pStartTime = Clock.Read

Select Case TRACKERHARDWARE
	Case "Arrington"
		Dim VPXstring As String
		Dim tmp As Integer
		tmp=len("dataFile_InsertString" & " " & "'" & c.getattrib("Trialnum") & c.getattrib("Difficulty") & "';")
		VPXstring = "VPX2" & " "  & tmp & ";" & "220;" & "dataFile_InsertString" & " " & "'" & c.getattrib("Trialnum") & c.getattrib("Difficulty") & "';" 
		socket.writestring VPXstring
    Case "EyeLink"
		Dim ELTrialID As String
		ELTrialID = c.getattrib("Trialnum") & "_" & c.getattrib("Procedure") & "_" & c.getattrib("Difficulty") & "_" & c.getattrib("Shock")
		'Print.Debug ELTrialID
		tracker.sendMessage "TRIALID " & ELTrialID
		tracker.sendMessage "!V TRIAL_VAR trial_number " & c.getattrib("Trialnum")
		tracker.sendMessage "!V TRIAL_VAR procedure " & TOLconditions.GetCurrentAttrib("Procedure")
		tracker.sendMessage "!V TRIAL_VAR shock " & c.GetAttrib("Shock")
		tracker.sendMessage "!V TRIAL_VAR correctmoves " & c.GetAttrib("correctmoves")
        tracker.sendCommand "record_status_message 'Start " & ELTrialID & "'" ' send to Host PC status bar
End Select


sleep(100)

If USE_SERIAL Then
'Send event makers
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 30  '43 
	bytesThatMakePulseConfigCommand(3) = 0 	  '202 
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	'Ingeter 4 trigger the channel on STP100C that triggers the digital out lines
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 2
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
	
	'sleep for duration of the pulse allows previous code to execute prior to resetting the lines
	sleep 30
	
	'Resets all stimtracker lines to 0 for pulse duration and command
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 0
	bytesThatMakePulseConfigCommand(3) = 0
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 0
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
End If

fixon = Clock.Read
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Initialize1 END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	Select Case Fixation2.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t

			'Image1
			Set Fixation2_SlideImage = CSlideImage(Fixation2.ActiveSlideState.Objects(ebUCase_I & ebLCase_m & ebLCase_a & ebLCase_g & ebLCase_e & ebDigit_1))
			Fixation2_SlideImage.Filename = c.GetAttrib("Shock") &_ 
				".tif"
			Fixation2_SlideImage.Load
			Set Fixation2_SlideImage = Nothing

	End Select

	
	Fixation2.Run
	
	c.SetAttrib Fixation2.Name & ebDot & ebLogNameOnsetTime, Fixation2.OnsetTime
	c.SetAttrib Fixation2.Name & ebDot & ebLogNameOffsetTime, Fixation2.OffsetTime
	
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - sendtrialtypephase BEGIN <sendtrialtypephase>
	'''''''''''''''''''''''''''''''''''''''''''''
	elapsedtime = (Clock.Read - pStarttime)


planprestimtime = Clock.Read
'Plan.PreRelease =3064

If TRACKERHARDWARE = "EyeLink" Then
	Dim planid As String
	planid = "d" & c.GetAttrib("difficulty") & "_" & c.GetAttrib("Shock")
	tracker.sendCommand "record_status_message 'PLAN " & planid & "'" ' to host pc status area
	tracker.sendMessage "plan_" &  planid ' into eyd file
End If
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - sendtrialtypephase END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label2 BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Label2:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Label2Resume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Label2Resume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label2 END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	
	Select Case Plan.ActiveState
		Case ebUCase_P & ebLCase_o & ebLCase_s & ebUCase_C & ebLCase_u & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_n & ebLCase_t


			'Text3
			Set Plan_SlideText = CSlideText(Plan.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_3))
			Plan_SlideText.Text = "TIME LEFT\n" &_ 
				c.GetAttrib("pcountdown") &_ 
				"  sec"
			Set Plan_SlideText = Nothing
			'Image1
			Set Plan_SlideImage = CSlideImage(Plan.ActiveSlideState.Objects(ebUCase_I & ebLCase_m & ebLCase_a & ebLCase_g & ebLCase_e & ebDigit_1))
			Plan_SlideImage.Filename = c.GetAttrib("Shock") &_ 
				".tif"
			Plan_SlideImage.Load
			Set Plan_SlideImage = Nothing
			'res2
			Set Plan_SlideImage = CSlideImage(Plan.ActiveSlideState.Objects(ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_2))
			Plan_SlideImage.Filename = c.GetAttrib("res2") &_ 
				".bmp"
			Plan_SlideImage.Load
			Set Plan_SlideImage = Nothing
			'res3
			Set Plan_SlideImage = CSlideImage(Plan.ActiveSlideState.Objects(ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_3))
			Plan_SlideImage.Filename = c.GetAttrib("res3") &_ 
				".bmp"
			Plan_SlideImage.Load
			Set Plan_SlideImage = Nothing
			'res6
			Set Plan_SlideImage = CSlideImage(Plan.ActiveSlideState.Objects(ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_6))
			Plan_SlideImage.Filename = c.GetAttrib("res6") &_ 
				".bmp"
			Plan_SlideImage.Load
			Set Plan_SlideImage = Nothing
			'res5
			Set Plan_SlideImage = CSlideImage(Plan.ActiveSlideState.Objects(ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_5))
			Plan_SlideImage.Filename = c.GetAttrib("res5") &_ 
				".bmp"
			Plan_SlideImage.Load
			Set Plan_SlideImage = Nothing
			'res4
			Set Plan_SlideImage = CSlideImage(Plan.ActiveSlideState.Objects(ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_4))
			Plan_SlideImage.Filename = c.GetAttrib("res4") &_ 
				".bmp"
			Plan_SlideImage.Load
			Set Plan_SlideImage = Nothing
			'PosGoal
			Set Plan_SlideImage = CSlideImage(Plan.ActiveSlideState.Objects(ebUCase_P & ebLCase_o & ebLCase_s & ebUCase_G & ebLCase_o & ebLCase_a & ebLCase_l))
			Plan_SlideImage.Filename = c.GetAttrib("posgoal") &_ 
				".tif"
			Plan_SlideImage.Load
			Set Plan_SlideImage = Nothing
			'PosCurrent
			Set Plan_SlideImage = CSlideImage(Plan.ActiveSlideState.Objects(ebUCase_P & ebLCase_o & ebLCase_s & ebUCase_C & ebLCase_u & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_n & ebLCase_t))
			Plan_SlideImage.Filename = c.GetAttrib("posCurrent") &_ 
				".tif"
			Plan_SlideImage.Load
			Set Plan_SlideImage = Nothing

	End Select

	
	
	Plan.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		PlanEchoClients.RemoveAll
		Plan.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2 & ebDigit_3 & ebDigit_4 & ebDigit_5, _ 
				ebEmptyText, _ 
				CLng(Plan.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Plan.Run
	
	c.SetAttrib Plan.Name & ebDot & ebLogNameOnsetTime, Plan.OnsetTime
	c.SetAttrib Plan.Name & ebDot & ebLogNameOffsetTime, Plan.OffsetTime
	
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Planresponse BEGIN <Planresponse>
	'''''''''''''''''''''''''''''''''''''''''''''
	'set timing variables
Plan.PreRelease = 0
elapsedtime = (Clock.Read - pStarttime)
slidedur = Clock.Read - planprestimtime
pdur=c.getattrib("plandur")
countdown = (pdur - slidedur)/1000
countdown2= (pdur - slidedur)
c.setattrib "pcountdown", Mid(CStr(countdown), 1, 2)

'set state of planning slidef
Set planState = Plan.States("PosCurrent")

'start determining if a response was made and set it to variable strHit
If PLAN.InputMasks.Responses.Count > 0 Then
	Set keyboardMask = CKeyboardResponseData(PLAN.InputMasks.Responses(1))
	strHit = keyboardMask.RESP
End If

'Code to hihglight a response selection
If strHit = "1" And Mid(c.getattrib("res2"), 6, 1) = "N" And Mid(c.getattrib("res3"), 6, 1) = "N" And Mid(c.getattrib("res4"), 6, 1) = "N"And Mid(c.getattrib("res5"), 6, 1) = "N" And Mid(c.getattrib("res6"), 6, 1) = "N" Then 
	c.setattrib "res2", "Plan\\Clicked\\C" & Mid(c.getattrib("res2"), 11, 1) 
ElseIf strHit = "2" And Mid(c.getattrib("res2"), 6, 1) = "N" And Mid(c.getattrib("res3"), 6, 1) = "N" And Mid(c.getattrib("res4"), 6, 1) = "N"And Mid(c.getattrib("res5"), 6, 1) = "N" And Mid(c.getattrib("res6"), 6, 1) = "N" Then
	c.setattrib "res3", "Plan\\Clicked\\C" & Mid(c.getattrib("res3"), 11, 1) 
ElseIf strHit = "3" And Mid(c.getattrib("res2"), 6, 1) = "N" And Mid(c.getattrib("res3"), 6, 1) = "N" And Mid(c.getattrib("res4"), 6, 1) = "N" And Mid(c.getattrib("res5"), 6, 1) = "N" And Mid(c.getattrib("res6"), 6, 1) = "N" Then 
	c.setattrib "res4", "Plan\\Clicked\\C" & Mid(c.getattrib("res4"), 11, 1) 
ElseIf strHit = "4" And Mid(c.getattrib("res2"), 6, 1) = "N" And Mid(c.getattrib("res3"), 6, 1) = "N" And Mid(c.getattrib("res4"), 6, 1) = "N"And Mid(c.getattrib("res5"), 6, 1) = "N" And Mid(c.getattrib("res6"), 6, 1) = "N" Then 
	c.setattrib "res5", "Plan\\Clicked\\C" & Mid(c.getattrib("res5"), 11, 1) 
ElseIf strHit = "5" And Mid(c.getattrib("res2"), 6, 1) = "N" And Mid(c.getattrib("res3"), 6, 1) = "N" And Mid(c.getattrib("res4"), 6, 1) = "N"And Mid(c.getattrib("res5"), 6, 1) = "N" And Mid(c.getattrib("res6"), 6, 1) = "N" Then 
	c.setattrib "res6", "Plan\\Clicked\\C" & Mid(c.getattrib("res6"), 11, 1) 
End If

'Code to switch selections once they are made
If  strHit = "1" And Mid(c.getattrib("res3"), 6, 1) = "C" Then 
	c.setattrib "res2", "Plan\\Clicked\\C" & Mid(c.getattrib("res2"), 11, 1)
	c.setattrib "res3", "Plan\\Not\\N" & Mid(c.getattrib("res3"), 15, 1) 
ElseIf strHit = "1" And Mid(c.getattrib("res4"), 6, 1) = "C" Then 
	c.setattrib "res2", "Plan\\Clicked\\C" & Mid(c.getattrib("res2"), 11, 1)
	c.setattrib "res4", "Plan\\Not\\N" & Mid(c.getattrib("res4"), 15, 1) 
ElseIf strHit = "1" And Mid(c.getattrib("res5"), 6, 1) = "C" Then 
	c.setattrib "res2", "Plan\\Clicked\\C" & Mid(c.getattrib("res2"), 11, 1)
	c.setattrib "res5", "Plan\\Not\\N" & Mid(c.getattrib("res5"), 15, 1)
ElseIf strHit = "1" And Mid(c.getattrib("res6"), 6, 1) = "C" Then 
	c.setattrib "res2", "Plan\\Clicked\\C" & Mid(c.getattrib("res2"), 11, 1)
	c.setattrib "res6", "Plan\\Not\\N" & Mid(c.getattrib("res6"), 15, 1) 
End If 

If  strHit = "2" And Mid(c.getattrib("res2"), 6, 1) = "C" Then 
	c.setattrib "res3", "Plan\\Clicked\\C" & Mid(c.getattrib("res3"), 11, 1)
	c.setattrib "res2", "Plan\\Not\\N" & Mid(c.getattrib("res2"), 15, 1) 
ElseIf strHit = "2" And Mid(c.getattrib("res4"), 6, 1) = "C" Then 
	c.setattrib "res3", "Plan\\Clicked\\C" & Mid(c.getattrib("res3"), 11, 1)
	c.setattrib "res4", "Plan\\Not\\N" & Mid(c.getattrib("res4"), 15, 1) 
ElseIf strHit = "2" And Mid(c.getattrib("res5"), 6, 1) = "C" Then 
	c.setattrib "res3", "Plan\\Clicked\\C" & Mid(c.getattrib("res3"), 11, 1)
	c.setattrib "res5", "Plan\\Not\\N" & Mid(c.getattrib("res5"), 15, 1)
ElseIf strHit = "2" And Mid(c.getattrib("res6"), 6, 1) = "C" Then 
	c.setattrib "res3", "Plan\\Clicked\\C" & Mid(c.getattrib("res3"), 11, 1)
	c.setattrib "res6", "Plan\\Not\\N" & Mid(c.getattrib("res6"), 15, 1) 
End If 

If  strHit = "3" And Mid(c.getattrib("res2"), 6, 1) = "C" Then 
	c.setattrib "res4", "Plan\\Clicked\\C" & Mid(c.getattrib("res4"), 11, 1)
	c.setattrib "res2", "Plan\\Not\\N" & Mid(c.getattrib("res2"), 15, 1) 
ElseIf strHit = "3" And Mid(c.getattrib("res3"), 6, 1) = "C" Then 
	c.setattrib "res4", "Plan\\Clicked\\C" & Mid(c.getattrib("res4"), 11, 1)
	c.setattrib "res3", "Plan\\Not\\N" & Mid(c.getattrib("res3"), 15, 1) 
ElseIf strHit = "3" And Mid(c.getattrib("res5"), 6, 1) = "C" Then 
	c.setattrib "res4", "Plan\\Clicked\\C" & Mid(c.getattrib("res4"), 11, 1)
	c.setattrib "res5", "Plan\\Not\\N" & Mid(c.getattrib("res5"), 15, 1)
ElseIf strHit = "3" And Mid(c.getattrib("res6"), 6, 1) = "C" Then 
	c.setattrib "res4", "Plan\\Clicked\\C" & Mid(c.getattrib("res4"), 11, 1)
	c.setattrib "res6", "Plan\\Not\\N" & Mid(c.getattrib("res6"), 15, 1) 
End If 

If  strHit = "4" And Mid(c.getattrib("res2"), 6, 1) = "C" Then 
	c.setattrib "res5", "Plan\\Clicked\\C" & Mid(c.getattrib("res5"), 11, 1)
	c.setattrib "res2", "Plan\\Not\\N" & Mid(c.getattrib("res2"), 15, 1) 
ElseIf strHit = "4" And Mid(c.getattrib("res3"), 6, 1) = "C" Then 
	c.setattrib "res5", "Plan\\Clicked\\C" & Mid(c.getattrib("res5"), 11, 1)
	c.setattrib "res3", "Plan\\Not\\N" & Mid(c.getattrib("res3"), 15, 1) 
ElseIf strHit = "4" And Mid(c.getattrib("res4"), 6, 1) = "C" Then 
	c.setattrib "res5", "Plan\\Clicked\\C" & Mid(c.getattrib("res5"), 11, 1)
	c.setattrib "res4", "Plan\\Not\\N" & Mid(c.getattrib("res4"), 15, 1)
ElseIf strHit = "4" And Mid(c.getattrib("res6"), 6, 1) = "C" Then 
	c.setattrib "res5", "Plan\\Clicked\\C" & Mid(c.getattrib("res5"), 11, 1)
	c.setattrib "res6", "Plan\\Not\\N" & Mid(c.getattrib("res6"), 15, 1) 
End If

If  strHit = "5" And Mid(c.getattrib("res2"), 6, 1) = "C" Then 
	c.setattrib "res6", "Plan\\Clicked\\C" & Mid(c.getattrib("res6"), 11, 1)
	c.setattrib "res2", "Plan\\Not\\N" & Mid(c.getattrib("res2"), 15, 1) 
ElseIf strHit = "5" And Mid(c.getattrib("res3"), 6, 1) = "C" Then 
	c.setattrib "res6", "Plan\\Clicked\\C" & Mid(c.getattrib("res6"), 11, 1)
	c.setattrib "res3", "Plan\\Not\\N" & Mid(c.getattrib("res3"), 15, 1) 
ElseIf strHit = "5" And Mid(c.getattrib("res4"), 6, 1) = "C" Then 
	c.setattrib "res6", "Plan\\Clicked\\C" & Mid(c.getattrib("res6"), 11, 1)
	c.setattrib "res4", "Plan\\Not\\N" & Mid(c.getattrib("res4"), 15, 1)
ElseIf strHit = "5" And Mid(c.getattrib("res5"), 6, 1) = "C" Then 
	c.setattrib "res6", "Plan\\Clicked\\C" & Mid(c.getattrib("res6"), 11, 1)
	c.setattrib "res5", "Plan\\Not\\N" & Mid(c.getattrib("res5"), 15, 1) 
End If


'Collect the response for feedback
If Mid(c.getattrib("res2"), 6, 1) = "C" Then 
c.SetAttrib "plannummov" , Mid(c.getattrib("res2"), 15, 1)
ElseIf Mid(c.getattrib("res3"), 6, 1) = "C" Then 
c.SetAttrib "plannummov" , Mid(c.getattrib("res3"), 15, 1)
ElseIf Mid(c.getattrib("res4"), 6, 1) = "C" Then 
c.SetAttrib "plannummov" , Mid(c.getattrib("res4"), 15, 1)
ElseIf Mid(c.getattrib("res5"), 6, 1) = "C" Then 
c.SetAttrib "plannummov" , Mid(c.getattrib("res5"), 15, 1)
ElseIf Mid(c.getattrib("res6"), 6, 1) = "C" Then 
c.SetAttrib "plannummov" , Mid(c.getattrib("res6"), 15, 1)
ElseIf c.getattrib("res2") = "Plan\\Not\\N2" And c.getattrib("res3") = "Plan\\Not\\N3" And c.getattrib("res4") = "Plan\\Not\\N4" And c.getattrib("res5") = "Plan\\Not\\N5" And c.getattrib("res6") = "Plan\\Not\\N6" Then 
c.SetAttrib "plannummov" , 0
End If

Dim elsent As Integer
If strHit = "1" Or strHit = "2" Or strHit = "3" Or strHit = "4" Or strHit = "5" Then
 currt=(Clock.Read-planprestimtime)
 elsent = elMaybeMsg("response_" & strHit)
End If 

'Shock Code
If c.GetAttrib("AShock")="Shock" And countdown2 >= 4000 And countdown2 <=5000 And USE_SERIAL Then
	elsent = elMaybeMsg("shock_" & countdown2) ' TODO: TEST. might spam tracker? what's stepsize?
	'Set the duration of the event marker to cedrus 
	'mp interger 43 on byte 3 and integer 202 on byte 4 combine in binary to sum to 500 ms
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 200  '43 
	bytesThatMakePulseConfigCommand(3) = 0 	  '202 
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	'Ingeter 4 trigger the channel on STP100C that triggers the digital out lines
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 4
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
	
	'sleep for duration of the pulse allows previous code to execute prior to resetting the lines
	sleep 200
	
	'Resets all stimtracker lines to 0 for pulse duration and command
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 0
	bytesThatMakePulseConfigCommand(3) = 0
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 0
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
End If 

If c.GetAttrib("AShock")="Shock" And countdown2 >= 13000 And countdown2 <=14000 And USE_SERIAL Then
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 200  '43 
	bytesThatMakePulseConfigCommand(3) = 0 	  '202 
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	'Ingeter 4 trigger the channel on STP100C that triggers the digital out lines
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 4
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
	
	'sleep for duration of the pulse allows previous code to execute prior to resetting the lines
	sleep 200
	
	'Resets all stimtracker lines to 0 for pulse duration and command
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 0
	bytesThatMakePulseConfigCommand(3) = 0
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 0
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
End If 

If c.GetAttrib("AShock")="Shock" And countdown2 >= 20000 And countdown2 <=21000 And USE_SERIAL  Then
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 200  '43 
	bytesThatMakePulseConfigCommand(3) = 0 	  '202 
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	'Ingeter 4 trigger the channel on STP100C that triggers the digital out lines
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 4
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
	
	'sleep for duration of the pulse allows previous code to execute prior to resetting the lines
	sleep 200
	
	'Resets all stimtracker lines to 0 for pulse duration and command
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 0
	bytesThatMakePulseConfigCommand(3) = 0
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 0
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
End If 


' animation step size is 1s
' jump to label 2 (just before plan slide) and set
' plan duration to 1000ms unless that'll overshoot overshoot block.plandur total
strHit = 0
If slidedur <= (pdur-1000) Then
Plan.Duration = 1000
GoTo Label2
ElseIf slidedur > (pdur-1000) And slidedur <= pdur Then
   tleft=(pdur-slidedur) 
   If tleft >0 Then
   Plan.Duration = tleft
   GoTo Label2
   Else 
   GoTo Label1
   End If 
ElseIf slidedur > pdur Then
   GoTo Label1
End If
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Planresponse END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label1 BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Label1:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Label1Resume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Label1Resume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label1 END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - skiptofeed BEGIN <skiptofeed>
	'''''''''''''''''''''''''''''''''''''''''''''
	elapsedtime = (Clock.Read - pStarttime)
If c.getattrib("correctmoves") = c.getattrib("plannummov") Then 
fbon = Clock.Read
GoTo Label3 
ElseIf c.getattrib("correctmoves") <> c.getattrib("plannummov")Then 
fbon = Clock.Read
GoTo Label4
End If 
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - skiptofeed END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label3 BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Label3:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Label3Resume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Label3Resume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label3 END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		
	Correct.Duration = CLng(c.GetAttrib(ebLCase_f & ebLCase_e & ebLCase_e & ebLCase_d & ebLCase_d & ebLCase_u & ebLCase_r))
	Correct.Run
	
	c.SetAttrib Correct.Name & ebDot & ebLogNameOnsetTime, Correct.OnsetTime
	c.SetAttrib Correct.Name & ebDot & ebLogNameOffsetTime, Correct.OffsetTime
	
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - jumpend BEGIN <jumpend>
	'''''''''''''''''''''''''''''''''''''''''''''
	elapsedtime = (Clock.Read - pStarttime)
GoTo Label5
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - jumpend END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label4 BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Label4:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Label4Resume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Label4Resume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label4 END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		
	Incorrect.Duration = CLng(c.GetAttrib(ebLCase_f & ebLCase_e & ebLCase_e & ebLCase_d & ebLCase_d & ebLCase_u & ebLCase_r))
	Incorrect.Run
	
	c.SetAttrib Incorrect.Name & ebDot & ebLogNameOnsetTime, Incorrect.OnsetTime
	c.SetAttrib Incorrect.Name & ebDot & ebLogNameOffsetTime, Incorrect.OffsetTime
	
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - jumpend1 BEGIN <jumpend1>
	'''''''''''''''''''''''''''''''''''''''''''''
	elapsedtime = (Clock.Read - pStarttime)
GoTo Label5
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - jumpend1 END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label5 BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Label5:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Label5Resume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Label5Resume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label5 END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - InLine13 BEGIN <InLine13>
	'''''''''''''''''''''''''''''''''''''''''''''
	If c.getattrib("correctmoves") = c.getattrib("plannummov") Then
plancorr = 1
Else plancorr = 0
End If
maskon = Clock.Read
write #1, CSTR(c.getattrib("StartState")) & "\t" & CSTR(Mid(c.getattrib("posGoal"), 6, 2)) & "\t" & cstr(c.getattrib("Difficulty")) & "\t" & CSTR(c.getattrib("correctmoves")) & "\t" & cstr(c.getattrib("plannummov")) & "\t" & cstr(plancorr) & "\t" & CSTR(currt)

If TRACKERHARDWARE = "EyeLink" Then
	tracker.sendMessage "TRIAL_RESULT " & plancorr 
	tracker.sendCommand "record_status_message 'TRial cor? " & plancorr & "'" ' to host pc status area
End If
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - InLine13 END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	
	mask.Duration = CLng(c.GetAttrib(ebUCase_I & ebUCase_T & ebUCase_I))
	mask.Run
	c.SetAttrib mask.Name & ebDot & ebLogNameOnsetTime, mask.OnsetTime
	c.SetAttrib mask.Name & ebDot & ebLogNameOffsetTime, mask.OffsetTime
	
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Time BEGIN <Time>
	'''''''''''''''''''''''''''''''''''''''''''''
	elapsedtime = (Clock.Read - pStarttime)
write #2, CSTR(breakfix)& "\t" & CSTR(pStartTime) & "\t" & CSTR(planprestimtime) & "\t" & cstr(fbon) & "\t" & CSTR(maskon)
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Time END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	planproc.TimelineFinish
	Fixation2.EndOfProcedure

	Plan.EndOfProcedure

	Correct.EndOfProcedure

	Incorrect.EndOfProcedure

	mask.EndOfProcedure

	planproc.EndOfProcedure
	c.SetAttrib Fixation2.Name & ebDot & ebLogNameOnsetTime, Fixation2.OnsetTime
	c.SetAttrib Fixation2.Name & ebDot & ebLogNameOffsetTime, Fixation2.OffsetTime
	
	c.SetAttrib Plan.Name & ebDot & ebLogNameOnsetTime, Plan.OnsetTime
	c.SetAttrib Plan.Name & ebDot & ebLogNameOffsetTime, Plan.OffsetTime
	
	c.SetAttrib Correct.Name & ebDot & ebLogNameOnsetTime, Correct.OnsetTime
	c.SetAttrib Correct.Name & ebDot & ebLogNameOffsetTime, Correct.OffsetTime
	
	c.SetAttrib Incorrect.Name & ebDot & ebLogNameOnsetTime, Incorrect.OnsetTime
	c.SetAttrib Incorrect.Name & ebDot & ebLogNameOffsetTime, Incorrect.OffsetTime
	
	c.SetAttrib mask.Name & ebDot & ebLogNameOnsetTime, mask.OnsetTime
	c.SetAttrib mask.Name & ebDot & ebLogNameOffsetTime, mask.OffsetTime
	

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	planproc.ProcedureFinish
End Sub

Sub Menu_Run(c as Context)
	Menu.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Menu.ProcedureStart

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Menu.TimelineStart
	
	
	MenuText.Run
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - MenuChoices BEGIN <MenuChoices>
	'''''''''''''''''''''''''''''''''''''''''''''
	Dim Continue As Integer
Continue=1

Do While Continue>0
	MenuText.InputMasks.Reset
	MenuText.InputMasks.Add Keyboard.CreateInputMask("AB", "", Val(MenuText.Duration), Val("1"), ebEndResponseActionTerminate, True, "", "", "")

 MenuText.Run

 Select Case (MenuText.Resp) 
	Case "A"
        TowerTask.Run c
	Case "B"
	     Goodbye.Run c
		Continue=0
	'Case "C"
	'     Calibrate.Run c
   End Select
Loop


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - MenuChoices END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Menu.TimelineFinish
	MenuText.EndOfProcedure

	Menu.EndOfProcedure

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Menu.ProcedureFinish
End Sub

Sub TowerTask_Run(c as Context)
	TowerTask.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	TowerTask.ProcedureStart
		Instruct2.ResetLoggingProperties

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	TowerTask.TimelineStart
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - GoToEyeHardware BEGIN <GoToEyeHardware>
	'''''''''''''''''''''''''''''''''''''''''''''
	' 20240402WF - currently just skip if not eyelink
If TRACKERHARDWARE <> "EyeLink" Then
  GoTo TowerStart
'Else GoTo EyeLinkConnect
End If
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - GoToEyeHardware END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - EyeLinkConnect BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

EyeLinkConnect:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume EyeLinkConnectResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

EyeLinkConnectResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - EyeLinkConnect END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - elConnect BEGIN <elConnect>
	'''''''''''''''''''''''''''''''''''''''''''''
	'-------------------------------------------------------------------------------

elCameraSetupType = 1 '1 for withCam (allows camera transfer in camera setup) or
			'2 for noCam (no camera transfer, but no transition delays).  See
			'README lines 18 - 36 for more information.

useSuspend = 0 'Controls whether device suspend and resume calls are used.  If
	'using Windows 7 or earlier, set to 1.  Otherwise, leave at 0.  If issues
	'are observed with experiment freezing, try switching this value.

usePriority = 0 'Controls whether thread priority changing calls are used.  If
	'using Windows 7 or earlier, set to 1.  Otherwise, leave at 0.  If issues
	'are observed with experiment freezing, try switching this value.  If both
	'values lead to freezing, please set to 2 -- this enables all but the last
	'thread priority call at the end of the elConnect script, which was seen to
	'cause issues on a small number of Windows 10 systems.

dummyMode = 0 '0 for an active tracker connection (for running a project with
	'eye tracking enabled) or 1 for running in dummy mode (for testing without
	'a connected tracker).

calibrationSoundsOn = 1 '1 to enable calibration sounds, 0 to disable.

'setMouseState True ' show mouse cursor

'Ask edf file name -- limited to 8 alphanumeric characters (plus .edf extension)
'No special characters allowed, barring underscore.  See User Script for code:
getEDFName
Debug.Print "EDF Host PC filename: " & edfFileName

setMouseState False ' hide the mouse cursor

cal_background = "0,0,0" ' Set background color for calibration/validation
			'/drift check screens.  This should be set to match the background
			'color of the main experiment.  
cal_foreground = "255,255,255"       ' Set foreground color for calibration/validation
			'/drift check screens. This is the color of the dots during the
			'calibration/validation/drift check.   
cal_target_size=5 ' Set calibration target circle size:
				  ' withCam - Radius in pixels to the outer circle's outer edge.
				  ' noCam - Radius in pixels to the middle of the line area of
				  '	 the outer circle.
cal_pen_width =5 ' Set calibration target center hole size / pen width:
				 ' withCam - Radius in pixels of the inner circle/inner hole
				 '  size
				 ' noCam - Thickness of outer circle line in pixels.  Half the
				 '  value will fall on either side of the circular line
				 '  specified by cal_target_size, so the diameter of the
				 '  "outside circle" of the calibration dot will extend and the
				 '  diameter of the "inner circle" target hole will shrink.
use_cust_cal = 1 ' 0=off, 1=static image, 2 = video
			' SEE README LINES 62-65.
If use_cust_cal = 1 Then
	cust_cal_stim="eyecaldot.png" 'set calibration target image file
ElseIf use_cust_cal = 2 Then
	cust_cal_stim="Stimuli/EL_calibration.avi" 'set calibration target video
											   ' file
End If

If usePriority > 0 Then
	nPriority = GetOSThreadPriority()
	'Temporarily set the thread priority to a normal application
	'otherwise you will get timed out when connecting to the tracker.
	SetOSThreadPriority 3
End If

'On Error GoTo ErrorHandle
Set elutil = CreateObject("SREYELINK.EyeLinkUtil") 'get instance of EyeLinkUtil
	'(necessary to get information from the Host PC)
Set tracker = CreateObject("SREYELINK.EyeLink") ' get instance of EyeLink object
	'(necessary to interface with the tracker)

If dummyMode = 0 Then
	tracker.open "100.1.1.1",0	' open tracker connection (default IP 100.1.1.1)
ElseIf dummyMode = 1 Then
	tracker.dummyOpen		' open dummy mode connection for testing without an
							' active tracker connection.
End If

Debug.Print "Opening " & edfFileName & " on EyeLink Host PC"
tracker.openDataFile edfFileName ' open edf file
Debug.Print "EDF OPENED"

'Set an attribute "EDFNAMELOG" to log the .edf name chosen into the output
'.edat and .txt files.  This is to help verify .edf/session match-up, if needed.
If Not c.AttribExists("EDFNAMELOG") Then c.SetAttrib "EDFNAMELOG", edfFileName

'Mark the .edf with the E-Prime session information.  Starting the text with
'"RECORDED BY" will make the text available in Data Viewer's Inspector window
'(click the EDF session node in the top panel, then look for the "Recorded By:"
'field in the bottom panel of the Inspector).
tracker.sendCommand "add_file_preamble_text 'RECORDED BY E-Prime Project " _
 & c.GetAttrib("Experiment") & "'"

'Set display coordinates for EyeLink data by entering left, top, right and
'bottom coordinates in screen pixels
tracker.sendCommand "screen_pixel_coords = 0 0 " & Display.XRes-1 & " " &_
 Display.YRes-1

'Set calibration type (e.g., HV9, HV13)
tracker.sendCommand "calibration_type = HV5"

'Write DISPLAY_COORDS message to EDF file: sets display coordinates in
'DataViewer.  See DataViewer manual section: Protocol for EyeLink Data to
'Viewer Integration > Pre-trial Message Commands
tracker.sendMessage "DISPLAY_COORDS 0 0 " & Display.XRes-1 & " " &_
 Display.YRes-1

'Add a message to the EDF reporting refresh rate
tracker.sendMessage "FRAMERATE " & Display.CalculatedRefreshRate

'SET UP TRACKER CONFIGURATION 
'Get EyeLink tracker software version
'getTrackerVersionString() returns the tracker software version.  The version
'number will be 2.x for the EyeLink II, 4.x for the EyeLink 1000, 5.x for the
'EyeLink 1000 Plus, or 6.x for the EyeLink Portable Duo.  This Is used below to
'set whether HTARGET information can be recorded (version >= 4).

Dim el_soft_ver_str As String
Dim el_soft_ver_num As Integer

el_soft_ver_str = trim(tracker.getTrackerVersionString())
If instr (1,el_soft_ver_str,"EYELINK CL") > 0 Then
	el_soft_ver_num = trim(Mid(el_soft_ver_str,len("EYELINK CL")+1))
End If

'SELECT AVAILABLE SAMPLE/EVENT DATA
'See EyeLinkProgrammers Guide manual > Useful EyeLink Commands > File Data
'Control & Link Data Control

'Select which events are saved in the EDF file. Include everything just in case 
tracker.sendCommand "file_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK," _
	& "MESSAGE,BUTTON,INPUT"
	
'Select which events are available online for gaze-contingent experiments.
'Include everything just in case
tracker.sendCommand "link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK," _
	&"BUTTON,FIXUPDATE,INPUT"

'Select the sample data to save in EDF file or have available online. Include
'everything just in case
'Check tracker version and include 'HTARGET' to save head target sticker data
'for supported eye trackers
If el_soft_ver_num >= 4 Then
	tracker.sendCommand "file_sample_data = LEFT,RIGHT,GAZE,HREF,RAW,AREA," _
	& "HTARGET,GAZERES,BUTTON,STATUS,INPUT"
	tracker.sendCommand "link_sample_data = LEFT,RIGHT,GAZE,AREA,HTARGET," _
	& "GAZERES,STATUS,INPUT"
Else
	tracker.sendCommand "file_sample_data = LEFT,RIGHT,GAZE,HREF,RAW,AREA," _
	& "GAZERES,BUTTON,STATUS,INPUT"
	tracker.sendCommand "link_sample_data = LEFT,RIGHT,GAZE,AREA,GAZERES," _
	& "STATUS,INPUT"
End If

'Allow a supported EyeLink Host PC button box to accept calibration or
'drift-check targets via button 5
tracker.sendCommand "button_function 5 'accept_target_fixation'"

'Clear Host PC display from any previus drawing
tracker.sendCommand "clear_screen 0"

If usePriority = 1 Then
	'Reset the thread priority
	SetOSThreadPriority nPriority
End If


Debug.Print "Finished EyeLink Setup"

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - elConnect END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	
	
	elInstructions.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		elInstructionsEchoClients.RemoveAll
		elInstructions.InputMasks.Add Keyboard.CreateInputMask(ebLCase_c & ebUCase_C & ebLCase_v & ebUCase_V & ebLCase_o & ebUCase_O, _ 
				ebEmptyText, _ 
				CLng(elInstructions.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	elInstructions.Run
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - elCameraSetup BEGIN <elCameraSetup>
	'''''''''''''''''''''''''''''''''''''''''''''
	setMouseState False	'ensure mouse cursor is not visible before proceeding.
doCameraSetup	'perform camera setup (C to calibrate, V to validate, O to
				'continue (output/record).
setMouseState False	'ensure mouse cursor is not visible before proceeding.
Debug.Print "Finished EyeLink Calibration"

If Err.Number <> 0 Then
	Debug.Print Err.Description
	Err.Clear
	' 202040402WF - "58: File already exists" even for new files
	' Err.Number, Err.Source, Err.Description
End If
	
' Err.Clear
sleep  100
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - elCameraSetup END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - TowerStart BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

TowerStart:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume TowerStartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

TowerStartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - TowerStart END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	
	
	
	Instruct.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		InstructEchoClients.RemoveAll
		Instruct.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Instruct.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Instruct.Run
	
	
	
	Instruct2.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		Instruct2EchoClients.RemoveAll
		Instruct2.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Instruct2.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Instruct2.Run
		TOLconditions.Run c
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - closeoutputfile BEGIN <closeoutputfile>
	'''''''''''''''''''''''''''''''''''''''''''''
	close #1
close #2
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - closeoutputfile END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	TowerTask.TimelineFinish
	elInstructions.EndOfProcedure

	Instruct.EndOfProcedure

	Instruct2.EndOfProcedure

	TOLconditions.EndOfProcedure

	TowerTask.EndOfProcedure

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	TowerTask.ProcedureFinish
End Sub

Sub goodbye_Run(c as Context)
	goodbye.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	goodbye.ProcedureStart

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	goodbye.TimelineStart
	
	
	Goodbyetxt.Run
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	goodbye.TimelineFinish
	Goodbyetxt.EndOfProcedure

	goodbye.EndOfProcedure

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	goodbye.ProcedureFinish
End Sub

Sub Breakproc_Run(c as Context)
	Breakproc.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Breakproc.ProcedureStart

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Breakproc.TimelineStart
	
	
	
	Standby.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		StandbyEchoClients.RemoveAll
		Standby.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Standby.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Standby.Run
	
	
	
	Waitingforpup.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		WaitingforpupEchoClients.RemoveAll
		Waitingforpup.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & "=" & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Waitingforpup.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Waitingforpup.Run
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - openpupfile1 BEGIN <openpupfile1>
	'''''''''''''''''''''''''''''''''''''''''''''
	Dim pupfname As String
Dim tmp As Integer
If TRACKERHARDWARE = "None" Then
	Debug.Print "NO EYE TRACKING"
ElseIf TRACKERHARDWARE = "Arrington" Then
	tmp=len("dataFile_NewName" & " " & "'TOL_pup_"&"1_" & c.GetAttrib("Subject") & ".txt';")
	pupfname = "VPX2" &" "& tmp & ";220;dataFile_NewName" & " " & "'TOL_pup_"&"1_" & c.GetAttrib("Subject") & ".txt';"
	'debug.print pupfname
	socket.writestring pupfname
	sleep(100)
	socket.writeString "VPX2 29;220;dataFile_asynchStringData No;"
ElseIf TRACKERHARDWARE = "EyeLink" Then
	Dim status As Integer
    'status = elSendTrialID(1) ' 20240402WF - all in same file. dont need this
	Debug.Print "ET block 1. opening file"
	OpenBlockFile(1)
	' edfShortName
End If

sleep(100)

If USE_SERIAL Then
'Send event makers
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 30  '43 
	bytesThatMakePulseConfigCommand(3) = 0 	  '202 
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	'Ingeter 4 trigger the channel on STP100C that triggers the digital out lines
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 1
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
	
	'sleep for duration of the pulse allows previous code to execute prior to resetting the lines
	sleep 30
	
	'Resets all stimtracker lines to 0 for pulse duration and command
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 0
	bytesThatMakePulseConfigCommand(3) = 0
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 0
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines

Else
   ' we sleep for 30 between serial events
   sleep 30
End If

breakfix = Clock.Read


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - openpupfile1 END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	
	Fixation.Run
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetDelay, Fixation.OnsetDelay
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetTime, Fixation.OnsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDurationError, Fixation.DurationError
	c.SetAttrib Fixation.Name & ebDot & ebLogNamePreRelease, Fixation.PreRelease
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDuration, Fixation.Duration
	c.SetAttrib Fixation.Name & ebDot & ebLogNameStartTime, Fixation.StartTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOffsetTime, Fixation.OffsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRTTime, Fixation.RTTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameACC, Fixation.ACC
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRT, Fixation.RT
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRESP, Fixation.RESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameCRESP, Fixation.CRESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation.OnsetToOnsetTime
	
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Breakproc.TimelineFinish
	Standby.EndOfProcedure

	Waitingforpup.EndOfProcedure

	Fixation.EndOfProcedure

	Breakproc.EndOfProcedure
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetDelay, Fixation.OnsetDelay
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetTime, Fixation.OnsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDurationError, Fixation.DurationError
	c.SetAttrib Fixation.Name & ebDot & ebLogNamePreRelease, Fixation.PreRelease
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDuration, Fixation.Duration
	c.SetAttrib Fixation.Name & ebDot & ebLogNameStartTime, Fixation.StartTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOffsetTime, Fixation.OffsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRTTime, Fixation.RTTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameACC, Fixation.ACC
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRT, Fixation.RT
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRESP, Fixation.RESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameCRESP, Fixation.CRESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation.OnsetToOnsetTime
	

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Breakproc.ProcedureFinish
End Sub







Sub Beakprocshock_Run(c as Context)
	Beakprocshock.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock.ProcedureStart
		SAMDdid.ResetLoggingProperties
		shockcheck.ResetLoggingProperties
		CD5.ResetLoggingProperties
		CD4.ResetLoggingProperties
		CD3.ResetLoggingProperties
		CD2.ResetLoggingProperties
		CD1.ResetLoggingProperties
		Fixation3.ResetLoggingProperties
		shockscale.ResetLoggingProperties
		Moreshock.ResetLoggingProperties
		
	
								
	
	
	

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock.TimelineStart
	
	
	SAMDdid.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		SAMDdidEchoClients.RemoveAll
		SAMDdid.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(SAMDdid.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	SAMDdid.Run
	
	
	
	Standby.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		StandbyEchoClients.RemoveAll
		Standby.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Standby.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Standby.Run
	
	
	shockcheck.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		shockcheckEchoClients.RemoveAll
		shockcheck.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(shockcheck.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	shockcheck.Run
	
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label6 BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Label6:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Label6Resume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Label6Resume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label6 END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	
	CD5.Run
	
	
	CD4.Run
	
	
	CD3.Run
	
	
	CD2.Run
	
	
	CD1.Run
	
	
	Fixation3.Run
	
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOffsetTime, Fixation3.OffsetTime
	
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - shockcode BEGIN <shockcode>
	'''''''''''''''''''''''''''''''''''''''''''''
	'Dim elSent As Integer
'elSent = elMaybeMsg("standby_shock")

If USE_SERIAL Then
	'Shock Code	
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 200  '43 
	bytesThatMakePulseConfigCommand(3) = 0 '202 
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
		
	'Ingeter 4 trigger the channel on STP100C that triggers the digital out lines
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 4
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
		
	'sleep for duration of the pulse allows previous code to execute prior to resetting the lines
	sleep 200
		
	'Resets all stimtracker lines to 0 for pulse duration and command
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 0
	bytesThatMakePulseConfigCommand(3) = 0
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 0
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
Else
    ' keep sleep the same even if not sending
	sleep 200
End If
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - shockcode END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	
	shockscale.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		shockscaleEchoClients.RemoveAll
		shockscale.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(shockscale.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	shockscale.Run
	
	
	
	Moreshock.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		MoreshockEchoClients.RemoveAll
		Moreshock.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2, _ 
				ebEmptyText, _ 
				CLng(Moreshock.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Moreshock.Run
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - InLine1 BEGIN <InLine1>
	'''''''''''''''''''''''''''''''''''''''''''''
	If (Moreshock.RESP = 1) Then
GoTo Label6
End If 
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - InLine1 END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	
	Intelligence.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		IntelligenceEchoClients.RemoveAll
		Intelligence.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Intelligence.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Intelligence.Run
	
	
	Waitingforpup.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		WaitingforpupEchoClients.RemoveAll
		Waitingforpup.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & "=" & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Waitingforpup.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Waitingforpup.Run
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - openpupfile2 BEGIN <openpupfile2>
	'''''''''''''''''''''''''''''''''''''''''''''
	If TRACKERHARDWARE = "Arrington" Then
	Dim pupfname As String
	Dim tmp As Integer
	tmp=len("dataFile_NewName" & " " & "'TOL_pup_"&"2_" & c.GetAttrib("Subject") & ".txt';")
	pupfname = "VPX2" &" "& tmp & ";220;dataFile_NewName" & " " & "'TOL_pup_"&"2_" & c.GetAttrib("Subject") & ".txt';"
	'debug.print pupfname
	socket.writestring pupfname
	sleep(100)
	socket.writeString "VPX2 29;220;dataFile_asynchStringData No;"
	sleep(100)
ElseIf TRACKERHARDWARE = "EyeLink" Then
    Debug.Print "TODO: EyeLink block 2 no new file"
	Dim status As Integer
    'status = elSendTrialID(2)  ' 20240402WF - all in single file.
	Debug.Print "ET block 2. opening file"
	OpenBlockFile(2)
End If

breakfix = Clock.Read
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - openpupfile2 END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	Fixation.Run
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetDelay, Fixation.OnsetDelay
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetTime, Fixation.OnsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDurationError, Fixation.DurationError
	c.SetAttrib Fixation.Name & ebDot & ebLogNamePreRelease, Fixation.PreRelease
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDuration, Fixation.Duration
	c.SetAttrib Fixation.Name & ebDot & ebLogNameStartTime, Fixation.StartTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOffsetTime, Fixation.OffsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRTTime, Fixation.RTTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameACC, Fixation.ACC
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRT, Fixation.RT
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRESP, Fixation.RESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameCRESP, Fixation.CRESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation.OnsetToOnsetTime
	
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock.TimelineFinish
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Beakprocshock_theCollection.RemoveAll
	For Beakprocshock_nObject = 1 To Beakprocshock.ChildObjectCount
		Set Beakprocshock_theInputObject = CRteRunnableInputObject(Rte.GetObject(Beakprocshock.GetChildObjectName(Beakprocshock_nObject)))
		If Not Beakprocshock_theInputObject Is Nothing Then Beakprocshock_theCollection.Add Beakprocshock_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Beakprocshock_bCanExit = True
		For Beakprocshock_nObject = 1 To Beakprocshock_theCollection.Count
			Set Beakprocshock_theInputObject = CRteRunnableInputObject(Beakprocshock_theCollection(Beakprocshock_nObject))
			If Not Beakprocshock_theInputObject Is Nothing Then
				If Beakprocshock_theInputObject.InputMasks.IsPending() Then 
					Beakprocshock_bCanExit = False
					Exit For
				End If
			End If
		Next
		
		' No input masks
		If Beakprocshock_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Beakprocshock_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	
	SAMDdid.EndOfProcedure

	Standby.EndOfProcedure

	shockcheck.EndOfProcedure

	CD5.EndOfProcedure

	CD4.EndOfProcedure

	CD3.EndOfProcedure

	CD2.EndOfProcedure

	CD1.EndOfProcedure

	Fixation3.EndOfProcedure

	shockscale.EndOfProcedure

	Moreshock.EndOfProcedure

	Intelligence.EndOfProcedure

	Waitingforpup.EndOfProcedure

	Fixation.EndOfProcedure

	Beakprocshock.EndOfProcedure
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOffsetTime, Fixation3.OffsetTime
	
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetDelay, Fixation.OnsetDelay
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetTime, Fixation.OnsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDurationError, Fixation.DurationError
	c.SetAttrib Fixation.Name & ebDot & ebLogNamePreRelease, Fixation.PreRelease
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDuration, Fixation.Duration
	c.SetAttrib Fixation.Name & ebDot & ebLogNameStartTime, Fixation.StartTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOffsetTime, Fixation.OffsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRTTime, Fixation.RTTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameACC, Fixation.ACC
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRT, Fixation.RT
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRESP, Fixation.RESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameCRESP, Fixation.CRESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation.OnsetToOnsetTime
	

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock.ProcedureFinish
End Sub

















Sub Beakprocshock3_Run(c as Context)
	Beakprocshock3.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock3.ProcedureStart
		SAMDdid.ResetLoggingProperties
		
	
	
	

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock3.TimelineStart
	
	
	SAMDdid.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		SAMDdidEchoClients.RemoveAll
		SAMDdid.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(SAMDdid.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	SAMDdid.Run
	
	
	
	Standby.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		StandbyEchoClients.RemoveAll
		Standby.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Standby.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Standby.Run
	
	
	Intelligence1.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		Intelligence1EchoClients.RemoveAll
		Intelligence1.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Intelligence1.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Intelligence1.Run
	
	
	Waitingforpup.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		WaitingforpupEchoClients.RemoveAll
		Waitingforpup.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & "=" & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Waitingforpup.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Waitingforpup.Run
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - openpupfile3 BEGIN <openpupfile3>
	'''''''''''''''''''''''''''''''''''''''''''''
	If TRACKERHARDWARE = "Arrington" Then
	Dim pupfname As String
	Dim tmp As Integer
	tmp=len("dataFile_NewName" & " " & "'TOL_pup_"&"3_" & c.GetAttrib("Subject") & ".txt';")
	pupfname = "VPX2" &" "& tmp & ";220;dataFile_NewName" & " " & "'TOL_pup_"&"3_" & c.GetAttrib("Subject") & ".txt';"
	'debug.print pupfname
	socket.writestring pupfname
	sleep(100)
	socket.writeString "VPX2 29;220;dataFile_asynchStringData No;"
	sleep(100)
ElseIf TRACKERHARDWARE = "EyeLink" Then
	Debug.Print "ET block 3. opening file"
	OpenBlockFile(3)
End If

breakfix = Clock.Read
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - openpupfile3 END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	Fixation.Run
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetDelay, Fixation.OnsetDelay
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetTime, Fixation.OnsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDurationError, Fixation.DurationError
	c.SetAttrib Fixation.Name & ebDot & ebLogNamePreRelease, Fixation.PreRelease
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDuration, Fixation.Duration
	c.SetAttrib Fixation.Name & ebDot & ebLogNameStartTime, Fixation.StartTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOffsetTime, Fixation.OffsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRTTime, Fixation.RTTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameACC, Fixation.ACC
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRT, Fixation.RT
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRESP, Fixation.RESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameCRESP, Fixation.CRESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation.OnsetToOnsetTime
	
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock3.TimelineFinish
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Beakprocshock3_theCollection.RemoveAll
	For Beakprocshock3_nObject = 1 To Beakprocshock3.ChildObjectCount
		Set Beakprocshock3_theInputObject = CRteRunnableInputObject(Rte.GetObject(Beakprocshock3.GetChildObjectName(Beakprocshock3_nObject)))
		If Not Beakprocshock3_theInputObject Is Nothing Then Beakprocshock3_theCollection.Add Beakprocshock3_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Beakprocshock3_bCanExit = True
		For Beakprocshock3_nObject = 1 To Beakprocshock3_theCollection.Count
			Set Beakprocshock3_theInputObject = CRteRunnableInputObject(Beakprocshock3_theCollection(Beakprocshock3_nObject))
			If Not Beakprocshock3_theInputObject Is Nothing Then
				If Beakprocshock3_theInputObject.InputMasks.IsPending() Then 
					Beakprocshock3_bCanExit = False
					Exit For
				End If
			End If
		Next
		
		' No input masks
		If Beakprocshock3_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Beakprocshock3_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	
	SAMDdid.EndOfProcedure

	Standby.EndOfProcedure

	Intelligence1.EndOfProcedure

	Waitingforpup.EndOfProcedure

	Fixation.EndOfProcedure

	Beakprocshock3.EndOfProcedure
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetDelay, Fixation.OnsetDelay
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetTime, Fixation.OnsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDurationError, Fixation.DurationError
	c.SetAttrib Fixation.Name & ebDot & ebLogNamePreRelease, Fixation.PreRelease
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDuration, Fixation.Duration
	c.SetAttrib Fixation.Name & ebDot & ebLogNameStartTime, Fixation.StartTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOffsetTime, Fixation.OffsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRTTime, Fixation.RTTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameACC, Fixation.ACC
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRT, Fixation.RT
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRESP, Fixation.RESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameCRESP, Fixation.CRESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation.OnsetToOnsetTime
	

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock3.ProcedureFinish
End Sub

Sub Beakprocshock4_Run(c as Context)
	Beakprocshock4.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock4.ProcedureStart
		SAMDdid.ResetLoggingProperties
		
	
	
	

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock4.TimelineStart
	
	
	SAMDdid.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		SAMDdidEchoClients.RemoveAll
		SAMDdid.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(SAMDdid.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	SAMDdid.Run
	
	
	
	Standby.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		StandbyEchoClients.RemoveAll
		Standby.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Standby.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Standby.Run
	
	
	Intelligence1.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		Intelligence1EchoClients.RemoveAll
		Intelligence1.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Intelligence1.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Intelligence1.Run
	
	
	Waitingforpup.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		WaitingforpupEchoClients.RemoveAll
		Waitingforpup.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & "=" & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Waitingforpup.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Waitingforpup.Run
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - openpupfile4 BEGIN <openpupfile4>
	'''''''''''''''''''''''''''''''''''''''''''''
	If TRACKERHARDWARE = "Arrington" Then
	Dim pupfname As String
	Dim tmp As Integer
	tmp=len("dataFile_NewName" & " " & "'TOL_pup_"&"4_" & c.GetAttrib("Subject") & ".txt';")
	pupfname = "VPX2" &" "& tmp  & ";220;dataFile_NewName" & " " & "'TOL_pup_"&"4_" & c.GetAttrib("Subject") & ".txt';"
	'debug.print pupfname
	socket.writestring pupfname
	sleep(100)
	socket.writeString "VPX2 29;220;dataFile_asynchStringData No;"
	sleep(100)
ElseIf TRACKER = "EyeLink" Then
    Debug.Print "ET block 4. opening file"
	OpenBlockFile(4) 
End If
breakfix = Clock.Read
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - openpupfile4 END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	Fixation.Run
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetDelay, Fixation.OnsetDelay
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetTime, Fixation.OnsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDurationError, Fixation.DurationError
	c.SetAttrib Fixation.Name & ebDot & ebLogNamePreRelease, Fixation.PreRelease
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDuration, Fixation.Duration
	c.SetAttrib Fixation.Name & ebDot & ebLogNameStartTime, Fixation.StartTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOffsetTime, Fixation.OffsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRTTime, Fixation.RTTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameACC, Fixation.ACC
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRT, Fixation.RT
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRESP, Fixation.RESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameCRESP, Fixation.CRESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation.OnsetToOnsetTime
	
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock4.TimelineFinish
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Beakprocshock4_theCollection.RemoveAll
	For Beakprocshock4_nObject = 1 To Beakprocshock4.ChildObjectCount
		Set Beakprocshock4_theInputObject = CRteRunnableInputObject(Rte.GetObject(Beakprocshock4.GetChildObjectName(Beakprocshock4_nObject)))
		If Not Beakprocshock4_theInputObject Is Nothing Then Beakprocshock4_theCollection.Add Beakprocshock4_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Beakprocshock4_bCanExit = True
		For Beakprocshock4_nObject = 1 To Beakprocshock4_theCollection.Count
			Set Beakprocshock4_theInputObject = CRteRunnableInputObject(Beakprocshock4_theCollection(Beakprocshock4_nObject))
			If Not Beakprocshock4_theInputObject Is Nothing Then
				If Beakprocshock4_theInputObject.InputMasks.IsPending() Then 
					Beakprocshock4_bCanExit = False
					Exit For
				End If
			End If
		Next
		
		' No input masks
		If Beakprocshock4_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Beakprocshock4_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	
	SAMDdid.EndOfProcedure

	Standby.EndOfProcedure

	Intelligence1.EndOfProcedure

	Waitingforpup.EndOfProcedure

	Fixation.EndOfProcedure

	Beakprocshock4.EndOfProcedure
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetDelay, Fixation.OnsetDelay
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetTime, Fixation.OnsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDurationError, Fixation.DurationError
	c.SetAttrib Fixation.Name & ebDot & ebLogNamePreRelease, Fixation.PreRelease
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDuration, Fixation.Duration
	c.SetAttrib Fixation.Name & ebDot & ebLogNameStartTime, Fixation.StartTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOffsetTime, Fixation.OffsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRTTime, Fixation.RTTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameACC, Fixation.ACC
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRT, Fixation.RT
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRESP, Fixation.RESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameCRESP, Fixation.CRESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation.OnsetToOnsetTime
	

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock4.ProcedureFinish
End Sub

Sub calibrate_Run(c as Context)
	calibrate.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	calibrate.ProcedureStart

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	calibrate.TimelineStart
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	calibrate.TimelineFinish
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	calibrate_theCollection.RemoveAll
	For calibrate_nObject = 1 To calibrate.ChildObjectCount
		Set calibrate_theInputObject = CRteRunnableInputObject(Rte.GetObject(calibrate.GetChildObjectName(calibrate_nObject)))
		If Not calibrate_theInputObject Is Nothing Then calibrate_theCollection.Add calibrate_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		calibrate_bCanExit = True
		For calibrate_nObject = 1 To calibrate_theCollection.Count
			Set calibrate_theInputObject = CRteRunnableInputObject(calibrate_theCollection(calibrate_nObject))
			If Not calibrate_theInputObject Is Nothing Then
				If calibrate_theInputObject.InputMasks.IsPending() Then 
					calibrate_bCanExit = False
					Exit For
				End If
			End If
		Next
		
		' No input masks
		If calibrate_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	calibrate_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	
	calibrate.EndOfProcedure

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	calibrate.ProcedureFinish
End Sub

Sub cleanup_Run(c as Context)
	cleanup.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	cleanup.ProcedureStart

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	cleanup.TimelineStart
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - closeEyeFile BEGIN <closeEyeFile>
	'''''''''''''''''''''''''''''''''''''''''''''
	
' save eye tracking file. close eye tracking file while we don't need it
Dim eye_suffix As String
eye_suffix = "TOT_" & c.GetAttrib("Subject") & "_" & c.GetAttrib("Session") & "_" & c.GetAttrib("eyesuffix")
elCloseFileMaybe(eye_suffix)
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - closeEyeFile END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	cleanup.TimelineFinish
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	cleanup_theCollection.RemoveAll
	For cleanup_nObject = 1 To cleanup.ChildObjectCount
		Set cleanup_theInputObject = CRteRunnableInputObject(Rte.GetObject(cleanup.GetChildObjectName(cleanup_nObject)))
		If Not cleanup_theInputObject Is Nothing Then cleanup_theCollection.Add cleanup_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		cleanup_bCanExit = True
		For cleanup_nObject = 1 To cleanup_theCollection.Count
			Set cleanup_theInputObject = CRteRunnableInputObject(cleanup_theCollection(cleanup_nObject))
			If Not cleanup_theInputObject Is Nothing Then
				If cleanup_theInputObject.InputMasks.IsPending() Then 
					cleanup_bCanExit = False
					Exit For
				End If
			End If
		Next
		
		' No input masks
		If cleanup_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	cleanup_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	
	cleanup.EndOfProcedure

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	cleanup.ProcedureFinish
End Sub



'--------------------------------------------------------------------------
' PreInitDevices
'
'--------------------------------------------------------------------------
Sub PreInitDevices(c As Context)

End Sub



'--------------------------------------------------------------------------
' PostInitDevices
'
'--------------------------------------------------------------------------
Sub PostInitDevices(c As Context)


	' Log DisplayDevice(s) Refresh Rates
Dim DisplayOpen As Boolean
	DisplayOpen = True
	If c.AttribExists(Display.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then DisplayOpen = CLogical(c.GetAttrib(Display.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If DisplayOpen = True Then
		c.SetAttrib Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e, Format$(Display.CalculatedRefreshRate, ebDigit_0 & ebDot & ebDigit_0 & ebDigit_0 & ebDigit_0)

		'Ensure that the refresh rate is acceptable
		If CLng(Display.CalculatedRefreshRate) = 0 Then
			'WARNING: RefreshRate of 0 (Zero) Detected.  Experiment will assume 60hz to continue. Data collection should NOT be used for time critical analysis.  Please ensure your display adapter is configured with the most recent and device specific driver.\n(Standard Display Adapter under Windows Vista or later is not compatible)
			Dim strDisplayError As String
			strDisplayError = ebUCase_W & ebUCase_A & ebUCase_R & ebUCase_N & ebUCase_I & ebUCase_N & ebUCase_G & ebColon & ebSpace & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e & ebSpace & ebLCase_o & ebLCase_f & ebSpace & ebDigit_0 & ebSpace & ebParenOpen & ebUCase_Z & ebLCase_e & ebLCase_r & ebLCase_o & ebParenClose & ebSpace & ebUCase_D & ebLCase_e & ebLCase_t & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_e & ebLCase_d & ebDot & ebSpace & ebSpace & ebUCase_E & ebLCase_x & ebLCase_p & ebLCase_e & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t & ebSpace & ebLCase_w & ebLCase_i & ebLCase_l & ebLCase_l & ebSpace & ebLCase_a & ebLCase_s & ebLCase_s & ebLCase_u & ebLCase_m & ebLCase_e & ebSpace & ebDigit_6 & ebDigit_0 & ebLCase_h & ebLCase_z & ebSpace & ebLCase_t & ebLCase_o & ebSpace & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_u & ebLCase_e & ebDot & ebSpace & ebUCase_D & ebLCase_a & ebLCase_t & ebLCase_a & ebSpace & ebLCase_c & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebSpace & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_u & ebLCase_l & ebLCase_d & ebSpace & ebUCase_N & ebUCase_O & ebUCase_T & ebSpace & ebLCase_b & ebLCase_e & ebSpace & ebLCase_u & ebLCase_s & ebLCase_e & ebLCase_d & ebSpace & ebLCase_f & ebLCase_o & ebLCase_r & ebSpace & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_e & ebSpace & ebLCase_c & ebLCase_r & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_c & ebLCase_a & ebLCase_l & ebSpace & ebLCase_a & ebLCase_n & ebLCase_a & ebLCase_l & ebLCase_y & ebLCase_s & ebLCase_i & ebLCase_s & ebDot & ebSpace & ebSpace & ebUCase_P & ebLCase_l & ebLCase_e & ebLCase_a & ebLCase_s & ebLCase_e & ebSpace & ebLCase_e & ebLCase_n & ebLCase_s & ebLCase_u & ebLCase_r & ebLCase_e & ebSpace & ebLCase_y & ebLCase_o & ebLCase_u & ebLCase_r & ebSpace & ebLCase_d & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebSpace & ebLCase_a & ebLCase_d & ebLCase_a & ebLCase_p & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_i & ebLCase_s & ebSpace & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_f & ebLCase_i & ebLCase_g & ebLCase_u & ebLCase_r & ebLCase_e & ebLCase_d & ebSpace & ebLCase_w & ebLCase_i & ebLCase_t & ebLCase_h & ebSpace & ebLCase_t & ebLCase_h & ebLCase_e & ebSpace & ebLCase_m & ebLCase_o & ebLCase_s & ebLCase_t & ebSpace & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_e & ebLCase_n & ebLCase_t & ebSpace & ebLCase_a & ebLCase_n & ebLCase_d & ebSpace & ebLCase_d & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebSpace & ebLCase_s & ebLCase_p & ebLCase_e & ebLCase_c & ebLCase_i & ebLCase_f & ebLCase_i & ebLCase_c & ebSpace & ebLCase_d & ebLCase_r & ebLCase_i & ebLCase_v & ebLCase_e & ebLCase_r & ebDot & ebLf & ebParenOpen & ebUCase_S & ebLCase_t & ebLCase_a & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_d & ebSpace & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebSpace & ebUCase_A & ebLCase_d & ebLCase_a & ebLCase_p & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_u & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_r & ebSpace & ebUCase_W & ebLCase_i & ebLCase_n & ebLCase_d & ebLCase_o & ebLCase_w & ebLCase_s & ebSpace & ebUCase_V & ebLCase_i & ebLCase_s & ebLCase_t & ebLCase_a & ebSpace & ebLCase_o & ebLCase_r & ebSpace & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_i & ebLCase_s & ebSpace & ebLCase_n & ebLCase_o & ebLCase_t & ebSpace & ebLCase_c & ebLCase_o & ebLCase_m & ebLCase_p & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_b & ebLCase_l & ebLCase_e & ebParenClose
			Debug.Print strDisplayError
			c.SetAttrib ebUCase_A & ebUCase_W & ebLCase_a & ebLCase_r & ebLCase_n & ebLCase_i & ebLCase_n & ebLCase_g & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e, strDisplayError
		End If

		'Determine RefreshRate range
		Dim dblDisplayMinRefreshRate As Double
		Dim dblDisplayMaxRefreshRate As Double
		dblDisplayMinRefreshRate = 39
		dblDisplayMaxRefreshRate = 201
		If c.AttribExists(Display.Name & ebDot & ebUCase_M & ebLCase_i & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e) Then dblDisplayMinRefreshRate = CDbl(c.GetAttrib(Display.Name & ebDot & ebUCase_M & ebLCase_i & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e))
		If c.AttribExists(Display.Name & ebDot & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e) Then dblDisplayMaxRefreshRate = CDbl(c.GetAttrib(Display.Name & ebDot & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e))

		'Ensure that the refresh rate is within range
		If Display.CalculatedRefreshRate < dblDisplayMinRefreshRate Or Display.CalculatedRefreshRate > dblDisplayMaxRefreshRate Then
			' Only throw error if running fullscreen.
			' If windowed, E-Prime timing isn't guaranteed so we may proceed.
			If Not CLogical(c.GetAttribOrDefault(ebUCase_E & ebLCase_x & ebLCase_p & ebLCase_e & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t & ebDot & ebUCase_W & ebLCase_i & ebLCase_n & ebLCase_d & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_d, ebDigit_0)) Then
				'Unable to obtain a valid refresh rate.\n\nPlease ensure your display adapter is configured with the most recent and device specific driver.\n(Standard Display Adapter under Windows Vista is not compatible)
				Rte.AbortExperiment -999, ebUCase_U & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebSpace & ebLCase_t & ebLCase_o & ebSpace & ebLCase_o & ebLCase_b & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n & ebSpace & ebLCase_a & ebSpace & ebLCase_v & ebLCase_a & ebLCase_l & ebLCase_i & ebLCase_d & ebSpace & ebLCase_r & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebSpace & ebLCase_r & ebLCase_a & ebLCase_t & ebLCase_e & ebDot & ebLf & ebLf & ebUCase_P & ebLCase_l & ebLCase_e & ebLCase_a & ebLCase_s & ebLCase_e & ebSpace & ebLCase_e & ebLCase_n & ebLCase_s & ebLCase_u & ebLCase_r & ebLCase_e & ebSpace & ebLCase_y & ebLCase_o & ebLCase_u & ebLCase_r & ebSpace & ebLCase_d & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebSpace & ebLCase_a & ebLCase_d & ebLCase_a & ebLCase_p & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_i & ebLCase_s & ebSpace & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_f & ebLCase_i & ebLCase_g & ebLCase_u & ebLCase_r & ebLCase_e & ebLCase_d & ebSpace & ebLCase_w & ebLCase_i & ebLCase_t & ebLCase_h & ebSpace & ebLCase_t & ebLCase_h & ebLCase_e & ebSpace & ebLCase_m & ebLCase_o & ebLCase_s & ebLCase_t & ebSpace & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_e & ebLCase_n & ebLCase_t & ebSpace & ebLCase_a & ebLCase_n & ebLCase_d & ebSpace & ebLCase_d & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebSpace & ebLCase_s & ebLCase_p & ebLCase_e & ebLCase_c & ebLCase_i & ebLCase_f & ebLCase_i & ebLCase_c & ebSpace & ebLCase_d & ebLCase_r & ebLCase_i & ebLCase_v & ebLCase_e & ebLCase_r & ebDot & ebLf & ebParenOpen & ebUCase_S & ebLCase_t & ebLCase_a & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_d & ebSpace & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebSpace & ebUCase_A & ebLCase_d & ebLCase_a & ebLCase_p & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_u & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_r & ebSpace & ebUCase_W & ebLCase_i & ebLCase_n & ebLCase_d & ebLCase_o & ebLCase_w & ebLCase_s & ebSpace & ebUCase_V & ebLCase_i & ebLCase_s & ebLCase_t & ebLCase_a & ebSpace & ebLCase_i & ebLCase_s & ebSpace & ebLCase_n & ebLCase_o & ebLCase_t & ebSpace & ebLCase_c & ebLCase_o & ebLCase_m & ebLCase_p & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_b & ebLCase_l & ebLCase_e & ebParenClose
			End If
		End If
	End If
	'Assign the input device to filter for the ButtonDevice
	Button.AttachDevice CInputDevice(Rte.DeviceManager.GetDevice(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_I & ebLCase_n & ebLCase_p & ebLCase_u & ebLCase_t & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_T & ebLCase_o & ebUCase_F & ebLCase_i & ebLCase_l & ebLCase_t & ebLCase_e & ebLCase_r, Mouse.Name)))

	'Assign the DisplayName to filter for the ButtonDevice
	Button.DisplayName = c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e, ebEmptyText)

	Button.ReservedA = c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_A, ebEmptyText)
	Button.ReservedB = c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_B, ebEmptyText)
	Button.ReservedC = c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_C, ebEmptyText)
	Button.ReservedD = c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_D, ebEmptyText)
	Button.ShowHover = c.GetAttribOrDefault(CLogical(Button.Name & ebDot & ebUCase_S & ebLCase_h & ebLCase_o & ebLCase_w & ebUCase_H & ebLCase_o & ebLCase_v & ebLCase_e & ebLCase_r), True)
	Button.ShowDown = c.GetAttribOrDefault(CLogical(Button.Name & ebDot & ebUCase_S & ebLCase_h & ebLCase_o & ebLCase_w & ebUCase_D & ebLCase_o & ebLCase_w & ebLCase_n), True)
	Button.ShowFixated = c.GetAttribOrDefault(CLogical(Button.Name & ebDot & ebUCase_S & ebLCase_h & ebLCase_o & ebLCase_w & ebUCase_F & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_e & ebLCase_d), False)

End Sub



'--------------------------------------------------------------------------
' InitDevices
'
'--------------------------------------------------------------------------
Sub InitDevices(c As Context)

	PreInitDevices c


	Set Display = New DisplayDevice
	Display.Name = ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y

	Dim DisplayDisplayDeviceInfo As DisplayDeviceInfo
	DisplayDisplayDeviceInfo.XRes = 640
	DisplayDisplayDeviceInfo.YRes = 480
	DisplayDisplayDeviceInfo.ColorDepth = 32
	DisplayDisplayDeviceInfo.DisplayIndex = 1
	DisplayDisplayDeviceInfo.UseDesktopSettings = False
	DisplayDisplayDeviceInfo.DefaultColor = Color.White
	DisplayDisplayDeviceInfo.RefreshRateRequested = 0
	DisplayDisplayDeviceInfo.NumPages = 0
	
	'Load values from context if they exist
	If c.AttribExists(Display.Name & ebDot & ebUCase_X & ebUCase_R & ebLCase_e & ebLCase_s) Then DisplayDisplayDeviceInfo.XRes = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_X & ebUCase_R & ebLCase_e & ebLCase_s))
	If c.AttribExists(Display.Name & ebDot & ebUCase_Y & ebUCase_R & ebLCase_e & ebLCase_s) Then DisplayDisplayDeviceInfo.YRes = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_Y & ebUCase_R & ebLCase_e & ebLCase_s))
	If c.AttribExists(Display.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r & ebUCase_D & ebLCase_e & ebLCase_p & ebLCase_t & ebLCase_h) Then DisplayDisplayDeviceInfo.ColorDepth = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r & ebUCase_D & ebLCase_e & ebLCase_p & ebLCase_t & ebLCase_h))
	If c.AttribExists(Display.Name & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x) Then DisplayDisplayDeviceInfo.DisplayIndex = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x))
	If c.AttribExists(Display.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r) Then DisplayDisplayDeviceInfo.DefaultColor = CColor(c.GetAttrib(Display.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r))
	If c.AttribExists(Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_d) Then DisplayDisplayDeviceInfo.RefreshRateRequested = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_d))
	If c.AttribExists(Display.Name & ebDot & ebUCase_N & ebLCase_u & ebLCase_m & ebUCase_P & ebLCase_a & ebLCase_g & ebLCase_e & ebLCase_s) Then DisplayDisplayDeviceInfo.NumPages = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_N & ebLCase_u & ebLCase_m & ebUCase_P & ebLCase_a & ebLCase_g & ebLCase_e & ebLCase_s))
	If c.AttribExists(Display.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_s & ebLCase_k & ebLCase_t & ebLCase_o & ebLCase_p & ebUCase_S & ebLCase_e & ebLCase_t & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s) Then DisplayDisplayDeviceInfo.UseDesktopSettings = CLogical(c.GetAttrib(Display.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_s & ebLCase_k & ebLCase_t & ebLCase_o & ebLCase_p & ebUCase_S & ebLCase_e & ebLCase_t & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s))
	
	'Open the device, unless the context values indicate otherwise
	Dim DisplayOpen As Boolean
	DisplayOpen = True
	If c.AttribExists(Display.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then DisplayOpen = CLogical(c.GetAttrib(Display.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If DisplayOpen = True Then
		Display.Open DisplayDisplayDeviceInfo
		Display.RefreshAlignment = ebDigit_7 & ebDigit_5 & ebPercent
		If c.AttribExists(Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_A & ebLCase_l & ebLCase_i & ebLCase_g & ebLCase_n & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Display.RefreshAlignment = c.GetAttrib(Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_A & ebLCase_l & ebLCase_i & ebLCase_g & ebLCase_n & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t)
			Display.RTAdjustment = 0
		If c.AttribExists(Display.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Display.RTAdjustment = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t))
	End If

	'Enable flipping, if requested
	If c.AttribExists(Display.Name & ebDot & ebUCase_F & ebLCase_l & ebLCase_i & ebLCase_p & ebLCase_p & ebLCase_i & ebLCase_n & ebLCase_g & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d) Then
		Display.FlippingEnabled = CLogical(c.GetAttrib(Display.Name & ebDot & ebUCase_F & ebLCase_l & ebLCase_i & ebLCase_p & ebLCase_p & ebLCase_i & ebLCase_n & ebLCase_g & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d))
	Else
		Display.FlippingEnabled = True
	End If

	Set Keyboard = New KeyboardDevice
	Keyboard.Name = ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_b & ebLCase_o & ebLCase_a & ebLCase_r & ebLCase_d


	Dim KeyboardKeyboardDeviceInfo as KeyboardDeviceInfo
	KeyboardKeyboardDeviceInfo.CollectionMode = ebPressesOnly
	KeyboardKeyboardDeviceInfo.CapsLock = ebCapsLockOff
	KeyboardKeyboardDeviceInfo.NumLock = ebNumLockOn
	'Load values from context if they exist
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e) Then KeyboardKeyboardDeviceInfo.CollectionMode = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e))
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_C & ebLCase_a & ebLCase_p & ebLCase_s & ebUCase_L & ebLCase_o & ebLCase_c & ebLCase_k) Then KeyboardKeyboardDeviceInfo.CapsLock = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_C & ebLCase_a & ebLCase_p & ebLCase_s & ebUCase_L & ebLCase_o & ebLCase_c & ebLCase_k))
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_N & ebLCase_u & ebLCase_m & ebUCase_L & ebLCase_o & ebLCase_c & ebLCase_k) Then KeyboardKeyboardDeviceInfo.NumLock = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_N & ebLCase_u & ebLCase_m & ebUCase_L & ebLCase_o & ebLCase_c & ebLCase_k))
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e) Then KeyboardKeyboardDeviceInfo.EmulateDeviceName = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e)
	
	'Open the device, unless the context values indicate otherwise
	Dim KeyboardOpen As Boolean
	KeyboardOpen = True
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then KeyboardOpen = CLogical(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If KeyboardOpen = True Then
		Keyboard.Open KeyboardKeyboardDeviceInfo
		Keyboard.RTAdjustment = 0
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Keyboard.RTAdjustment = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t))
	
		Keyboard.AutoResponseEnabled = True
		Keyboard.AutoResponseTimeLimitLowerBound = ebDigit_2 & ebDigit_5 & ebPercent
		Keyboard.AutoResponseTimeLimitUpperBound = ebDigit_7 & ebDigit_5 & ebPercent
		Keyboard.AutoResponseTimeLimitWhenInfinite = 1000
		Keyboard.AutoResponseCorrectProbability = ebDigit_8 & ebDigit_0 & ebPercent
		Keyboard.AutoResponseAllowableOverride = ebEmptyText
		Keyboard.AutoResponseMaxCountLowerBound = ebDigit_2 & ebDigit_5 & ebPercent
		Keyboard.AutoResponseMaxCountUpperBound = ebDigit_7 & ebDigit_5 & ebPercent
		Keyboard.AutoResponseDelayBetweenResponses = 30
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d) Then Keyboard.AutoResponseEnabled = CLogical(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d))
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_L & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d) Then Keyboard.AutoResponseTimeLimitLowerBound = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_L & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_U & ebLCase_p & ebLCase_p & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d) Then Keyboard.AutoResponseTimeLimitUpperBound = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_U & ebLCase_p & ebLCase_p & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_W & ebLCase_h & ebLCase_e & ebLCase_n & ebUCase_I & ebLCase_n & ebLCase_f & ebLCase_i & ebLCase_n & ebLCase_i & ebLCase_t & ebLCase_e) Then Keyboard.AutoResponseTimeLimitWhenInfinite = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_W & ebLCase_h & ebLCase_e & ebLCase_n & ebUCase_I & ebLCase_n & ebLCase_f & ebLCase_i & ebLCase_n & ebLCase_i & ebLCase_t & ebLCase_e))
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_b & ebLCase_a & ebLCase_b & ebLCase_i & ebLCase_l & ebLCase_i & ebLCase_t & ebLCase_y) Then Keyboard.AutoResponseCorrectProbability = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_b & ebLCase_a & ebLCase_b & ebLCase_i & ebLCase_l & ebLCase_i & ebLCase_t & ebLCase_y)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_A & ebLCase_l & ebLCase_l & ebLCase_o & ebLCase_w & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebUCase_O & ebLCase_v & ebLCase_e & ebLCase_r & ebLCase_r & ebLCase_i & ebLCase_d & ebLCase_e) Then Keyboard.AutoResponseAllowableOverride = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_A & ebLCase_l & ebLCase_l & ebLCase_o & ebLCase_w & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebUCase_O & ebLCase_v & ebLCase_e & ebLCase_r & ebLCase_r & ebLCase_i & ebLCase_d & ebLCase_e)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_C & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebUCase_L & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d) Then Keyboard.AutoResponseMaxCountLowerBound = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_C & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebUCase_L & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_C & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebUCase_U & ebLCase_p & ebLCase_p & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d) Then Keyboard.AutoResponseMaxCountUpperBound = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_C & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebUCase_U & ebLCase_p & ebLCase_p & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_B & ebLCase_e & ebLCase_t & ebLCase_w & ebLCase_e & ebLCase_e & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebLCase_s) Then Keyboard.AutoResponseDelayBetweenResponses = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_B & ebLCase_e & ebLCase_t & ebLCase_w & ebLCase_e & ebLCase_e & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebLCase_s))
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_S & ebLCase_y & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_m & ebUCase_A & ebLCase_b & ebLCase_o & ebLCase_r & ebLCase_t & ebUCase_W & ebLCase_a & ebLCase_t & ebLCase_c & ebLCase_h & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Keyboard.SystemAbortWatchSequence = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_S & ebLCase_y & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_m & ebUCase_A & ebLCase_b & ebLCase_o & ebLCase_r & ebLCase_t & ebUCase_W & ebLCase_a & ebLCase_t & ebLCase_c & ebLCase_h & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l & ebUCase_E & ebLCase_x & ebLCase_i & ebLCase_t & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Keyboard.ConditionalExitSequence = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l & ebUCase_E & ebLCase_x & ebLCase_i & ebLCase_t & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Keyboard.UserBreakSequence = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
	
	End If

	Set Mouse = New MouseDevice
	Mouse.Name = ebUCase_M & ebLCase_o & ebLCase_u & ebLCase_s & ebLCase_e


	Dim MouseMouseDeviceInfo as MouseDeviceInfo
	MouseMouseDeviceInfo.OpenMode = ebMouseOpenModeDirect
	MouseMouseDeviceInfo.CollectionMode = ebPressesOnly
	MouseMouseDeviceInfo.ShowCursor = False
	'Load values from context if they exist
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e) Then MouseMouseDeviceInfo.OpenMode = CLng(c.GetAttrib(Mouse.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e))
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e) Then MouseMouseDeviceInfo.CollectionMode = CLng(c.GetAttrib(Mouse.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e))
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_S & ebLCase_h & ebLCase_o & ebLCase_w & ebUCase_C & ebLCase_u & ebLCase_r & ebLCase_s & ebLCase_o & ebLCase_r) Then MouseMouseDeviceInfo.ShowCursor = CLng(c.GetAttrib(Mouse.Name & ebDot & ebUCase_S & ebLCase_h & ebLCase_o & ebLCase_w & ebUCase_C & ebLCase_u & ebLCase_r & ebLCase_s & ebLCase_o & ebLCase_r))
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e) Then MouseMouseDeviceInfo.EmulateDeviceName = c.GetAttrib(Mouse.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e)
	
	'Open the device, unless the context values indicate otherwise
	Dim MouseOpen As Boolean
	MouseOpen = True
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then MouseOpen = CLogical(c.GetAttrib(Mouse.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If MouseOpen = True Then
		Mouse.Open MouseMouseDeviceInfo
		If c.AttribExists(Mouse.Name & ebDot & ebUCase_S & ebLCase_y & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_m & ebUCase_A & ebLCase_b & ebLCase_o & ebLCase_r & ebLCase_t & ebUCase_W & ebLCase_a & ebLCase_t & ebLCase_c & ebLCase_h & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Mouse.SystemAbortWatchSequence = c.GetAttrib(Mouse.Name & ebDot & ebUCase_S & ebLCase_y & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_m & ebUCase_A & ebLCase_b & ebLCase_o & ebLCase_r & ebLCase_t & ebUCase_W & ebLCase_a & ebLCase_t & ebLCase_c & ebLCase_h & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
		If c.AttribExists(Mouse.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l & ebUCase_E & ebLCase_x & ebLCase_i & ebLCase_t & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Mouse.ConditionalExitSequence = c.GetAttrib(Mouse.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l & ebUCase_E & ebLCase_x & ebLCase_i & ebLCase_t & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
		If c.AttribExists(Mouse.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Mouse.UserBreakSequence = c.GetAttrib(Mouse.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
			Mouse.RTAdjustment = 0
		If c.AttribExists(Mouse.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Mouse.RTAdjustment = CLng(c.GetAttrib(Mouse.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t))
	
	End If

	Set Socket = New SocketDevice
	Socket.Name = "Socket"

	Dim SocketSocketDeviceInfo As SocketDeviceInfo
	SocketSocketDeviceInfo.Server = "10.48.88.226"
	SocketSocketDeviceInfo.Port = 5000
	SocketSocketDeviceInfo.SocketType = ebProtocolTcp
	SocketSocketDeviceInfo.ByteOrdering = ebByteOrderingNative
	'Load values from context if they exist
	If c.AttribExists(Socket.Name & ".Server") Then SocketSocketDeviceInfo.Server = c.GetAttrib(Socket.Name & ".Server")
	If c.AttribExists(Socket.Name & ".Port") Then SocketSocketDeviceInfo.Port = CLng(c.GetAttrib(Socket.Name & ".Port"))
	If c.AttribExists(Socket.Name & ".SocketType") Then SocketSocketDeviceInfo.SocketType = CLng(c.GetAttrib(Socket.Name & ".SocketType"))
	If c.AttribExists(Socket.Name & ".ByteOrdering") Then SocketSocketDeviceInfo.ByteOrdering = CLng(c.GetAttrib(Socket.Name & ".ByteOrdering"))
	
	Set Button = New ButtonDevice
	Button.Name = ebUCase_B & ebLCase_u & ebLCase_t & ebLCase_t & ebLCase_o & ebLCase_n


	Dim ButtonButtonDeviceInfo as ButtonDeviceInfo
	ButtonButtonDeviceInfo.ResponseTypes = 196862
	ButtonButtonDeviceInfo.DblClickTime = 500
	ButtonButtonDeviceInfo.LongPressTime = 1000
	ButtonButtonDeviceInfo.FixationTime = 3000
	
	'Load values from context if they exist
	'Button.ResponseTypes
	ButtonButtonDeviceInfo.ResponseTypes = CLng(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebLCase_s, ButtonButtonDeviceInfo.ResponseTypes))

	'Button.ResponseTypeDown - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_D & ebLCase_o & ebLCase_w & ebLCase_n, False)), 2, 0))

	'Button.ResponseTypeClick - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_C & ebLCase_l & ebLCase_i & ebLCase_c & ebLCase_k, False)), 4, 0))

	'Button.ResponseTypeDblClick - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_D & ebLCase_b & ebLCase_l & ebUCase_C & ebLCase_l & ebLCase_i & ebLCase_c & ebLCase_k, False)), 8, 0))

	'Button.ResponseTypeHover - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_H & ebLCase_o & ebLCase_v & ebLCase_e & ebLCase_r, False)), 32, 0))

	'Button.ResponseTypeLongpress - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_L & ebLCase_o & ebLCase_n & ebLCase_g & ebLCase_p & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_s, False)), 16, 0))

	'Button.ResponseTypeFixation - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_F & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n, False)), 64, 0))

	'Button.ResponseTypeCheck - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_C & ebLCase_h & ebLCase_e & ebLCase_c & ebLCase_k, False)), 128, 0))

	'Button.ResponseTypeSecondary - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y, False)), 65536, 0))

	'Button.ResponseTypeInactive - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_I & ebLCase_n & ebLCase_a & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_v & ebLCase_e, False)), 131072, 0))

	'Button.ResponseTypeDisabled - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d, False)), 262144, 0))

	'Button.DblClickTime
	ButtonButtonDeviceInfo.DblClickTime = CLng(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_D & ebLCase_b & ebLCase_l & ebUCase_C & ebLCase_l & ebLCase_i & ebLCase_c & ebLCase_k & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e, ButtonButtonDeviceInfo.DblClickTime))

	'Button.LongPressTime
	ButtonButtonDeviceInfo.LongPressTime = CLng(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_L & ebLCase_o & ebLCase_n & ebLCase_g & ebUCase_P & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e, ButtonButtonDeviceInfo.LongPressTime))

	'Button.FixationTime
	ButtonButtonDeviceInfo.FixationTime = CLng(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_F & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e, ButtonButtonDeviceInfo.FixationTime))

	'Button.EmulateDeviceName
	ButtonButtonDeviceInfo.EmulateDeviceName = CStr(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e, ButtonButtonDeviceInfo.EmulateDeviceName))

	
	'Open the device, unless the context values indicate otherwise
	Dim ButtonOpen As Boolean
	ButtonOpen = True
	If c.AttribExists(Button.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then ButtonOpen = CLogical(c.GetAttrib(Button.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If ButtonOpen = True Then
		Button.Open ButtonButtonDeviceInfo

		'Button.RTAdjustment
		Button.RTAdjustment = CLng(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t, 0))

		'Button.PrimaryKeys
		Button.PrimaryKeys = CLng(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s, 255))

		'Button.PrimaryKeys.1 - BitMask
		Button.PrimaryKeys = Button.PrimaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_1, False)), 1, 0))

		'Button.PrimaryKeys.2 - BitMask
		Button.PrimaryKeys = Button.PrimaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_2, False)), 2, 0))

		'Button.PrimaryKeys.3 - BitMask
		Button.PrimaryKeys = Button.PrimaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_3, False)), 4, 0))

		'Button.PrimaryKeys.4 - BitMask
		Button.PrimaryKeys = Button.PrimaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_4, False)), 8, 0))

		'Button.PrimaryKeys.5 - BitMask
		Button.PrimaryKeys = Button.PrimaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_5, False)), 16, 0))

		'Button.PrimaryKeys.6 - BitMask
		Button.PrimaryKeys = Button.PrimaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_6, False)), 32, 0))

		'Button.PrimaryKeys.7 - BitMask
		Button.PrimaryKeys = Button.PrimaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_7, False)), 64, 0))

		'Button.PrimaryKeys.8 - BitMask
		Button.PrimaryKeys = Button.PrimaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_8, False)), 128, 0))

		'Button.SecondaryKeys
		Button.SecondaryKeys = CLng(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s, 255))

		'Button.SecondaryKeys.1 - BitMask
		Button.SecondaryKeys = Button.SecondaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_1, False)), 1, 0))

		'Button.SecondaryKeys.2 - BitMask
		Button.SecondaryKeys = Button.SecondaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_2, False)), 2, 0))

		'Button.SecondaryKeys.3 - BitMask
		Button.SecondaryKeys = Button.SecondaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_3, False)), 4, 0))

		'Button.SecondaryKeys.4 - BitMask
		Button.SecondaryKeys = Button.SecondaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_4, False)), 8, 0))

		'Button.SecondaryKeys.5 - BitMask
		Button.SecondaryKeys = Button.SecondaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_5, False)), 16, 0))

		'Button.SecondaryKeys.6 - BitMask
		Button.SecondaryKeys = Button.SecondaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_6, False)), 32, 0))

		'Button.SecondaryKeys.7 - BitMask
		Button.SecondaryKeys = Button.SecondaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_7, False)), 64, 0))

		'Button.SecondaryKeys.8 - BitMask
		Button.SecondaryKeys = Button.SecondaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_8, False)), 128, 0))

		'Button.UseStartTime
		Button.UseStartTime = CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebUCase_S & ebLCase_t & ebLCase_a & ebLCase_r & ebLCase_t & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e, False))

		
	End If

	Set Serial = New SerialDevice
	Serial.Name = ebUCase_S & ebLCase_e & ebLCase_r & ebLCase_i & ebLCase_a & ebLCase_l

	Dim SerialSerialDeviceInfo As SerialDeviceInfo
	SerialSerialDeviceInfo.CommPort = 3
	SerialSerialDeviceInfo.BaudRate = 115200
	SerialSerialDeviceInfo.DataBits = 8
	SerialSerialDeviceInfo.Parity = ebParityNo
	SerialSerialDeviceInfo.StopBits = ebStopBits1_0
	'Load values from context if they exist
	If c.AttribExists(Serial.Name & ".CommPort") Then SerialSerialDeviceInfo.CommPort = CLng(c.GetAttrib(Serial.Name & ".CommPort"))
	If c.AttribExists(Serial.Name & ".BaudRate") Then SerialSerialDeviceInfo.BaudRate = CLng(c.GetAttrib(Serial.Name & ".BaudRate"))
	If c.AttribExists(Serial.Name & ".DataBits") Then SerialSerialDeviceInfo.DataBits = CLng(c.GetAttrib(Serial.Name & ".DataBits"))
	If c.AttribExists(Serial.Name & ".Parity") Then SerialSerialDeviceInfo.Parity = CLng(c.GetAttrib(Serial.Name & ".Parity"))
	If c.AttribExists(Serial.Name & ".StopBits") Then SerialSerialDeviceInfo.StopBits = CLng(c.GetAttrib(Serial.Name & ".StopBits"))
	
	'Open the device, unless the context values indicate otherwise
	Dim SerialOpen As Boolean
	SerialOpen = True
	If c.AttribExists(Serial.Name & ".Open") Then SerialOpen = CLogical(c.GetAttrib(Serial.Name & ".Open"))
	If SerialOpen = True Then
		Serial.Open SerialSerialDeviceInfo

	End If

	'Init All Devices
	Rte.DeviceManager.Init


	Dim theTheme As SlideButtonTheme
	Dim theFeedback As SlideButtonFeedback

	Set theTheme = New SlideButtonTheme
	theTheme.Name = ebUCase_B & ebLCase_a & ebLCase_s & ebLCase_e & ebUCase_B & ebLCase_u & ebLCase_t & ebLCase_t & ebLCase_o & ebLCase_n
	theTheme.LoadProperties

	Set theTheme = New SlideButtonTheme
	theTheme.Name = ebUCase_B & ebLCase_a & ebLCase_s & ebLCase_e & ebUCase_C & ebLCase_h & ebLCase_o & ebLCase_i & ebLCase_c & ebLCase_e
	theTheme.LoadProperties

	Set theTheme = New SlideButtonTheme
	theTheme.Name = ebUCase_B & ebLCase_a & ebLCase_s & ebLCase_e & ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebLCase_r
	theTheme.LoadProperties

	GetSlideButtonTheme(ebUCase_B & ebLCase_a & ebLCase_s & ebLCase_e & ebUCase_B & ebLCase_u & ebLCase_t & ebLCase_t & ebLCase_o & ebLCase_n).Update
	GetSlideButtonTheme(ebUCase_B & ebLCase_a & ebLCase_s & ebLCase_e & ebUCase_C & ebLCase_h & ebLCase_o & ebLCase_i & ebLCase_c & ebLCase_e).Update
	GetSlideButtonTheme(ebUCase_B & ebLCase_a & ebLCase_s & ebLCase_e & ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebLCase_r).Update
	
	PostInitDevices c

End Sub



'--------------------------------------------------------------------------
' PreInitObjects
'
'--------------------------------------------------------------------------
Sub PreInitObjects(c As Context)

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

End Sub


'--------------------------------------------------------------------------
' PostInitObjects
'
'--------------------------------------------------------------------------
Sub PostInitObjects(c As Context)

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

End Sub


'--------------------------------------------------------------------------
' InitObjects
'
'--------------------------------------------------------------------------
Sub InitObjects(c As Context)

	PreInitObjects c

	Set Plan = New Slide
	Plan.Name = ebUCase_P & ebLCase_l & ebLCase_a & ebLCase_n
	'{C04950CF-1D12-4736-83B9-922115FE8A66}
	Plan.Guid = CGuid(&HC04950CF, &H1D12, &H4736, &H83B9, &H922115FE, &H8A66)
	Plan.Tag = ebEmptyText

	Set PlanEchoClients = New EchoClientCollection

	Plan.LoadProperties

	Set SessionProc = New Procedure
	SessionProc.Name = ebUCase_S & ebLCase_e & ebLCase_s & ebLCase_s & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c
	'{E69E1F21-7317-40DF-91B6-5DAA331FBFA9}
	SessionProc.Guid = CGuid(&HE69E1F21, &H7317, &H40DF, &H91B6, &H5DAA331F, &HBFA9)
	SessionProc.Tag = ebEmptyText

	SessionProc.LoadProperties
	SessionProc.Subroutine = ebUCase_S & ebLCase_e & ebLCase_s & ebLCase_s & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n

	Set planproc = New Procedure
	planproc.Name = ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_n & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c
	'{07F7BE35-F0DE-4BBF-8B65-CA3AE4BD451B}
	planproc.Guid = CGuid(&H07F7BE35, &HF0DE, &H4BBF, &H8B65, &HCA3AE4BD, &H451B)
	planproc.Tag = ebEmptyText

	planproc.LoadProperties
	planproc.Subroutine = ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_n & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n

	Set Fixation = New TextDisplay
	Fixation.Name = ebUCase_F & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n
	'{2EA4420E-7A27-4292-9AE8-37E3A8F341AF}
	Fixation.Guid = CGuid(&H2EA4420E, &H7A27, &H4292, &H9AE8, &H37E3A8F3, &H41AF)
	Fixation.Tag = ebEmptyText

	Fixation.LoadProperties

	Set MenuList = New List
	MenuList.Name = ebUCase_M & ebLCase_e & ebLCase_n & ebLCase_u & ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t
	'{32ECFA94-F3D0-472C-BC30-E49BE7FBB6CB}
	MenuList.Guid = CGuid(&H32ECFA94, &HF3D0, &H472C, &HBC30, &HE49BE7FB, &HB6CB)
	MenuList.Tag = ebEmptyText

	'Initialization for MenuList
	
	Set MenuList.Order = New SequentialOrder
	Set MenuList.Deletion = NoDeletion
	MenuList.ResetEveryRun = False

	MenuList.LoadProperties

	Set MenuList.TerminateCondition = Cycles(1)
	Set MenuList.ResetCondition = Samples(1)
	MenuList.Reset
	
	Set Menu = New Procedure
	Menu.Name = ebUCase_M & ebLCase_e & ebLCase_n & ebLCase_u
	'{355B5886-98B3-4B8F-ACDB-DED154DEC16F}
	Menu.Guid = CGuid(&H355B5886, &H98B3, &H4B8F, &HACDB, &HDED154DE, &HC16F)
	Menu.Tag = ebEmptyText

	Menu.LoadProperties
	Menu.Subroutine = ebUCase_M & ebLCase_e & ebLCase_n & ebLCase_u & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n

	Set TowerTask = New Procedure
	TowerTask.Name = ebUCase_T & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_T & ebLCase_a & ebLCase_s & ebLCase_k
	'{89052989-E072-4C68-89B6-3AC95C9C3674}
	TowerTask.Guid = CGuid(&H89052989, &HE072, &H4C68, &H89B6, &H3AC95C9C, &H3674)
	TowerTask.Tag = ebEmptyText

	TowerTask.LoadProperties
	TowerTask.Subroutine = ebUCase_T & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_T & ebLCase_a & ebLCase_s & ebLCase_k & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n

	Set MenuText = New TextDisplay
	MenuText.Name = ebUCase_M & ebLCase_e & ebLCase_n & ebLCase_u & ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t
	'{B5CC34F5-0E2A-499C-815B-DBEEF47403DC}
	MenuText.Guid = CGuid(&HB5CC34F5, &H0E2A, &H499C, &H815B, &HDBEEF474, &H03DC)
	MenuText.Tag = ebEmptyText

	MenuText.LoadProperties

	Set goodbye = New Procedure
	goodbye.Name = ebLCase_g & ebLCase_o & ebLCase_o & ebLCase_d & ebLCase_b & ebLCase_y & ebLCase_e
	'{0F4699F6-9D2A-4A30-9643-CC8A9D7DED39}
	goodbye.Guid = CGuid(&H0F4699F6, &H9D2A, &H4A30, &H9643, &HCC8A9D7D, &HED39)
	goodbye.Tag = ebEmptyText

	goodbye.LoadProperties
	goodbye.Subroutine = ebLCase_g & ebLCase_o & ebLCase_o & ebLCase_d & ebLCase_b & ebLCase_y & ebLCase_e & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n

	Set Goodbyetxt = New TextDisplay
	Goodbyetxt.Name = ebUCase_G & ebLCase_o & ebLCase_o & ebLCase_d & ebLCase_b & ebLCase_y & ebLCase_e & ebLCase_t & ebLCase_x & ebLCase_t
	'{59E8DAAB-8074-477B-BBCD-5EBCBBE7928E}
	Goodbyetxt.Guid = CGuid(&H59E8DAAB, &H8074, &H477B, &HBBCD, &H5EBCBBE7, &H928E)
	Goodbyetxt.Tag = ebEmptyText

	Goodbyetxt.LoadProperties

	Set Breakproc = New Procedure
	Breakproc.Name = ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c
	'{67F7BF77-CA28-4D76-95BD-3A98D30F9011}
	Breakproc.Guid = CGuid(&H67F7BF77, &HCA28, &H4D76, &H95BD, &H3A98D30F, &H9011)
	Breakproc.Tag = ebEmptyText

	Breakproc.LoadProperties
	Breakproc.Subroutine = ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n

	Set Standby = New TextDisplay
	Standby.Name = ebUCase_S & ebLCase_t & ebLCase_a & ebLCase_n & ebLCase_d & ebLCase_b & ebLCase_y
	'{5A6836DB-5594-48F0-8406-18CA07792279}
	Standby.Guid = CGuid(&H5A6836DB, &H5594, &H48F0, &H8406, &H18CA0779, &H2279)
	Standby.Tag = ebEmptyText

	Set StandbyEchoClients = New EchoClientCollection

	Standby.LoadProperties

	Set Waitingforpup = New TextDisplay
	Waitingforpup.Name = ebUCase_W & ebLCase_a & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_f & ebLCase_o & ebLCase_r & ebLCase_p & ebLCase_u & ebLCase_p
	'{0E42CA41-9C7D-498B-842D-EE966FF6592F}
	Waitingforpup.Guid = CGuid(&H0E42CA41, &H9C7D, &H498B, &H842D, &HEE966FF6, &H592F)
	Waitingforpup.Tag = ebEmptyText

	Set WaitingforpupEchoClients = New EchoClientCollection

	Waitingforpup.LoadProperties

	Set TOLconditions = New List
	TOLconditions.Name = ebUCase_T & ebUCase_O & ebUCase_L & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_s
	'{225E7D0E-DC91-4710-BEE1-7A81A022B67F}
	TOLconditions.Guid = CGuid(&H225E7D0E, &HDC91, &H4710, &HBEE1, &H7A81A022, &HB67F)
	TOLconditions.Tag = ebEmptyText

	'Initialization for TOLconditions
	
	Set TOLconditions.Order = New SequentialOrder
	Set TOLconditions.Deletion = NoDeletion
	TOLconditions.ResetEveryRun = False

	TOLconditions.LoadProperties

	Set TOLconditions.TerminateCondition = Cycles(1)
	Set TOLconditions.ResetCondition = Samples(55)
	TOLconditions.Reset
	
	Set Instruct = New TextDisplay
	Instruct.Name = ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t
	'{734E2D5B-A70F-4FFB-B7A4-7B81248E1E87}
	Instruct.Guid = CGuid(&H734E2D5B, &HA70F, &H4FFB, &HB7A4, &H7B81248E, &H1E87)
	Instruct.Tag = ebEmptyText

	Set InstructEchoClients = New EchoClientCollection

	Instruct.LoadProperties

	Set mask = New TextDisplay
	mask.Name = ebLCase_m & ebLCase_a & ebLCase_s & ebLCase_k
	'{211472E1-3454-4AB2-9281-16307C6FD9EB}
	mask.Guid = CGuid(&H211472E1, &H3454, &H4AB2, &H9281, &H16307C6F, &HD9EB)
	mask.Tag = ebEmptyText

	mask.LoadProperties

	Set Intelligence = New TextDisplay
	Intelligence.Name = ebUCase_I & ebLCase_n & ebLCase_t & ebLCase_e & ebLCase_l & ebLCase_l & ebLCase_i & ebLCase_g & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e
	'{1D78EA40-C4E6-441B-8E8A-40237619715E}
	Intelligence.Guid = CGuid(&H1D78EA40, &HC4E6, &H441B, &H8E8A, &H40237619, &H715E)
	Intelligence.Tag = ebEmptyText

	Set IntelligenceEchoClients = New EchoClientCollection

	Intelligence.LoadProperties

	Set Block1 = New List
	Block1.Name = ebUCase_B & ebLCase_l & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_1
	'{B01D00C3-5587-4428-8CBB-FBB776E54E84}
	Block1.Guid = CGuid(&HB01D00C3, &H5587, &H4428, &H8CBB, &HFBB776E5, &H4E84)
	Block1.Tag = ebEmptyText

	'Initialization for Block1
	
	Set Block1.Order = New SequentialOrder
	Set Block1.Deletion = NoDeletion
	Block1.ResetEveryRun = False

	Block1.LoadProperties

	Set Block1.TerminateCondition = Cycles(1)
	Set Block1.ResetCondition = Samples(13)
	Block1.Reset
	
	Set Incorrect = New Slide
	Incorrect.Name = ebUCase_I & ebLCase_n & ebLCase_c & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t
	'{D15E126F-BCB9-4FA9-A08E-E55E5C9A6944}
	Incorrect.Guid = CGuid(&HD15E126F, &HBCB9, &H4FA9, &HA08E, &HE55E5C9A, &H6944)
	Incorrect.Tag = ebEmptyText

	Incorrect.LoadProperties

	Set Correct = New Slide
	Correct.Name = ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t
	'{2E0A778C-FFD2-4304-8B15-C5DA25F3FD1B}
	Correct.Guid = CGuid(&H2E0A778C, &HFFD2, &H4304, &H8B15, &HC5DA25F3, &HFD1B)
	Correct.Tag = ebEmptyText

	Correct.LoadProperties

	Set Fixation2 = New Slide
	Fixation2.Name = ebUCase_F & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_2
	'{BB0D29E4-FF08-4D92-ADF1-5D5F74D818C5}
	Fixation2.Guid = CGuid(&HBB0D29E4, &HFF08, &H4D92, &HADF1, &H5D5F74D8, &H18C5)
	Fixation2.Tag = ebEmptyText

	Fixation2.LoadProperties

	Set Block2 = New List
	Block2.Name = ebUCase_B & ebLCase_l & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_2
	'{C8419165-84EB-46BB-9B87-07EF69483426}
	Block2.Guid = CGuid(&HC8419165, &H84EB, &H46BB, &H9B87, &H07EF6948, &H3426)
	Block2.Tag = ebEmptyText

	'Initialization for Block2
	
	Set Block2.Order = New SequentialOrder
	Set Block2.Deletion = NoDeletion
	Block2.ResetEveryRun = False

	Block2.LoadProperties

	Set Block2.TerminateCondition = Cycles(1)
	Set Block2.ResetCondition = Samples(11)
	Block2.Reset
	
	Set Block3 = New List
	Block3.Name = ebUCase_B & ebLCase_l & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_3
	'{FD438588-9AA3-42C7-A5E0-6AA92117E3B2}
	Block3.Guid = CGuid(&HFD438588, &H9AA3, &H42C7, &HA5E0, &H6AA92117, &HE3B2)
	Block3.Tag = ebEmptyText

	'Initialization for Block3
	
	Set Block3.Order = New SequentialOrder
	Set Block3.Deletion = NoDeletion
	Block3.ResetEveryRun = False

	Block3.LoadProperties

	Set Block3.TerminateCondition = Cycles(1)
	Set Block3.ResetCondition = Samples(11)
	Block3.Reset
	
	Set Instruct2 = New TextDisplay
	Instruct2.Name = ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t & ebDigit_2
	'{F4CA94AA-57BF-40C3-907B-5D39540E2168}
	Instruct2.Guid = CGuid(&HF4CA94AA, &H57BF, &H40C3, &H907B, &H5D39540E, &H2168)
	Instruct2.Tag = ebEmptyText

	Set Instruct2EchoClients = New EchoClientCollection

	Instruct2.LoadProperties

	Set Beakprocshock = New Procedure
	Beakprocshock.Name = ebUCase_B & ebLCase_e & ebLCase_a & ebLCase_k & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k
	'{982560AD-FE56-4C1A-A494-125821A6F3D4}
	Beakprocshock.Guid = CGuid(&H982560AD, &HFE56, &H4C1A, &HA494, &H125821A6, &HF3D4)
	Beakprocshock.Tag = ebEmptyText

	Beakprocshock.LoadProperties
	Beakprocshock.Subroutine = ebUCase_B & ebLCase_e & ebLCase_a & ebLCase_k & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Beakprocshock_theCollection = New RteCollection

	Set Block4 = New List
	Block4.Name = ebUCase_B & ebLCase_l & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_4
	'{9535BF4F-2D9B-41B9-BD37-B488AAB68CD9}
	Block4.Guid = CGuid(&H9535BF4F, &H2D9B, &H41B9, &HBD37, &HB488AAB6, &H8CD9)
	Block4.Tag = ebEmptyText

	'Initialization for Block4
	
	Set Block4.Order = New SequentialOrder
	Set Block4.Deletion = NoDeletion
	Block4.ResetEveryRun = False

	Block4.LoadProperties

	Set Block4.TerminateCondition = Cycles(1)
	Set Block4.ResetCondition = Samples(11)
	Block4.Reset
	
	Set SAMDdid = New Slide
	SAMDdid.Name = ebUCase_S & ebUCase_A & ebUCase_M & ebUCase_D & ebLCase_d & ebLCase_i & ebLCase_d
	'{5601C391-F65B-407F-9036-AD2CD84F84A0}
	SAMDdid.Guid = CGuid(&H5601C391, &HF65B, &H407F, &H9036, &HAD2CD84F, &H84A0)
	SAMDdid.Tag = ebEmptyText

	Set SAMDdidEchoClients = New EchoClientCollection

	SAMDdid.LoadProperties

	Set Intelligence1 = New TextDisplay
	Intelligence1.Name = ebUCase_I & ebLCase_n & ebLCase_t & ebLCase_e & ebLCase_l & ebLCase_l & ebLCase_i & ebLCase_g & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e & ebDigit_1
	'{1CE8F41F-7F94-402F-BD59-3C7BA43F97E0}
	Intelligence1.Guid = CGuid(&H1CE8F41F, &H7F94, &H402F, &HBD59, &H3C7BA43F, &H97E0)
	Intelligence1.Tag = ebEmptyText

	Set Intelligence1EchoClients = New EchoClientCollection

	Intelligence1.LoadProperties

	Set CD5 = New Slide
	CD5.Name = ebUCase_C & ebUCase_D & ebDigit_5
	'{4D96F879-00A7-42F5-B843-E7973E92ED79}
	CD5.Guid = CGuid(&H4D96F879, &H00A7, &H42F5, &HB843, &HE7973E92, &HED79)
	CD5.Tag = ebEmptyText

	CD5.LoadProperties

	Set CD1 = New Slide
	CD1.Name = ebUCase_C & ebUCase_D & ebDigit_1
	'{C92B9F79-448C-4DE5-8F5D-A516AAF93B76}
	CD1.Guid = CGuid(&HC92B9F79, &H448C, &H4DE5, &H8F5D, &HA516AAF9, &H3B76)
	CD1.Tag = ebEmptyText

	CD1.LoadProperties

	Set CD2 = New Slide
	CD2.Name = ebUCase_C & ebUCase_D & ebDigit_2
	'{D5101BEB-5646-42C2-BE3F-99159F50D4DC}
	CD2.Guid = CGuid(&HD5101BEB, &H5646, &H42C2, &HBE3F, &H99159F50, &HD4DC)
	CD2.Tag = ebEmptyText

	CD2.LoadProperties

	Set CD3 = New Slide
	CD3.Name = ebUCase_C & ebUCase_D & ebDigit_3
	'{8177C68D-4496-436B-83E0-CE25C19E09BE}
	CD3.Guid = CGuid(&H8177C68D, &H4496, &H436B, &H83E0, &HCE25C19E, &H09BE)
	CD3.Tag = ebEmptyText

	CD3.LoadProperties

	Set CD4 = New Slide
	CD4.Name = ebUCase_C & ebUCase_D & ebDigit_4
	'{8DFE1C7D-DA2F-43A9-8C4A-5252167E7B18}
	CD4.Guid = CGuid(&H8DFE1C7D, &HDA2F, &H43A9, &H8C4A, &H5252167E, &H7B18)
	CD4.Tag = ebEmptyText

	CD4.LoadProperties

	Set Fixation3 = New Slide
	Fixation3.Name = ebUCase_F & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_3
	'{E4EBD7EE-A5F4-4952-ADA0-FC64BC3F2CC4}
	Fixation3.Guid = CGuid(&HE4EBD7EE, &HA5F4, &H4952, &HADA0, &HFC64BC3F, &H2CC4)
	Fixation3.Tag = ebEmptyText

	Fixation3.LoadProperties

	Set shockcheck = New TextDisplay
	shockcheck.Name = ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k & ebLCase_c & ebLCase_h & ebLCase_e & ebLCase_c & ebLCase_k
	'{8B17FEC9-BD2D-4739-8BB4-E93839976D7D}
	shockcheck.Guid = CGuid(&H8B17FEC9, &HBD2D, &H4739, &H8BB4, &HE9383997, &H6D7D)
	shockcheck.Tag = ebEmptyText

	Set shockcheckEchoClients = New EchoClientCollection

	shockcheck.LoadProperties

	Set shockscale = New Slide
	shockscale.Name = ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_c & ebLCase_a & ebLCase_l & ebLCase_e
	'{FD4C6EAC-C978-46FA-9A73-11A7F9B303AE}
	shockscale.Guid = CGuid(&HFD4C6EAC, &HC978, &H46FA, &H9A73, &H11A7F9B3, &H03AE)
	shockscale.Tag = ebEmptyText

	Set shockscaleEchoClients = New EchoClientCollection

	shockscale.LoadProperties

	Set Moreshock = New TextDisplay
	Moreshock.Name = ebUCase_M & ebLCase_o & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k
	'{E26EF5B6-221B-4D12-B7F3-2034D9B6B664}
	Moreshock.Guid = CGuid(&HE26EF5B6, &H221B, &H4D12, &HB7F3, &H2034D9B6, &HB664)
	Moreshock.Tag = ebEmptyText

	Set MoreshockEchoClients = New EchoClientCollection

	Moreshock.LoadProperties

	Set Beakprocshock3 = New Procedure
	Beakprocshock3.Name = ebUCase_B & ebLCase_e & ebLCase_a & ebLCase_k & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_3
	'{0C7DE89C-0991-4FF3-B291-75E5BEDF64D7}
	Beakprocshock3.Guid = CGuid(&H0C7DE89C, &H0991, &H4FF3, &HB291, &H75E5BEDF, &H64D7)
	Beakprocshock3.Tag = ebEmptyText

	Beakprocshock3.LoadProperties
	Beakprocshock3.Subroutine = ebUCase_B & ebLCase_e & ebLCase_a & ebLCase_k & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_3 & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Beakprocshock3_theCollection = New RteCollection

	Set Beakprocshock4 = New Procedure
	Beakprocshock4.Name = ebUCase_B & ebLCase_e & ebLCase_a & ebLCase_k & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_4
	'{DBE3BC18-B7C4-4663-AC05-8FD3DF6639CB}
	Beakprocshock4.Guid = CGuid(&HDBE3BC18, &HB7C4, &H4663, &HAC05, &H8FD3DF66, &H39CB)
	Beakprocshock4.Tag = ebEmptyText

	Beakprocshock4.LoadProperties
	Beakprocshock4.Subroutine = ebUCase_B & ebLCase_e & ebLCase_a & ebLCase_k & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_4 & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Beakprocshock4_theCollection = New RteCollection

	Set elInstructions = New TextDisplay
	elInstructions.Name = ebLCase_e & ebLCase_l & ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_s
	'{5CF83845-671E-4E76-9F3C-E2E8A5E3F8ED}
	elInstructions.Guid = CGuid(&H5CF83845, &H671E, &H4E76, &H9F3C, &HE2E8A5E3, &HF8ED)
	elInstructions.Tag = ebEmptyText

	Set elInstructionsEchoClients = New EchoClientCollection

	elInstructions.LoadProperties

	Set calibrate = New Procedure
	calibrate.Name = ebLCase_c & ebLCase_a & ebLCase_l & ebLCase_i & ebLCase_b & ebLCase_r & ebLCase_a & ebLCase_t & ebLCase_e
	'{278152F1-02AC-4FC4-8F9F-BEDA7B48C4D0}
	calibrate.Guid = CGuid(&H278152F1, &H02AC, &H4FC4, &H8F9F, &HBEDA7B48, &HC4D0)
	calibrate.Tag = ebEmptyText

	calibrate.LoadProperties
	calibrate.Subroutine = ebLCase_c & ebLCase_a & ebLCase_l & ebLCase_i & ebLCase_b & ebLCase_r & ebLCase_a & ebLCase_t & ebLCase_e & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set calibrate_theCollection = New RteCollection

	Set cleanup = New Procedure
	cleanup.Name = ebLCase_c & ebLCase_l & ebLCase_e & ebLCase_a & ebLCase_n & ebLCase_u & ebLCase_p
	'{367A5FBB-0A86-437E-A346-2504C8B72682}
	cleanup.Guid = CGuid(&H367A5FBB, &H0A86, &H437E, &HA346, &H2504C8B7, &H2682)
	cleanup.Tag = ebEmptyText

	cleanup.LoadProperties
	cleanup.Subroutine = ebLCase_c & ebLCase_l & ebLCase_e & ebLCase_a & ebLCase_n & ebLCase_u & ebLCase_p & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set cleanup_theCollection = New RteCollection

	PostInitObjects c


End Sub


'--------------------------------------------------------------------------
' InitPackages
'
'--------------------------------------------------------------------------
Sub InitPackages(c As Context)

End Sub



'--------------------------------------------------------------------------
' InitGlobals
'
'--------------------------------------------------------------------------
Sub InitGlobals(c As Context)


	'Assign Context to the StartupInfo object
	Set Rte.StartupInfo.Context = c

	'Load and Transfer external StartupInfo
	Rte.StartupInfo.Load
	Rte.StartupInfo.Transfer

End Sub



'--------------------------------------------------------------------------


'--------------------------------------------------------------------------
'--------------------------------------------------------------------------
' UnInitGlobals
'--------------------------------------------------------------------------
Sub UnInitGlobals()

	'Close the external StartupInfo
	Rte.StartupInfo.Close

End Sub
'--------------------------------------------------------------------------
' UnInitDevices
'--------------------------------------------------------------------------
Sub UnInitDevices()

	'UnInit All Devices
	Rte.DeviceManager.UnInit
	Display.Close
	Set Display = Nothing

	Keyboard.Close
	Set Keyboard = Nothing

	Mouse.Close
	Set Mouse = Nothing


	Set Socket = Nothing

	Button.Close
	Set Button = Nothing


	'Close the SerialDevice
	Serial.Close
	Set Serial = Nothing
End Sub


'--------------------------------------------------------------------------
'--------------------------------------------------------------------------
' UnInitPackages
'--------------------------------------------------------------------------
Sub UnInitPackages()
End Sub


'--------------------------------------------------------------------------
' UnInitObjects
'
'--------------------------------------------------------------------------
Sub UnInitObjects()

	Set Plan = Nothing

	Set PlanEchoClients = Nothing

	Set SessionProc = Nothing

	Set planproc = Nothing

	Set Fixation = Nothing

	Set MenuList = Nothing

	Set Menu = Nothing

	Set TowerTask = Nothing

	Set MenuText = Nothing

	Set goodbye = Nothing

	Set Goodbyetxt = Nothing

	Set Breakproc = Nothing

	Set Standby = Nothing

	Set StandbyEchoClients = Nothing

	Set Waitingforpup = Nothing

	Set WaitingforpupEchoClients = Nothing

	Set TOLconditions = Nothing

	Set Instruct = Nothing

	Set InstructEchoClients = Nothing

	Set mask = Nothing

	Set Intelligence = Nothing

	Set IntelligenceEchoClients = Nothing

	Set Block1 = Nothing

	Set Incorrect = Nothing

	Set Correct = Nothing

	Set Fixation2 = Nothing

	Set Block2 = Nothing

	Set Block3 = Nothing

	Set Instruct2 = Nothing

	Set Instruct2EchoClients = Nothing

	Set Beakprocshock = Nothing

	Set Block4 = Nothing

	Set SAMDdid = Nothing

	Set SAMDdidEchoClients = Nothing

	Set Intelligence1 = Nothing

	Set Intelligence1EchoClients = Nothing

	Set CD5 = Nothing

	Set CD1 = Nothing

	Set CD2 = Nothing

	Set CD3 = Nothing

	Set CD4 = Nothing

	Set Fixation3 = Nothing

	Set shockcheck = Nothing

	Set shockcheckEchoClients = Nothing

	Set shockscale = Nothing

	Set shockscaleEchoClients = Nothing

	Set Moreshock = Nothing

	Set MoreshockEchoClients = Nothing

	Set Beakprocshock3 = Nothing

	Set Beakprocshock4 = Nothing

	Set elInstructions = Nothing

	Set elInstructionsEchoClients = Nothing

	Set calibrate = Nothing

	Set cleanup = Nothing


End Sub


'--------------------------------------------------------------------------
' Main
'
'--------------------------------------------------------------------------
Sub Main()

	' Create and initialize the default context, data file,
	' and provide global access to the context.
	Dim c As Context
	Set c = New Context
	c.Name = "ebContext"
	Set c.DataFile = New DataFile
	c.PushNewFrame
	Set ebContext = c

	' Set the log level names
	c.SetLogLevelName 1, "Session"
	c.SetLogLevelName 2, "Block"
	c.SetLogLevelName 3, "Trial"
	c.SetLogLevelName 4, "SubTrial"
	c.SetLogLevelName 5, "LogLevel5"
	c.SetLogLevelName 6, "LogLevel6"
	c.SetLogLevelName 7, "LogLevel7"
	c.SetLogLevelName 8, "LogLevel8"
	c.SetLogLevelName 9, "LogLevel9"
	c.SetLogLevelName 10, "LogLevel10"

	' Set standard logging items
	ebContext.SetAttrib "Experiment", "TOL072723_EyeLink2024-04-02WF"
	ebContext.SetAttrib "SessionDate", Date$
	ebContext.SetAttrib "SessionTime", Time$
	ebContext.SetAttrib "SessionStartDateTimeUtc", NowUtc()

	'Initialize global variables for packages
	InitGlobals c

	' Initialize the Display Device(s) for runtime
	Dim DisplayDisplayDeviceInfo As DisplayDeviceInfo
	DisplayDisplayDeviceInfo.DefaultColor = Color.White
	DisplayDisplayDeviceInfo.DisplayIndex = 1
	If c.AttribExists(ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDot & ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r) Then DisplayDisplayDeviceInfo.DefaultColor = CColor(c.GetAttrib(ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDot & ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r))
	If c.AttribExists(ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x) Then DisplayDisplayDeviceInfo.DisplayIndex = CLng(c.GetAttrib(ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x))

	
	
	If CLogical(c.GetAttribOrDefault("Experiment.Windowed", "False")) Then
		CreateDefaultPortWindowed DisplayDisplayDeviceInfo.DisplayIndex
	Else
		CreateDefaultPort DisplayDisplayDeviceInfo.DefaultColor, "", DisplayDisplayDeviceInfo.DisplayIndex
	End If
	
	If Basic.OS = ebWin32 Then
		WinActivate "E-Run Experiment Window"
	End If

	' Get the StartupInfo

	' Set the defaults for all of the StartupInfo
	If Not c.AttribExists("Subject") Then c.SetAttrib "Subject", "1"
	If Not c.AttribExists("Session") Then c.SetAttrib "Session", "1"

	' Determine if StartupInfo.UseDefaults exists and is True/False to override prompts for StartupInfo parameters
	Dim bStartupInfoUseDefaults As Boolean
	bStartupInfoUseDefaults = False
	If c.AttribExists("StartupInfo.UseDefaults") Then bStartupInfoUseDefaults = CLogical(c.GetAttrib("StartupInfo.UseDefaults"))
	If Not bStartupInfoUseDefaults Then

		Dim vAnswer As Variant
StartupInfo_Begin:

StartupInfoPrompt_Subject:
		vAnswer = AskBox("Please enter the Subject Number (1-32767, 0=No Data Logging):", c.GetAttrib("Subject"))
		If Not IsEmpty(vAnswer) then
			If Not IsNumeric(vAnswer) then
				MsgBox "Please enter an integer value"
				GoTo StartupInfoPrompt_Subject
			ElseIf CLng(vAnswer) < 0 Then
				MsgBox "The value for Subject must not be less than 0"
				GoTo StartupInfoPrompt_Subject
			ElseIf CLng(vAnswer) > 999999 Then
				MsgBox "The value for Subject must not be greater than 999999"
				GoTo StartupInfoPrompt_Subject
			End If
		Else
			GoTo ExperimentAbort
		End if

		c.SetAttrib "Subject", CStr(vAnswer)

StartupInfoPrompt_Session:
		vAnswer = AskBox("Please enter the Session Number (1-32767):", c.GetAttrib("Session"))
		If Not IsEmpty(vAnswer) then
			If Not IsNumeric(vAnswer) then
				MsgBox "Please enter an integer value"
				GoTo StartupInfoPrompt_Session
			ElseIf CLng(vAnswer) < 1 Then
				MsgBox "The value for Session must not be less than 1"
				GoTo StartupInfoPrompt_Session
			ElseIf CLng(vAnswer) > 32767 Then
				MsgBox "The value for Session must not be greater than 32767"
				GoTo StartupInfoPrompt_Session
			End If
		Else
			GoTo ExperimentAbort
		End if

		c.SetAttrib "Session", CStr(vAnswer)

		' Display the summary
		Dim strSummary As String
		strSummary = "Subject:    " & c.GetAttrib("Subject") & "\n"
		strSummary = strSummary & "Session:    " & c.GetAttrib("Session") & "\n"
		strSummary = strSummary & "\nContinue with the above startup info?"

		Dim nSummaryAnswer As Integer
		nSummaryAnswer = MsgBox(strSummary, ebYesNoCancel, "Summary of Startup Info")
		If nSummaryAnswer = ebNo Then
				GoTo StartupInfo_Begin
		ElseIf nSummaryAnswer = ebCancel Then
				GoTo ExperimentAbort
		End If

	End If


	'Assign the Clock.Scale value
	Clock.Scale = 1.000000

	'If the attribute Clock.Scale.Override exists
	'  then use it for to set the Clock.Scale value
	If c.AttribExists("Clock.Scale.Override") Then
		Clock.Scale = CDbl(c.GetAttrib("Clock.Scale.Override"))
	End If

	' Set the Filenames for the data files
	Dim strFilenameBase As String
	Dim strFilenameRecovery As String
	Dim strFilenameEDAT As String
	Dim strFileNameTXT As String

	'If the attribute DataFile.Filename.Override exists
	'  then use it for the .txt and .edat3 filenames
	If c.AttribExists("DataFile.Filename.Override") Then

		' Set the default Data Filename
		strFilenameBase = CStr(c.GetAttrib("DataFile.Filename.Override"))

	Else

		' Set the default Data Filename
		strFilenameBase = CStr(c.GetAttrib("Experiment")) & "-" & CStr(c.GetAttrib("Subject")) & "-" & CStr(c.GetAttrib("Session"))

	End If

	'Set the name of the data file
	strFilenameRecovery = strFilenameBase & ".txt"
	strFilenameEDAT = strFilenameBase & ".edat3"
	strFileNameTXT = strFilenameBase & "-Export.txt"
	c.DataFile.Filename = strFilenameRecovery
	c.SetAttrib "DataFile.Basename", strFilenameBase

	' If we are logging data, then prompt to overwrite the data file if it exists
	If CLng(c.GetAttrib("Subject")) <> 0 Then
		If FileExists(c.DataFile.Filename) Or FileExists(strFilenameEDAT) Or FileExists(strFileNameTXT) Then
			If ebYes <> MsgBox("WARNING: The data file and/or recovery file already exists:\nFILE: " & c.DataFile.Filename & "\n\nDo you want to overwrite?", ebYesNo) Then
				GoTo ExperimentAbort
			End If
			' If you receive an error here then ensure that your E-Recovery (txt) file or 
			' the edat3 file is not open and then try the experiment run again.
			If FileExists(strFilenameEDAT) Then Kill strFilenameEDAT
			If FileExists(strFileNameTXT) Then Kill strFileNameTXT
			If FileExists(c.DataFile.Filename) Then Kill c.DataFile.Filename
		End If
	End If

	' Set defaults for RandomSeed and GroupNumber if StartupInfo did not assign their values
	If Not c.AttribExists("RandomSeed") Then c.SetAttrib "RandomSeed", PRNG.GetSeed()
	If Not c.AttribExists("Group") Then c.SetAttrib "Group", "1"

	'Set the random seed
	Randomize CLng(c.GetAttrib("RandomSeed"))

	' Initialize Experiment Advisor Properties
	Rte.ExperimentAdvisor.LoadProperties
	If c.AttribExists("Rte.ExperimentAdvisor.Enabled") Then Rte.ExperimentAdvisor.Enabled = CLogical(c.GetAttrib("Rte.ExperimentAdvisor.Enabled"))
	If c.AttribExists("Rte.ExperimentAdvisor.Filename") Then Rte.ExperimentAdvisor.Filename = CStr(c.GetAttrib("Rte.ExperimentAdvisor.Filename"))


	Dim nPriority As Long
	'Priority for init routines
	nPriority = 3

	'Determine if the priority should use the override value
	If c.AttribExists("SetOSThreadPriority.Init.Override") Then
		nPriority = c.GetAttrib("SetOSThreadPriority.Init.Override")
	End If

	'Update E-Prime Priority for INIT routines
	SetOSThreadPriority nPriority

	' Initialize all system devices, packages, and objects
	InitDevices c
	InitPackages c
	InitObjects c

	'Priority for start of experiment
	nPriority = -1

	'Determine if the priority should use the override value
	If c.AttribExists("SetOSThreadPriority.Override") Then
		nPriority = c.GetAttrib("SetOSThreadPriority.Override")
	End If

	'Update E-Prime Priority for start of experiment
	SetOSThreadPriority nPriority

	'Disable System power save mode
	Rte.PreventSystemIdle = True

	If CLng(c.GetAttrib("Subject")) < 0 Then
		Rte.AbortExperiment 12102, ebUCase_S & ebLCase_u & ebLCase_b & ebLCase_j & ebLCase_e & ebLCase_c & ebLCase_t & ebSpace & ebLCase_c & ebLCase_a & ebLCase_n & ebLCase_n & ebLCase_o & ebLCase_t & ebSpace & ebLCase_b & ebLCase_e & ebSpace & ebLCase_l & ebLCase_e & ebLCase_s & ebLCase_s & ebSpace & ebLCase_t & ebLCase_h & ebLCase_a & ebLCase_n & ebSpace & ebDigit_0 & ebDot
	End If

	If CLng(c.GetAttrib("Session")) < 1 Then
		Rte.AbortExperiment 12103, ebUCase_S & ebLCase_e & ebLCase_s & ebLCase_s & ebLCase_i & ebLCase_o & ebLCase_n & ebSpace & ebLCase_c & ebLCase_a & ebLCase_n & ebLCase_n & ebLCase_o & ebLCase_t & ebSpace & ebLCase_b & ebLCase_e & ebSpace & ebLCase_l & ebLCase_e & ebLCase_s & ebLCase_s & ebSpace & ebLCase_t & ebLCase_h & ebLCase_a & ebLCase_n & ebSpace & ebDigit_1 & ebDot
	End If

	' If we are logging data, then open the datafile
	If CLng(c.GetAttrib("Subject")) <> 0 Then
		c.DataFile.Open
		c.LogHeader
	End If


	'Setup the DataFile.BaseName attribute
	c.SetAttrib "DataFile.BaseName", Replace(c.DataFile.Filename, ".txt", ebEmptyText)

	' Log clock timing information
	c.SetAttrib "Clock.Information", Clock.Information

	' Log E-Studio version
	c.SetAttrib "StudioVersion", "3.0.3.214"

	' Log runtime version.
	c.SetAttrib "RuntimeVersion", Rte.Version.Major & ebDot & Rte.Version.Minor & ebDot & Rte.Version.Internal & ebDot & Rte.Version.Build
	c.SetAttrib "RuntimeVersionExpected", 3 & ebDot & 0 & ebDot & 3 & ebDot & 214
	c.SetAttrib "RuntimeCapabilities", ebUCase_F & ebLCase_u & ebLCase_l & ebLCase_l

	' Log experiment version
	c.SetAttrib "ExperimentVersion", "1.0.0.1361"

	' ExperimentStart
	 Rte.ExperimentStart
	' Start the running of the Experiment
	SessionProc.Run c
	' ExperimentFinish
	 Rte.ExperimentFinish

	' Clean up the context and close the datafile
	If CLng(c.GetAttrib("Subject")) <> 0 Then
		Dim nDataFileConvertProgress As Long
		nDataFileConvertProgress = ebProgressSimple
		If c.AttribExists("DataFile.ConvertProgress") Then nDataFileConvertProgress = CLng(c.GetAttrib("DataFile.ConvertProgress"))
		c.DataFile.Close
		' Attempt to convert the recovery file into a data file
		Dim nConvert As Long
		nConvert = c.DataFile.Convert(nDataFileConvertProgress, False)

		If nConvert = 0 Then
			' Settings in E-Studio are set to not remove E-Recovery file
		Else
			' The datafile failed to convert!
			MsgBox "ERROR: The datafile did not convert!\nFILE: " & c.DataFile.Filename & "\n\nIt is recommended that you recover your data with the E-Recovery utility"
			MsgBox c.DataFile.GetLastErrorMessage()
		End If
	End If
ExperimentFinish:

	UnInitObjects

	UnInitPackages
	UnInitDevices

	UnInitGlobals

	' Experiment Advisor Report Generation
	If Rte.ExperimentAdvisor.Enabled = True Then
		If Len(Rte.ExperimentAdvisor.Filename) = 0 Then Rte.ExperimentAdvisor.Filename = Replace(c.DataFile.Filename, ".txt", "-ExperimentAdvisorReport.xml")
		Rte.ExperimentAdvisor.GenerateReport


	End If


ExperimentAbort:

	' Clean up the context
	c.PopFrame
	Set c = Nothing
	Set ebContext = Nothing

	DestroyDefaultPort

End Sub

