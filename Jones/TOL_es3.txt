'
'
'
'	C:\Users\nstem\Documents\Notes_WF\TOL\TOL072723_EyeLink2024-02-20.ebs3
'	Generated on: 2/20/2024	16:37:17
'
'
'	This experiment has been generated with E-Prime version: 3.0.3.214
'
'	This file generated with the E-Studio interface.
'	E-Prime Â© 1996-2022 Psychology Software Tools. All rights reserved.
'
'	Legal use of this experiment script requires a full E-Prime or Runtime License.
'
'
'	Author:
'		Neil P. Jones
'
'
'
'

Option CStrings On
Dim ebContext as Context


'--------------------------------------------------------------------------
' Class Declarations
'--------------------------------------------------------------------------


























'--------------------------------------------------------------------------
' Instance Declarations
'--------------------------------------------------------------------------
Dim Display As DisplayDevice
Dim Keyboard As KeyboardDevice
Dim Mouse As MouseDevice
Dim Socket As SocketDevice
Dim Button As ButtonDevice
Dim Serial As SerialDevice
Dim Plan As Slide
Dim PlanEchoClients As EchoClientCollection
Dim Plan_State As SlideState
Dim Plan_SlideText As SlideText
Dim Plan_SlideImage As SlideImage

Dim SessionProc As Procedure

Dim planproc As Procedure

Dim Fixation As TextDisplay

' List Attribute Constants
Const attrib_weight = ebUCase_W & ebLCase_e & ebLCase_i & ebLCase_g & ebLCase_h & ebLCase_t
Const attrib_nested = ebUCase_N & ebLCase_e & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_d
Const attrib_procedure = ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_d & ebLCase_u & ebLCase_r & ebLCase_e
Const attrib_startstate = ebUCase_S & ebLCase_t & ebLCase_a & ebLCase_r & ebLCase_t & ebUCase_S & ebLCase_t & ebLCase_a & ebLCase_t & ebLCase_e
Const attrib_posgoal = ebLCase_p & ebLCase_o & ebLCase_s & ebUCase_G & ebLCase_o & ebLCase_a & ebLCase_l
Const attrib_correctmoves = ebLCase_c & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_m & ebLCase_o & ebLCase_v & ebLCase_e & ebLCase_s
Const attrib_difficulty = ebUCase_D & ebLCase_i & ebLCase_f & ebLCase_f & ebLCase_i & ebLCase_c & ebLCase_u & ebLCase_l & ebLCase_t & ebLCase_y
Const attrib_res2 = ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_2
Const attrib_res3 = ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_3
Const attrib_res4 = ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_4
Const attrib_res5 = ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_5
Const attrib_res6 = ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_6
Const attrib_cue = ebLCase_c & ebLCase_u & ebLCase_e
Const attrib_plandur = ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_n & ebLCase_d & ebLCase_u & ebLCase_r
Const attrib_feeddur = ebLCase_f & ebLCase_e & ebLCase_e & ebLCase_d & ebLCase_d & ebLCase_u & ebLCase_r
Const attrib_iti = ebUCase_I & ebUCase_T & ebUCase_I
Const attrib_shock = ebUCase_S & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k
Const attrib_ashock = ebUCase_A & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k
Const attrib_plannummov = ebUCase_P & ebLCase_l & ebLCase_a & ebLCase_n & ebLCase_n & ebLCase_u & ebLCase_m & ebLCase_m & ebLCase_o & ebLCase_v
Const attrib_pcountdown = ebLCase_p & ebLCase_c & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebLCase_d & ebLCase_o & ebLCase_w & ebLCase_n
Const attrib_trialnum = ebUCase_T & ebLCase_r & ebLCase_i & ebLCase_a & ebLCase_l & ebLCase_n & ebLCase_u & ebLCase_m

Dim MenuList As List

Dim Menu As Procedure

Dim TowerTask As Procedure

Dim MenuText As TextDisplay

Dim goodbye As Procedure

Dim Goodbyetxt As TextDisplay

Dim Breakproc As Procedure

Dim Standby As TextDisplay
Dim StandbyEchoClients As EchoClientCollection

Dim Waitingforpup As TextDisplay
Dim WaitingforpupEchoClients As EchoClientCollection

Dim TOLconditions As List

Dim Instruct As TextDisplay
Dim InstructEchoClients As EchoClientCollection

Dim mask As TextDisplay

Dim Intelligence As TextDisplay
Dim IntelligenceEchoClients As EchoClientCollection

Dim Block1 As List

Dim Incorrect As Slide
Dim Incorrect_State As SlideState
Dim Incorrect_SlideText As SlideText

Dim Correct As Slide
Dim Correct_State As SlideState
Dim Correct_SlideText As SlideText
Dim Correct_SlideImage As SlideImage

Dim Fixation2 As Slide
Dim Fixation2_State As SlideState
Dim Fixation2_SlideImage As SlideImage

Dim Block2 As List

Dim Block3 As List

Dim Instruct2 As TextDisplay
Dim Instruct2EchoClients As EchoClientCollection

Dim Beakprocshock As Procedure
Dim Beakprocshock_nObject As Long
Dim Beakprocshock_bCanExit As Boolean
Dim Beakprocshock_theCollection As RteCollection
Dim Beakprocshock_theInputObject As RteRunnableInputObject

Dim Block4 As List

Dim SAMDdid As Slide
Dim SAMDdidEchoClients As EchoClientCollection
Dim SAMDdid_State As SlideState
Dim SAMDdid_SlideImage As SlideImage

Dim Intelligence1 As TextDisplay
Dim Intelligence1EchoClients As EchoClientCollection

Dim CD5 As Slide
Dim CD5_State As SlideState
Dim CD5_SlideText As SlideText

Dim CD1 As Slide
Dim CD1_State As SlideState
Dim CD1_SlideText As SlideText

Dim CD2 As Slide
Dim CD2_State As SlideState
Dim CD2_SlideText As SlideText

Dim CD3 As Slide
Dim CD3_State As SlideState
Dim CD3_SlideText As SlideText

Dim CD4 As Slide
Dim CD4_State As SlideState
Dim CD4_SlideText As SlideText

Dim Fixation3 As Slide
Dim Fixation3_State As SlideState
Dim Fixation3_SlideImage As SlideImage

Dim shockcheck As TextDisplay
Dim shockcheckEchoClients As EchoClientCollection

Dim shockscale As Slide
Dim shockscaleEchoClients As EchoClientCollection
Dim shockscale_State As SlideState
Dim shockscale_SlideImage As SlideImage

Dim Moreshock As TextDisplay
Dim MoreshockEchoClients As EchoClientCollection

Dim Beakprocshock3 As Procedure
Dim Beakprocshock3_nObject As Long
Dim Beakprocshock3_bCanExit As Boolean
Dim Beakprocshock3_theCollection As RteCollection
Dim Beakprocshock3_theInputObject As RteRunnableInputObject

Dim Beakprocshock4 As Procedure
Dim Beakprocshock4_nObject As Long
Dim Beakprocshock4_bCanExit As Boolean
Dim Beakprocshock4_theCollection As RteCollection
Dim Beakprocshock4_theInputObject As RteRunnableInputObject



'--------------------------------------------------------------------------
' Package Declare Script
'--------------------------------------------------------------------------



'--------------------------------------------------------------------------
' User Script - BEGIN
'--------------------------------------------------------------------------
Dim Difficulty As String
Dim pupfname As String
Dim nStartTime As Long
Dim pStartTime As Long
Dim currt As Long
Dim prestimtime As Long
Dim planprestimtime As Long
Dim slidedur As Long
Dim countdown As String
Dim countdown2 As Long
Dim slidedurs As Long
Dim slidesolvs As Long
Dim elapsedtime As Long
Dim pdur As Integer
Dim countdowns As String
Dim extra As Integer
Dim pscore As Integer
Dim sscore As Integer
Dim tscore As Integer
Dim tleft As Double
Dim fudge As Double
Dim tset As Long
Dim slop As Long
Dim solved As Integer
Dim plancorr As Integer
Dim finalhit As Long
Dim feedbck As String
Dim posGoal As String
Dim posCurrent As String
Dim res1 As String
Dim res2 As String
Dim res3 As String
Dim res4 As String
Dim res5 As String
Dim res6 As String
Dim res7 As String
Dim res8 As String
Dim posA As String
Dim posB As String
Dim posC As String
Dim Shock As String
Dim planState As SlideState
Dim theState As SlideState 
Dim strHit As String
Dim keyboardMask As KeyboardResponseData
Dim switchfile As String
Dim switchfile2 As String 
Dim switchfile3 As String
Dim switchfile4 As String
Dim Checkshock As String
Dim plannummov As Integer
Dim posAvar As String
Dim posBvar As String
Dim posCvar As String
Dim dposGoal As String
Dim dposA As String
Dim dposB As String
Dim dposC As String
Dim exit1 As String
Dim value As String
Dim toggle As Boolean
Dim stable As Boolean
Dim TrialStar As Long
Dim Qval As Integer
Dim RT As Long
Dim Response As Double
Dim GotAns As Integer
Dim start As Integer
Dim x As Integer
Dim last As Integer
Dim juststarting As Integer
Dim tosend As Integer
Dim TrialNum As Integer
Dim fixon As Long
Dim fbon As Long
Dim maskon As Long
Dim breakfix As Long
Dim bytesThatMakePulseConfigCommand(5) As Integer
Dim bytesToRaiseStimTrackerLines(3) As Integer

Const PupilometerPresent = 1
Const NumInaRow=7
Const Screenres=13.333 'Monitor Resolution: 60 Hz use 16.6667; 75Hz use 13.333' 


'--------------------------------------------------------------------------
' User Script - END
'--------------------------------------------------------------------------



'--------------------------------------------------------------------------
' Package Global Script
'--------------------------------------------------------------------------



'--------------------------------------------------------------------------
' Implementation
'--------------------------------------------------------------------------


Sub SessionProc_Run(c as Context)
	SessionProc.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	SessionProc.ProcedureStart

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	SessionProc.TimelineStart
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Initializecode BEGIN <Initializecode>
	'''''''''''''''''''''''''''''''''''''''''''''
	c.Setattrib "Continue","1"
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Initializecode END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - initialzeoutput BEGIN <initialzeoutput>
	'''''''''''''''''''''''''''''''''''''''''''''
	'Open Tower of London E-Prime Behavioral Output & Write the header line
open "tol-output-" & c.getattrib("Subject") & ".txt" For Append As #1
write #1, "Start\tGoal\tdifficulty\tCormov\tplanmov\tplancorr\trt"
open "tol-timing-" & c.getattrib("Subject") & ".txt" For Append As #2
write #2, "breakfix\tfixon\tplanon\tfbon\tmaskon"
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - initialzeoutput END
	'''''''''''''''''''''''''''''''''''''''''''''
	
		MenuList.Run c
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	SessionProc.TimelineFinish
	MenuList.EndOfProcedure

	SessionProc.EndOfProcedure

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	SessionProc.ProcedureFinish
End Sub

Sub planproc_Run(c as Context)
	planproc.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	planproc.ProcedureStart
		Fixation2.ResetLoggingProperties
		Correct.ResetLoggingProperties
		Incorrect.ResetLoggingProperties

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	planproc.TimelineStart
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Initialize1 BEGIN <Initialize1>
	'''''''''''''''''''''''''''''''''''''''''''''
	
TrialNum=TrialNum+1

'set goal and current state
posGoal = c.getattrib("posGoal")
posCurrent = c.getattrib("StartState")

'initialize response buttons
res2 = c.getattrib("res2")
res3 = c.getattrib("res3")
res4 = c.getattrib("res4")
res5 = c.getattrib("res5")
res6 = c.getattrib("res6")

'initialize threat warning
Shock = c.GetAttrib("Shock")

'Add directory path to image files 
c.setattrib "posGoal", "Goal\\" & posGoal 
c.setattrib "posCurrent", "Goal\\" & posCurrent  
c.setattrib "res2", "Plan\\Not\\" & res2
c.setattrib "res3", "Plan\\Not\\" & res3
c.setattrib "res4", "Plan\\Not\\" & res4
c.setattrib "res5", "Plan\\Not\\" & res5
c.setattrib "res6", "Plan\\Not\\" & res6
c.setattrib "Shock", "Feed\\" & Shock 

'Start Timing
pStartTime = Clock.Read

Dim VPXstring As String
Dim tmp As Integer
tmp=len("dataFile_InsertString" & " " & "'" & c.getattrib("Trialnum") & c.getattrib("Difficulty") & "';")
VPXstring = "VPX2" & " "  & tmp & ";" & "220;" & "dataFile_InsertString" & " " & "'" & c.getattrib("Trialnum") & c.getattrib("Difficulty") & "';" 
socket.writestring VPXstring
sleep(100)
'Send event makers
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 30  '43 
	bytesThatMakePulseConfigCommand(3) = 0 	  '202 
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	'Ingeter 4 trigger the channel on STP100C that triggers the digital out lines
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 2
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
	
	'sleep for duration of the pulse allows previous code to execute prior to resetting the lines
	sleep 30
	
	'Resets all stimtracker lines to 0 for pulse duration and command
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 0
	bytesThatMakePulseConfigCommand(3) = 0
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 0
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
	
fixon = Clock.Read
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Initialize1 END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	Select Case Fixation2.ActiveState
		Case ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t

			'Image1
			Set Fixation2_SlideImage = CSlideImage(Fixation2.ActiveSlideState.Objects(ebUCase_I & ebLCase_m & ebLCase_a & ebLCase_g & ebLCase_e & ebDigit_1))
			Fixation2_SlideImage.Filename = c.GetAttrib("Shock") &_ 
				".tif"
			Fixation2_SlideImage.Load
			Set Fixation2_SlideImage = Nothing

	End Select

	
	Fixation2.Run
	
	c.SetAttrib Fixation2.Name & ebDot & ebLogNameOnsetTime, Fixation2.OnsetTime
	c.SetAttrib Fixation2.Name & ebDot & ebLogNameOffsetTime, Fixation2.OffsetTime
	
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - sendtrialtypephase BEGIN <sendtrialtypephase>
	'''''''''''''''''''''''''''''''''''''''''''''
	elapsedtime = (Clock.Read - pStarttime)


planprestimtime = Clock.Read
'Plan.PreRelease =3064

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - sendtrialtypephase END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label2 BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Label2:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Label2Resume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Label2Resume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label2 END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	
	Select Case Plan.ActiveState
		Case ebUCase_P & ebLCase_o & ebLCase_s & ebUCase_C & ebLCase_u & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_n & ebLCase_t


			'Text3
			Set Plan_SlideText = CSlideText(Plan.ActiveSlideState.Objects(ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t & ebDigit_3))
			Plan_SlideText.Text = "TIME LEFT\n" &_ 
				c.GetAttrib("pcountdown") &_ 
				"  sec"
			Set Plan_SlideText = Nothing
			'Image1
			Set Plan_SlideImage = CSlideImage(Plan.ActiveSlideState.Objects(ebUCase_I & ebLCase_m & ebLCase_a & ebLCase_g & ebLCase_e & ebDigit_1))
			Plan_SlideImage.Filename = c.GetAttrib("Shock") &_ 
				".tif"
			Plan_SlideImage.Load
			Set Plan_SlideImage = Nothing
			'res2
			Set Plan_SlideImage = CSlideImage(Plan.ActiveSlideState.Objects(ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_2))
			Plan_SlideImage.Filename = c.GetAttrib("res2") &_ 
				".bmp"
			Plan_SlideImage.Load
			Set Plan_SlideImage = Nothing
			'res3
			Set Plan_SlideImage = CSlideImage(Plan.ActiveSlideState.Objects(ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_3))
			Plan_SlideImage.Filename = c.GetAttrib("res3") &_ 
				".bmp"
			Plan_SlideImage.Load
			Set Plan_SlideImage = Nothing
			'res6
			Set Plan_SlideImage = CSlideImage(Plan.ActiveSlideState.Objects(ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_6))
			Plan_SlideImage.Filename = c.GetAttrib("res6") &_ 
				".bmp"
			Plan_SlideImage.Load
			Set Plan_SlideImage = Nothing
			'res5
			Set Plan_SlideImage = CSlideImage(Plan.ActiveSlideState.Objects(ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_5))
			Plan_SlideImage.Filename = c.GetAttrib("res5") &_ 
				".bmp"
			Plan_SlideImage.Load
			Set Plan_SlideImage = Nothing
			'res4
			Set Plan_SlideImage = CSlideImage(Plan.ActiveSlideState.Objects(ebLCase_r & ebLCase_e & ebLCase_s & ebDigit_4))
			Plan_SlideImage.Filename = c.GetAttrib("res4") &_ 
				".bmp"
			Plan_SlideImage.Load
			Set Plan_SlideImage = Nothing
			'PosGoal
			Set Plan_SlideImage = CSlideImage(Plan.ActiveSlideState.Objects(ebUCase_P & ebLCase_o & ebLCase_s & ebUCase_G & ebLCase_o & ebLCase_a & ebLCase_l))
			Plan_SlideImage.Filename = c.GetAttrib("posgoal") &_ 
				".tif"
			Plan_SlideImage.Load
			Set Plan_SlideImage = Nothing
			'PosCurrent
			Set Plan_SlideImage = CSlideImage(Plan.ActiveSlideState.Objects(ebUCase_P & ebLCase_o & ebLCase_s & ebUCase_C & ebLCase_u & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_n & ebLCase_t))
			Plan_SlideImage.Filename = c.GetAttrib("posCurrent") &_ 
				".tif"
			Plan_SlideImage.Load
			Set Plan_SlideImage = Nothing

	End Select

	
	
	Plan.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		PlanEchoClients.RemoveAll
		Plan.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2 & ebDigit_3 & ebDigit_4 & ebDigit_5, _ 
				ebEmptyText, _ 
				CLng(Plan.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Plan.Run
	
	c.SetAttrib Plan.Name & ebDot & ebLogNameOnsetTime, Plan.OnsetTime
	c.SetAttrib Plan.Name & ebDot & ebLogNameOffsetTime, Plan.OffsetTime
	
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Planresponse BEGIN <Planresponse>
	'''''''''''''''''''''''''''''''''''''''''''''
	'set timing variables
Plan.PreRelease = 0
elapsedtime = (Clock.Read - pStarttime)
slidedur = Clock.Read - planprestimtime
pdur=c.getattrib("plandur")
countdown = (pdur - slidedur)/1000
countdown2= (pdur - slidedur)
c.setattrib "pcountdown", Mid(CStr(countdown), 1, 2)

'set state of planning slidef
Set planState = Plan.States("PosCurrent")

'start determining if a response was made and set it to variable strHit
If PLAN.InputMasks.Responses.Count > 0 Then
	Set keyboardMask = CKeyboardResponseData(PLAN.InputMasks.Responses(1))
	strHit = keyboardMask.RESP
End If

'Code to hihglight a response selection
If strHit = "1" And Mid(c.getattrib("res2"), 6, 1) = "N" And Mid(c.getattrib("res3"), 6, 1) = "N" And Mid(c.getattrib("res4"), 6, 1) = "N"And Mid(c.getattrib("res5"), 6, 1) = "N" And Mid(c.getattrib("res6"), 6, 1) = "N" Then 
	c.setattrib "res2", "Plan\\Clicked\\C" & Mid(c.getattrib("res2"), 11, 1) 
ElseIf strHit = "2" And Mid(c.getattrib("res2"), 6, 1) = "N" And Mid(c.getattrib("res3"), 6, 1) = "N" And Mid(c.getattrib("res4"), 6, 1) = "N"And Mid(c.getattrib("res5"), 6, 1) = "N" And Mid(c.getattrib("res6"), 6, 1) = "N" Then
	c.setattrib "res3", "Plan\\Clicked\\C" & Mid(c.getattrib("res3"), 11, 1) 
ElseIf strHit = "3" And Mid(c.getattrib("res2"), 6, 1) = "N" And Mid(c.getattrib("res3"), 6, 1) = "N" And Mid(c.getattrib("res4"), 6, 1) = "N" And Mid(c.getattrib("res5"), 6, 1) = "N" And Mid(c.getattrib("res6"), 6, 1) = "N" Then 
	c.setattrib "res4", "Plan\\Clicked\\C" & Mid(c.getattrib("res4"), 11, 1) 
ElseIf strHit = "4" And Mid(c.getattrib("res2"), 6, 1) = "N" And Mid(c.getattrib("res3"), 6, 1) = "N" And Mid(c.getattrib("res4"), 6, 1) = "N"And Mid(c.getattrib("res5"), 6, 1) = "N" And Mid(c.getattrib("res6"), 6, 1) = "N" Then 
	c.setattrib "res5", "Plan\\Clicked\\C" & Mid(c.getattrib("res5"), 11, 1) 
ElseIf strHit = "5" And Mid(c.getattrib("res2"), 6, 1) = "N" And Mid(c.getattrib("res3"), 6, 1) = "N" And Mid(c.getattrib("res4"), 6, 1) = "N"And Mid(c.getattrib("res5"), 6, 1) = "N" And Mid(c.getattrib("res6"), 6, 1) = "N" Then 
	c.setattrib "res6", "Plan\\Clicked\\C" & Mid(c.getattrib("res6"), 11, 1) 
End If

'Code to switch selections once they are made
If  strHit = "1" And Mid(c.getattrib("res3"), 6, 1) = "C" Then 
	c.setattrib "res2", "Plan\\Clicked\\C" & Mid(c.getattrib("res2"), 11, 1)
	c.setattrib "res3", "Plan\\Not\\N" & Mid(c.getattrib("res3"), 15, 1) 
ElseIf strHit = "1" And Mid(c.getattrib("res4"), 6, 1) = "C" Then 
	c.setattrib "res2", "Plan\\Clicked\\C" & Mid(c.getattrib("res2"), 11, 1)
	c.setattrib "res4", "Plan\\Not\\N" & Mid(c.getattrib("res4"), 15, 1) 
ElseIf strHit = "1" And Mid(c.getattrib("res5"), 6, 1) = "C" Then 
	c.setattrib "res2", "Plan\\Clicked\\C" & Mid(c.getattrib("res2"), 11, 1)
	c.setattrib "res5", "Plan\\Not\\N" & Mid(c.getattrib("res5"), 15, 1)
ElseIf strHit = "1" And Mid(c.getattrib("res6"), 6, 1) = "C" Then 
	c.setattrib "res2", "Plan\\Clicked\\C" & Mid(c.getattrib("res2"), 11, 1)
	c.setattrib "res6", "Plan\\Not\\N" & Mid(c.getattrib("res6"), 15, 1) 
End If 

If  strHit = "2" And Mid(c.getattrib("res2"), 6, 1) = "C" Then 
	c.setattrib "res3", "Plan\\Clicked\\C" & Mid(c.getattrib("res3"), 11, 1)
	c.setattrib "res2", "Plan\\Not\\N" & Mid(c.getattrib("res2"), 15, 1) 
ElseIf strHit = "2" And Mid(c.getattrib("res4"), 6, 1) = "C" Then 
	c.setattrib "res3", "Plan\\Clicked\\C" & Mid(c.getattrib("res3"), 11, 1)
	c.setattrib "res4", "Plan\\Not\\N" & Mid(c.getattrib("res4"), 15, 1) 
ElseIf strHit = "2" And Mid(c.getattrib("res5"), 6, 1) = "C" Then 
	c.setattrib "res3", "Plan\\Clicked\\C" & Mid(c.getattrib("res3"), 11, 1)
	c.setattrib "res5", "Plan\\Not\\N" & Mid(c.getattrib("res5"), 15, 1)
ElseIf strHit = "2" And Mid(c.getattrib("res6"), 6, 1) = "C" Then 
	c.setattrib "res3", "Plan\\Clicked\\C" & Mid(c.getattrib("res3"), 11, 1)
	c.setattrib "res6", "Plan\\Not\\N" & Mid(c.getattrib("res6"), 15, 1) 
End If 

If  strHit = "3" And Mid(c.getattrib("res2"), 6, 1) = "C" Then 
	c.setattrib "res4", "Plan\\Clicked\\C" & Mid(c.getattrib("res4"), 11, 1)
	c.setattrib "res2", "Plan\\Not\\N" & Mid(c.getattrib("res2"), 15, 1) 
ElseIf strHit = "3" And Mid(c.getattrib("res3"), 6, 1) = "C" Then 
	c.setattrib "res4", "Plan\\Clicked\\C" & Mid(c.getattrib("res4"), 11, 1)
	c.setattrib "res3", "Plan\\Not\\N" & Mid(c.getattrib("res3"), 15, 1) 
ElseIf strHit = "3" And Mid(c.getattrib("res5"), 6, 1) = "C" Then 
	c.setattrib "res4", "Plan\\Clicked\\C" & Mid(c.getattrib("res4"), 11, 1)
	c.setattrib "res5", "Plan\\Not\\N" & Mid(c.getattrib("res5"), 15, 1)
ElseIf strHit = "3" And Mid(c.getattrib("res6"), 6, 1) = "C" Then 
	c.setattrib "res4", "Plan\\Clicked\\C" & Mid(c.getattrib("res4"), 11, 1)
	c.setattrib "res6", "Plan\\Not\\N" & Mid(c.getattrib("res6"), 15, 1) 
End If 

If  strHit = "4" And Mid(c.getattrib("res2"), 6, 1) = "C" Then 
	c.setattrib "res5", "Plan\\Clicked\\C" & Mid(c.getattrib("res5"), 11, 1)
	c.setattrib "res2", "Plan\\Not\\N" & Mid(c.getattrib("res2"), 15, 1) 
ElseIf strHit = "4" And Mid(c.getattrib("res3"), 6, 1) = "C" Then 
	c.setattrib "res5", "Plan\\Clicked\\C" & Mid(c.getattrib("res5"), 11, 1)
	c.setattrib "res3", "Plan\\Not\\N" & Mid(c.getattrib("res3"), 15, 1) 
ElseIf strHit = "4" And Mid(c.getattrib("res4"), 6, 1) = "C" Then 
	c.setattrib "res5", "Plan\\Clicked\\C" & Mid(c.getattrib("res5"), 11, 1)
	c.setattrib "res4", "Plan\\Not\\N" & Mid(c.getattrib("res4"), 15, 1)
ElseIf strHit = "4" And Mid(c.getattrib("res6"), 6, 1) = "C" Then 
	c.setattrib "res5", "Plan\\Clicked\\C" & Mid(c.getattrib("res5"), 11, 1)
	c.setattrib "res6", "Plan\\Not\\N" & Mid(c.getattrib("res6"), 15, 1) 
End If

If  strHit = "5" And Mid(c.getattrib("res2"), 6, 1) = "C" Then 
	c.setattrib "res6", "Plan\\Clicked\\C" & Mid(c.getattrib("res6"), 11, 1)
	c.setattrib "res2", "Plan\\Not\\N" & Mid(c.getattrib("res2"), 15, 1) 
ElseIf strHit = "5" And Mid(c.getattrib("res3"), 6, 1) = "C" Then 
	c.setattrib "res6", "Plan\\Clicked\\C" & Mid(c.getattrib("res6"), 11, 1)
	c.setattrib "res3", "Plan\\Not\\N" & Mid(c.getattrib("res3"), 15, 1) 
ElseIf strHit = "5" And Mid(c.getattrib("res4"), 6, 1) = "C" Then 
	c.setattrib "res6", "Plan\\Clicked\\C" & Mid(c.getattrib("res6"), 11, 1)
	c.setattrib "res4", "Plan\\Not\\N" & Mid(c.getattrib("res4"), 15, 1)
ElseIf strHit = "5" And Mid(c.getattrib("res5"), 6, 1) = "C" Then 
	c.setattrib "res6", "Plan\\Clicked\\C" & Mid(c.getattrib("res6"), 11, 1)
	c.setattrib "res5", "Plan\\Not\\N" & Mid(c.getattrib("res5"), 15, 1) 
End If


'Collect the response for feedback
If Mid(c.getattrib("res2"), 6, 1) = "C" Then 
c.SetAttrib "plannummov" , Mid(c.getattrib("res2"), 15, 1)
ElseIf Mid(c.getattrib("res3"), 6, 1) = "C" Then 
c.SetAttrib "plannummov" , Mid(c.getattrib("res3"), 15, 1)
ElseIf Mid(c.getattrib("res4"), 6, 1) = "C" Then 
c.SetAttrib "plannummov" , Mid(c.getattrib("res4"), 15, 1)
ElseIf Mid(c.getattrib("res5"), 6, 1) = "C" Then 
c.SetAttrib "plannummov" , Mid(c.getattrib("res5"), 15, 1)
ElseIf Mid(c.getattrib("res6"), 6, 1) = "C" Then 
c.SetAttrib "plannummov" , Mid(c.getattrib("res6"), 15, 1)
ElseIf c.getattrib("res2") = "Plan\\Not\\N2" And c.getattrib("res3") = "Plan\\Not\\N3" And c.getattrib("res4") = "Plan\\Not\\N4" And c.getattrib("res5") = "Plan\\Not\\N5" And c.getattrib("res6") = "Plan\\Not\\N6" Then 
c.SetAttrib "plannummov" , 0
End If

If strHit = "1" Or strHit = "2" Or strHit = "3" Or strHit = "4" Or strHit = "5" Then
currt=(Clock.Read-planprestimtime)
End If 

'Shock Code
If c.GetAttrib("AShock")="Shock" And countdown2 >= 4000 And countdown2 <=5000  Then
	'Set the duration of the event marker to cedrus 
	'mp interger 43 on byte 3 and integer 202 on byte 4 combine in binary to sum to 500 ms
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 200  '43 
	bytesThatMakePulseConfigCommand(3) = 0 	  '202 
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	'Ingeter 4 trigger the channel on STP100C that triggers the digital out lines
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 4
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
	
	'sleep for duration of the pulse allows previous code to execute prior to resetting the lines
	sleep 200
	
	'Resets all stimtracker lines to 0 for pulse duration and command
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 0
	bytesThatMakePulseConfigCommand(3) = 0
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 0
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
End If 

If c.GetAttrib("AShock")="Shock" And countdown2 >= 13000 And countdown2 <=14000  Then
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 200  '43 
	bytesThatMakePulseConfigCommand(3) = 0 	  '202 
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	'Ingeter 4 trigger the channel on STP100C that triggers the digital out lines
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 4
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
	
	'sleep for duration of the pulse allows previous code to execute prior to resetting the lines
	sleep 200
	
	'Resets all stimtracker lines to 0 for pulse duration and command
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 0
	bytesThatMakePulseConfigCommand(3) = 0
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 0
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
End If 

If c.GetAttrib("AShock")="Shock" And countdown2 >= 20000 And countdown2 <=21000  Then
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 200  '43 
	bytesThatMakePulseConfigCommand(3) = 0 	  '202 
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	'Ingeter 4 trigger the channel on STP100C that triggers the digital out lines
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 4
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
	
	'sleep for duration of the pulse allows previous code to execute prior to resetting the lines
	sleep 200
	
	'Resets all stimtracker lines to 0 for pulse duration and command
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 0
	bytesThatMakePulseConfigCommand(3) = 0
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 0
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
End If 

strHit = 0
If slidedur <= (pdur-1000) Then
Plan.Duration = 1000
GoTo Label2
ElseIf slidedur > (pdur-1000) And slidedur <= pdur Then
   tleft=(pdur-slidedur) 
   If tleft >0 Then
   Plan.Duration = tleft
   GoTo Label2
   Else 
   GoTo Label1
   End If 
ElseIf slidedur > pdur Then
   GoTo Label1
End If
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Planresponse END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label1 BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Label1:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Label1Resume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Label1Resume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label1 END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - skiptofeed BEGIN <skiptofeed>
	'''''''''''''''''''''''''''''''''''''''''''''
	elapsedtime = (Clock.Read - pStarttime)
If c.getattrib("correctmoves") = c.getattrib("plannummov") Then 
fbon = Clock.Read
GoTo Label3 
ElseIf c.getattrib("correctmoves") <> c.getattrib("plannummov")Then 
fbon = Clock.Read
GoTo Label4
End If 
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - skiptofeed END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label3 BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Label3:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Label3Resume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Label3Resume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label3 END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		
	Correct.Duration = CLng(c.GetAttrib(ebLCase_f & ebLCase_e & ebLCase_e & ebLCase_d & ebLCase_d & ebLCase_u & ebLCase_r))
	Correct.Run
	
	c.SetAttrib Correct.Name & ebDot & ebLogNameOnsetTime, Correct.OnsetTime
	c.SetAttrib Correct.Name & ebDot & ebLogNameOffsetTime, Correct.OffsetTime
	
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - jumpend BEGIN <jumpend>
	'''''''''''''''''''''''''''''''''''''''''''''
	elapsedtime = (Clock.Read - pStarttime)
GoTo Label5
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - jumpend END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label4 BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Label4:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Label4Resume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Label4Resume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label4 END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		
	Incorrect.Duration = CLng(c.GetAttrib(ebLCase_f & ebLCase_e & ebLCase_e & ebLCase_d & ebLCase_d & ebLCase_u & ebLCase_r))
	Incorrect.Run
	
	c.SetAttrib Incorrect.Name & ebDot & ebLogNameOnsetTime, Incorrect.OnsetTime
	c.SetAttrib Incorrect.Name & ebDot & ebLogNameOffsetTime, Incorrect.OffsetTime
	
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - jumpend1 BEGIN <jumpend1>
	'''''''''''''''''''''''''''''''''''''''''''''
	elapsedtime = (Clock.Read - pStarttime)
GoTo Label5
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - jumpend1 END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label5 BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Label5:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Label5Resume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Label5Resume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label5 END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - InLine13 BEGIN <InLine13>
	'''''''''''''''''''''''''''''''''''''''''''''
	If c.getattrib("correctmoves") = c.getattrib("plannummov") Then
plancorr = 1
Else plancorr = 0
End If
maskon = Clock.Read
write #1, CSTR(c.getattrib("StartState")) & "\t" & CSTR(Mid(c.getattrib("posGoal"), 6, 2)) & "\t" & cstr(c.getattrib("Difficulty")) & "\t" & CSTR(c.getattrib("correctmoves")) & "\t" & cstr(c.getattrib("plannummov")) & "\t" & cstr(plancorr) & "\t" & CSTR(currt)

	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - InLine13 END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	
	mask.Duration = CLng(c.GetAttrib(ebUCase_I & ebUCase_T & ebUCase_I))
	mask.Run
	c.SetAttrib mask.Name & ebDot & ebLogNameOnsetTime, mask.OnsetTime
	c.SetAttrib mask.Name & ebDot & ebLogNameOffsetTime, mask.OffsetTime
	
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Time BEGIN <Time>
	'''''''''''''''''''''''''''''''''''''''''''''
	elapsedtime = (Clock.Read - pStarttime)
write #2, CSTR(breakfix)& "\t" & CSTR(pStartTime) & "\t" & CSTR(planprestimtime) & "\t" & cstr(fbon) & "\t" & CSTR(maskon)
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - Time END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	planproc.TimelineFinish
	Fixation2.EndOfProcedure

	Plan.EndOfProcedure

	Correct.EndOfProcedure

	Incorrect.EndOfProcedure

	mask.EndOfProcedure

	planproc.EndOfProcedure
	c.SetAttrib Fixation2.Name & ebDot & ebLogNameOnsetTime, Fixation2.OnsetTime
	c.SetAttrib Fixation2.Name & ebDot & ebLogNameOffsetTime, Fixation2.OffsetTime
	
	c.SetAttrib Plan.Name & ebDot & ebLogNameOnsetTime, Plan.OnsetTime
	c.SetAttrib Plan.Name & ebDot & ebLogNameOffsetTime, Plan.OffsetTime
	
	c.SetAttrib Correct.Name & ebDot & ebLogNameOnsetTime, Correct.OnsetTime
	c.SetAttrib Correct.Name & ebDot & ebLogNameOffsetTime, Correct.OffsetTime
	
	c.SetAttrib Incorrect.Name & ebDot & ebLogNameOnsetTime, Incorrect.OnsetTime
	c.SetAttrib Incorrect.Name & ebDot & ebLogNameOffsetTime, Incorrect.OffsetTime
	
	c.SetAttrib mask.Name & ebDot & ebLogNameOnsetTime, mask.OnsetTime
	c.SetAttrib mask.Name & ebDot & ebLogNameOffsetTime, mask.OffsetTime
	

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	planproc.ProcedureFinish
End Sub

Sub Menu_Run(c as Context)
	Menu.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Menu.ProcedureStart

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Menu.TimelineStart
	
	
	MenuText.Run
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - MenuChoices BEGIN <MenuChoices>
	'''''''''''''''''''''''''''''''''''''''''''''
	Dim Continue As Integer
Continue=1

Do While Continue>0
	MenuText.InputMasks.Reset
	MenuText.InputMasks.Add Keyboard.CreateInputMask("AB", "", Val(MenuText.Duration), Val("1"), ebEndResponseActionTerminate, True, "", "", "")

 MenuText.Run

 Select Case (MenuText.Resp) 
	Case "A"
        TowerTask.Run c
	Case "B"
	     Goodbye.Run c
		Continue=0
   End Select
Loop


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - MenuChoices END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Menu.TimelineFinish
	MenuText.EndOfProcedure

	Menu.EndOfProcedure

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Menu.ProcedureFinish
End Sub

Sub TowerTask_Run(c as Context)
	TowerTask.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	TowerTask.ProcedureStart
		Instruct2.ResetLoggingProperties

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	TowerTask.TimelineStart
	
	
	
	Instruct.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		InstructEchoClients.RemoveAll
		Instruct.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Instruct.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Instruct.Run
	
	
	
	Instruct2.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		Instruct2EchoClients.RemoveAll
		Instruct2.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Instruct2.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Instruct2.Run
		TOLconditions.Run c
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - closeoutputfile BEGIN <closeoutputfile>
	'''''''''''''''''''''''''''''''''''''''''''''
	close #1
close #2
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - closeoutputfile END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	TowerTask.TimelineFinish
	Instruct.EndOfProcedure

	Instruct2.EndOfProcedure

	TOLconditions.EndOfProcedure

	TowerTask.EndOfProcedure

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	TowerTask.ProcedureFinish
End Sub

Sub goodbye_Run(c as Context)
	goodbye.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	goodbye.ProcedureStart

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	goodbye.TimelineStart
	
	
	Goodbyetxt.Run
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	goodbye.TimelineFinish
	Goodbyetxt.EndOfProcedure

	goodbye.EndOfProcedure

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	goodbye.ProcedureFinish
End Sub

Sub Breakproc_Run(c as Context)
	Breakproc.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Breakproc.ProcedureStart

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Breakproc.TimelineStart
	
	
	
	Standby.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		StandbyEchoClients.RemoveAll
		Standby.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Standby.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Standby.Run
	
	
	
	Waitingforpup.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		WaitingforpupEchoClients.RemoveAll
		Waitingforpup.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & "=" & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Waitingforpup.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Waitingforpup.Run
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - openpupfile1 BEGIN <openpupfile1>
	'''''''''''''''''''''''''''''''''''''''''''''
	Dim pupfname As String
Dim tmp As Integer
tmp=len("dataFile_NewName" & " " & "'TOL_pup_"&"1_" & c.GetAttrib("Subject") & ".txt';")
pupfname = "VPX2" &" "& tmp & ";220;dataFile_NewName" & " " & "'TOL_pup_"&"1_" & c.GetAttrib("Subject") & ".txt';"
'debug.print pupfname
socket.writestring pupfname
sleep(100)
socket.writeString "VPX2 29;220;dataFile_asynchStringData No;"
sleep(100)
'Send event makers
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 30  '43 
	bytesThatMakePulseConfigCommand(3) = 0 	  '202 
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	'Ingeter 4 trigger the channel on STP100C that triggers the digital out lines
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 1
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines
	
	'sleep for duration of the pulse allows previous code to execute prior to resetting the lines
	sleep 30
	
	'Resets all stimtracker lines to 0 for pulse duration and command
	bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
	bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
	bytesThatMakePulseConfigCommand(2) = 0
	bytesThatMakePulseConfigCommand(3) = 0
	bytesThatMakePulseConfigCommand(4) = 0
	bytesThatMakePulseConfigCommand(5) = 0
	Serial.WriteBytes bytesThatMakePulseConfigCommand
	
	bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
	bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
	bytesToRaiseStimTrackerLines(2) = 0
	bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
	Serial.WriteBytes bytesToRaiseStimTrackerLines

breakfix = Clock.Read


	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - openpupfile1 END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	
	Fixation.Run
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetDelay, Fixation.OnsetDelay
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetTime, Fixation.OnsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDurationError, Fixation.DurationError
	c.SetAttrib Fixation.Name & ebDot & ebLogNamePreRelease, Fixation.PreRelease
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDuration, Fixation.Duration
	c.SetAttrib Fixation.Name & ebDot & ebLogNameStartTime, Fixation.StartTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOffsetTime, Fixation.OffsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRTTime, Fixation.RTTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameACC, Fixation.ACC
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRT, Fixation.RT
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRESP, Fixation.RESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameCRESP, Fixation.CRESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation.OnsetToOnsetTime
	
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Breakproc.TimelineFinish
	Standby.EndOfProcedure

	Waitingforpup.EndOfProcedure

	Fixation.EndOfProcedure

	Breakproc.EndOfProcedure
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetDelay, Fixation.OnsetDelay
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetTime, Fixation.OnsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDurationError, Fixation.DurationError
	c.SetAttrib Fixation.Name & ebDot & ebLogNamePreRelease, Fixation.PreRelease
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDuration, Fixation.Duration
	c.SetAttrib Fixation.Name & ebDot & ebLogNameStartTime, Fixation.StartTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOffsetTime, Fixation.OffsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRTTime, Fixation.RTTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameACC, Fixation.ACC
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRT, Fixation.RT
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRESP, Fixation.RESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameCRESP, Fixation.CRESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation.OnsetToOnsetTime
	

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Breakproc.ProcedureFinish
End Sub







Sub Beakprocshock_Run(c as Context)
	Beakprocshock.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock.ProcedureStart
		SAMDdid.ResetLoggingProperties
		shockcheck.ResetLoggingProperties
		CD5.ResetLoggingProperties
		CD4.ResetLoggingProperties
		CD3.ResetLoggingProperties
		CD2.ResetLoggingProperties
		CD1.ResetLoggingProperties
		Fixation3.ResetLoggingProperties
		shockscale.ResetLoggingProperties
		Moreshock.ResetLoggingProperties
		
	
								
	
	
	

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock.TimelineStart
	
	
	SAMDdid.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		SAMDdidEchoClients.RemoveAll
		SAMDdid.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(SAMDdid.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	SAMDdid.Run
	
	
	
	Standby.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		StandbyEchoClients.RemoveAll
		Standby.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Standby.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Standby.Run
	
	
	shockcheck.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		shockcheckEchoClients.RemoveAll
		shockcheck.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(shockcheck.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	shockcheck.Run
	
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label6 BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Label6:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Label6Resume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Label6Resume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Label6 END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	
	CD5.Run
	
	
	CD4.Run
	
	
	CD3.Run
	
	
	CD2.Run
	
	
	CD1.Run
	
	
	Fixation3.Run
	
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOffsetTime, Fixation3.OffsetTime
	
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - shockcode BEGIN <shockcode>
	'''''''''''''''''''''''''''''''''''''''''''''
	'Shock Code	
bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
bytesThatMakePulseConfigCommand(2) = 200  '43 
bytesThatMakePulseConfigCommand(3) = 0 '202 
bytesThatMakePulseConfigCommand(4) = 0
bytesThatMakePulseConfigCommand(5) = 0
Serial.WriteBytes bytesThatMakePulseConfigCommand
	
'Ingeter 4 trigger the channel on STP100C that triggers the digital out lines
bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
bytesToRaiseStimTrackerLines(2) = 4
bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
Serial.WriteBytes bytesToRaiseStimTrackerLines
	
'sleep for duration of the pulse allows previous code to execute prior to resetting the lines
sleep 200
	
'Resets all stimtracker lines to 0 for pulse duration and command
bytesThatMakePulseConfigCommand(0) = 109 ' ascii m
bytesThatMakePulseConfigCommand(1) = 112 ' ascii p
bytesThatMakePulseConfigCommand(2) = 0
bytesThatMakePulseConfigCommand(3) = 0
bytesThatMakePulseConfigCommand(4) = 0
bytesThatMakePulseConfigCommand(5) = 0
Serial.WriteBytes bytesThatMakePulseConfigCommand

bytesToRaiseStimTrackerLines(0) = 109 ' ascii m
bytesToRaiseStimTrackerLines(1) = 104 ' ascii h
bytesToRaiseStimTrackerLines(2) = 0
bytesToRaiseStimTrackerLines(3) = 0 ' this final byte is currently ignored by StimTracker
Serial.WriteBytes bytesToRaiseStimTrackerLines
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - shockcode END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	
	shockscale.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		shockscaleEchoClients.RemoveAll
		shockscale.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(shockscale.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	shockscale.Run
	
	
	
	Moreshock.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		MoreshockEchoClients.RemoveAll
		Moreshock.InputMasks.Add Keyboard.CreateInputMask(ebDigit_1 & ebDigit_2, _ 
				ebEmptyText, _ 
				CLng(Moreshock.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Moreshock.Run
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - InLine1 BEGIN <InLine1>
	'''''''''''''''''''''''''''''''''''''''''''''
	If (Moreshock.RESP = 1) Then
GoTo Label6
End If 
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - InLine1 END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	
	Intelligence.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		IntelligenceEchoClients.RemoveAll
		Intelligence.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Intelligence.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Intelligence.Run
	
	
	Waitingforpup.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		WaitingforpupEchoClients.RemoveAll
		Waitingforpup.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & "=" & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Waitingforpup.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Waitingforpup.Run
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - openpupfile2 BEGIN <openpupfile2>
	'''''''''''''''''''''''''''''''''''''''''''''
	Dim pupfname As String
Dim tmp As Integer
tmp=len("dataFile_NewName" & " " & "'TOL_pup_"&"2_" & c.GetAttrib("Subject") & ".txt';")
pupfname = "VPX2" &" "& tmp & ";220;dataFile_NewName" & " " & "'TOL_pup_"&"2_" & c.GetAttrib("Subject") & ".txt';"
'debug.print pupfname
socket.writestring pupfname
sleep(100)
socket.writeString "VPX2 29;220;dataFile_asynchStringData No;"
sleep(100)
breakfix = Clock.Read
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - openpupfile2 END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	Fixation.Run
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetDelay, Fixation.OnsetDelay
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetTime, Fixation.OnsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDurationError, Fixation.DurationError
	c.SetAttrib Fixation.Name & ebDot & ebLogNamePreRelease, Fixation.PreRelease
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDuration, Fixation.Duration
	c.SetAttrib Fixation.Name & ebDot & ebLogNameStartTime, Fixation.StartTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOffsetTime, Fixation.OffsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRTTime, Fixation.RTTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameACC, Fixation.ACC
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRT, Fixation.RT
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRESP, Fixation.RESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameCRESP, Fixation.CRESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation.OnsetToOnsetTime
	
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock.TimelineFinish
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Beakprocshock_theCollection.RemoveAll
	For Beakprocshock_nObject = 1 To Beakprocshock.ChildObjectCount
		Set Beakprocshock_theInputObject = CRteRunnableInputObject(Rte.GetObject(Beakprocshock.GetChildObjectName(Beakprocshock_nObject)))
		If Not Beakprocshock_theInputObject Is Nothing Then Beakprocshock_theCollection.Add Beakprocshock_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Beakprocshock_bCanExit = True
		For Beakprocshock_nObject = 1 To Beakprocshock_theCollection.Count
			Set Beakprocshock_theInputObject = CRteRunnableInputObject(Beakprocshock_theCollection(Beakprocshock_nObject))
			If Not Beakprocshock_theInputObject Is Nothing Then
				If Beakprocshock_theInputObject.InputMasks.IsPending() Then 
					Beakprocshock_bCanExit = False
					Exit For
				End If
			End If
		Next
		
		' No input masks
		If Beakprocshock_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Beakprocshock_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	
	SAMDdid.EndOfProcedure

	Standby.EndOfProcedure

	shockcheck.EndOfProcedure

	CD5.EndOfProcedure

	CD4.EndOfProcedure

	CD3.EndOfProcedure

	CD2.EndOfProcedure

	CD1.EndOfProcedure

	Fixation3.EndOfProcedure

	shockscale.EndOfProcedure

	Moreshock.EndOfProcedure

	Intelligence.EndOfProcedure

	Waitingforpup.EndOfProcedure

	Fixation.EndOfProcedure

	Beakprocshock.EndOfProcedure
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOnsetTime, Fixation3.OnsetTime
	c.SetAttrib Fixation3.Name & ebDot & ebLogNameOffsetTime, Fixation3.OffsetTime
	
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetDelay, Fixation.OnsetDelay
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetTime, Fixation.OnsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDurationError, Fixation.DurationError
	c.SetAttrib Fixation.Name & ebDot & ebLogNamePreRelease, Fixation.PreRelease
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDuration, Fixation.Duration
	c.SetAttrib Fixation.Name & ebDot & ebLogNameStartTime, Fixation.StartTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOffsetTime, Fixation.OffsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRTTime, Fixation.RTTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameACC, Fixation.ACC
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRT, Fixation.RT
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRESP, Fixation.RESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameCRESP, Fixation.CRESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation.OnsetToOnsetTime
	

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock.ProcedureFinish
End Sub

















Sub Beakprocshock3_Run(c as Context)
	Beakprocshock3.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock3.ProcedureStart
		SAMDdid.ResetLoggingProperties
		
	
	
	

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock3.TimelineStart
	
	
	SAMDdid.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		SAMDdidEchoClients.RemoveAll
		SAMDdid.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(SAMDdid.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	SAMDdid.Run
	
	
	
	Standby.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		StandbyEchoClients.RemoveAll
		Standby.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Standby.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Standby.Run
	
	
	Intelligence1.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		Intelligence1EchoClients.RemoveAll
		Intelligence1.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Intelligence1.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Intelligence1.Run
	
	
	Waitingforpup.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		WaitingforpupEchoClients.RemoveAll
		Waitingforpup.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & "=" & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Waitingforpup.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Waitingforpup.Run
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - openpupfile3 BEGIN <openpupfile3>
	'''''''''''''''''''''''''''''''''''''''''''''
	Dim pupfname As String
Dim tmp As Integer
tmp=len("dataFile_NewName" & " " & "'TOL_pup_"&"3_" & c.GetAttrib("Subject") & ".txt';")
pupfname = "VPX2" &" "& tmp & ";220;dataFile_NewName" & " " & "'TOL_pup_"&"3_" & c.GetAttrib("Subject") & ".txt';"
'debug.print pupfname
socket.writestring pupfname
sleep(100)
socket.writeString "VPX2 29;220;dataFile_asynchStringData No;"
sleep(100)
breakfix = Clock.Read
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - openpupfile3 END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	Fixation.Run
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetDelay, Fixation.OnsetDelay
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetTime, Fixation.OnsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDurationError, Fixation.DurationError
	c.SetAttrib Fixation.Name & ebDot & ebLogNamePreRelease, Fixation.PreRelease
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDuration, Fixation.Duration
	c.SetAttrib Fixation.Name & ebDot & ebLogNameStartTime, Fixation.StartTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOffsetTime, Fixation.OffsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRTTime, Fixation.RTTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameACC, Fixation.ACC
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRT, Fixation.RT
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRESP, Fixation.RESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameCRESP, Fixation.CRESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation.OnsetToOnsetTime
	
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock3.TimelineFinish
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Beakprocshock3_theCollection.RemoveAll
	For Beakprocshock3_nObject = 1 To Beakprocshock3.ChildObjectCount
		Set Beakprocshock3_theInputObject = CRteRunnableInputObject(Rte.GetObject(Beakprocshock3.GetChildObjectName(Beakprocshock3_nObject)))
		If Not Beakprocshock3_theInputObject Is Nothing Then Beakprocshock3_theCollection.Add Beakprocshock3_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Beakprocshock3_bCanExit = True
		For Beakprocshock3_nObject = 1 To Beakprocshock3_theCollection.Count
			Set Beakprocshock3_theInputObject = CRteRunnableInputObject(Beakprocshock3_theCollection(Beakprocshock3_nObject))
			If Not Beakprocshock3_theInputObject Is Nothing Then
				If Beakprocshock3_theInputObject.InputMasks.IsPending() Then 
					Beakprocshock3_bCanExit = False
					Exit For
				End If
			End If
		Next
		
		' No input masks
		If Beakprocshock3_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Beakprocshock3_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	
	SAMDdid.EndOfProcedure

	Standby.EndOfProcedure

	Intelligence1.EndOfProcedure

	Waitingforpup.EndOfProcedure

	Fixation.EndOfProcedure

	Beakprocshock3.EndOfProcedure
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetDelay, Fixation.OnsetDelay
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetTime, Fixation.OnsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDurationError, Fixation.DurationError
	c.SetAttrib Fixation.Name & ebDot & ebLogNamePreRelease, Fixation.PreRelease
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDuration, Fixation.Duration
	c.SetAttrib Fixation.Name & ebDot & ebLogNameStartTime, Fixation.StartTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOffsetTime, Fixation.OffsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRTTime, Fixation.RTTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameACC, Fixation.ACC
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRT, Fixation.RT
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRESP, Fixation.RESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameCRESP, Fixation.CRESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation.OnsetToOnsetTime
	

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock3.ProcedureFinish
End Sub

Sub Beakprocshock4_Run(c as Context)
	Beakprocshock4.ArmTasks

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock4.ProcedureStart
		SAMDdid.ResetLoggingProperties
		
	
	
	

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Start:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_StartResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_StartResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Start END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock4.TimelineStart
	
	
	SAMDdid.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		SAMDdidEchoClients.RemoveAll
		SAMDdid.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(SAMDdid.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	SAMDdid.Run
	
	
	
	Standby.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		StandbyEchoClients.RemoveAll
		Standby.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Standby.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Standby.Run
	
	
	Intelligence1.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		Intelligence1EchoClients.RemoveAll
		Intelligence1.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & ebUCase_S & ebUCase_P & ebUCase_A & ebUCase_C & ebUCase_E & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Intelligence1.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Intelligence1.Run
	
	
	Waitingforpup.InputMasks.Reset
	
	If Keyboard.GetState() = ebStateOpen Then
		WaitingforpupEchoClients.RemoveAll
		Waitingforpup.InputMasks.Add Keyboard.CreateInputMask(ebBraceOpen & "=" & ebBraceClose, _ 
				ebEmptyText, _ 
				CLng(Waitingforpup.Duration), _ 
				CLng(ebDigit_1), _ 
				ebEndResponseActionTerminate, _ 
				CLogical(ebUCase_Y & ebLCase_e & ebLCase_s), _ 
				ebEmptyText, _ 
				ebEmptyText, _ 
				ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s & ebSpace & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e & ebColon & ebUCase_A & ebLCase_l & ebLCase_l & ebSpace & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_B & ebLCase_a & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_p & ebLCase_a & ebLCase_c & ebLCase_e & ebColon & ebUCase_Y & ebLCase_e & ebLCase_s)

	
	End If

	Waitingforpup.Run
	
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - openpupfile4 BEGIN <openpupfile4>
	'''''''''''''''''''''''''''''''''''''''''''''
	Dim pupfname As String
Dim tmp As Integer
tmp=len("dataFile_NewName" & " " & "'TOL_pup_"&"4_" & c.GetAttrib("Subject") & ".txt';")
pupfname = "VPX2" &" "& tmp  & ";220;dataFile_NewName" & " " & "'TOL_pup_"&"4_" & c.GetAttrib("Subject") & ".txt';"
'debug.print pupfname
socket.writestring pupfname
sleep(100)
socket.writeString "VPX2 29;220;dataFile_asynchStringData No;"
sleep(100)
breakfix = Clock.Read
	'''''''''''''''''''''''''''''''''''''''''''''
	' InLine - openpupfile4 END
	'''''''''''''''''''''''''''''''''''''''''''''
	
	
	Fixation.Run
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetDelay, Fixation.OnsetDelay
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetTime, Fixation.OnsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDurationError, Fixation.DurationError
	c.SetAttrib Fixation.Name & ebDot & ebLogNamePreRelease, Fixation.PreRelease
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDuration, Fixation.Duration
	c.SetAttrib Fixation.Name & ebDot & ebLogNameStartTime, Fixation.StartTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOffsetTime, Fixation.OffsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRTTime, Fixation.RTTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameACC, Fixation.ACC
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRT, Fixation.RT
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRESP, Fixation.RESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameCRESP, Fixation.CRESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation.OnsetToOnsetTime
	
	'''''''''''''''''''''''''''''''''''''''''''''
	'End Of Procedure Clean-Up
	'''''''''''''''''''''''''''''''''''''''''''''

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Timeline_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_Timeline_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_Timeline_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Timeline_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock4.TimelineFinish
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	' We are processing any pending input masks.
	' To prevent this code from being generated, set the Procedure object's
	'.ProcessPendingInputMasks property to None.
	'

	' Enum through the items on the Procedure and
	'  and determine if they are RteRunnableInputObject
	Beakprocshock4_theCollection.RemoveAll
	For Beakprocshock4_nObject = 1 To Beakprocshock4.ChildObjectCount
		Set Beakprocshock4_theInputObject = CRteRunnableInputObject(Rte.GetObject(Beakprocshock4.GetChildObjectName(Beakprocshock4_nObject)))
		If Not Beakprocshock4_theInputObject Is Nothing Then Beakprocshock4_theCollection.Add Beakprocshock4_theInputObject
	Next

	' Loop until a condition allows us to complete this Procedure
	Do
		'Any requests for termination?
		If GetTerminateMode() = ebTerminate Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Exit Do
		ElseIf GetTerminateMode() = ebTerminateJump Then
			SetTerminateMode ebTerminateNone
			SetNextTargetOnsetTime Clock.Read
			Err.Raise ebInputAccepted
		End If

		' Any input mask on this procedure have pending input masks?
		Beakprocshock4_bCanExit = True
		For Beakprocshock4_nObject = 1 To Beakprocshock4_theCollection.Count
			Set Beakprocshock4_theInputObject = CRteRunnableInputObject(Beakprocshock4_theCollection(Beakprocshock4_nObject))
			If Not Beakprocshock4_theInputObject Is Nothing Then
				If Beakprocshock4_theInputObject.InputMasks.IsPending() Then 
					Beakprocshock4_bCanExit = False
					Exit For
				End If
			End If
		Next
		
		' No input masks
		If Beakprocshock4_bCanExit Then Exit Do

		'Ready for the next object?
		If Clock.Read >= GetNextTargetOnsetTime() Then
			Exit Do
		End If

		'Conditional Exit?
		If GetConditionalExitState() <> 0 Then
			Exit Do
		End If

		If GetNextTargetOnsetTime() - Clock.Read > 4 Then Sleep 4
		DoEvents
	Loop

	' Cleanup
	Beakprocshock4_theCollection.RemoveAll

	'
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	
	SAMDdid.EndOfProcedure

	Standby.EndOfProcedure

	Intelligence1.EndOfProcedure

	Waitingforpup.EndOfProcedure

	Fixation.EndOfProcedure

	Beakprocshock4.EndOfProcedure
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetDelay, Fixation.OnsetDelay
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetTime, Fixation.OnsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDurationError, Fixation.DurationError
	c.SetAttrib Fixation.Name & ebDot & ebLogNamePreRelease, Fixation.PreRelease
	c.SetAttrib Fixation.Name & ebDot & ebLogNameDuration, Fixation.Duration
	c.SetAttrib Fixation.Name & ebDot & ebLogNameStartTime, Fixation.StartTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOffsetTime, Fixation.OffsetTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRTTime, Fixation.RTTime
	c.SetAttrib Fixation.Name & ebDot & ebLogNameACC, Fixation.ACC
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRT, Fixation.RT
	c.SetAttrib Fixation.Name & ebDot & ebLogNameRESP, Fixation.RESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameCRESP, Fixation.CRESP
	c.SetAttrib Fixation.Name & ebDot & ebLogNameOnsetToOnsetTime, Fixation.OnsetToOnsetTime
	

	c.Log

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish BEGIN
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Procedure_Finish:
	If Err.Number = ebInputAccepted Then
		Err.Clear
		Resume Procedure_FinishResume
	ElseIf Err.Number <> 0 Then
		'NOTE: If you receive a runtime error here, it
		' is because a runtime error other than ebInputAccepted
		' was thrown (ebInputAccepted for catching input masks that jump).
		'You are encouraged to either handle the error so that
		' it is not thrown in the future or will have to set up
		' your own error handler, which will also need to take
		' into account for any input masks that jump.
		'
		'Raise the error so the default error handler will show the message
		Err.Raise Err.Number, Err.Source, Err.Description
	End If

Procedure_FinishResume:

	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	'	Label - Procedure_Finish END
	''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Beakprocshock4.ProcedureFinish
End Sub



'--------------------------------------------------------------------------
' PreInitDevices
'
'--------------------------------------------------------------------------
Sub PreInitDevices(c As Context)

End Sub



'--------------------------------------------------------------------------
' PostInitDevices
'
'--------------------------------------------------------------------------
Sub PostInitDevices(c As Context)


	' Log DisplayDevice(s) Refresh Rates
Dim DisplayOpen As Boolean
	DisplayOpen = True
	If c.AttribExists(Display.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then DisplayOpen = CLogical(c.GetAttrib(Display.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If DisplayOpen = True Then
		c.SetAttrib Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e, Format$(Display.CalculatedRefreshRate, ebDigit_0 & ebDot & ebDigit_0 & ebDigit_0 & ebDigit_0)

		'Ensure that the refresh rate is acceptable
		If CLng(Display.CalculatedRefreshRate) = 0 Then
			'WARNING: RefreshRate of 0 (Zero) Detected.  Experiment will assume 60hz to continue. Data collection should NOT be used for time critical analysis.  Please ensure your display adapter is configured with the most recent and device specific driver.\n(Standard Display Adapter under Windows Vista or later is not compatible)
			Dim strDisplayError As String
			strDisplayError = ebUCase_W & ebUCase_A & ebUCase_R & ebUCase_N & ebUCase_I & ebUCase_N & ebUCase_G & ebColon & ebSpace & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e & ebSpace & ebLCase_o & ebLCase_f & ebSpace & ebDigit_0 & ebSpace & ebParenOpen & ebUCase_Z & ebLCase_e & ebLCase_r & ebLCase_o & ebParenClose & ebSpace & ebUCase_D & ebLCase_e & ebLCase_t & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_e & ebLCase_d & ebDot & ebSpace & ebSpace & ebUCase_E & ebLCase_x & ebLCase_p & ebLCase_e & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t & ebSpace & ebLCase_w & ebLCase_i & ebLCase_l & ebLCase_l & ebSpace & ebLCase_a & ebLCase_s & ebLCase_s & ebLCase_u & ebLCase_m & ebLCase_e & ebSpace & ebDigit_6 & ebDigit_0 & ebLCase_h & ebLCase_z & ebSpace & ebLCase_t & ebLCase_o & ebSpace & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_u & ebLCase_e & ebDot & ebSpace & ebUCase_D & ebLCase_a & ebLCase_t & ebLCase_a & ebSpace & ebLCase_c & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebSpace & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_u & ebLCase_l & ebLCase_d & ebSpace & ebUCase_N & ebUCase_O & ebUCase_T & ebSpace & ebLCase_b & ebLCase_e & ebSpace & ebLCase_u & ebLCase_s & ebLCase_e & ebLCase_d & ebSpace & ebLCase_f & ebLCase_o & ebLCase_r & ebSpace & ebLCase_t & ebLCase_i & ebLCase_m & ebLCase_e & ebSpace & ebLCase_c & ebLCase_r & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_c & ebLCase_a & ebLCase_l & ebSpace & ebLCase_a & ebLCase_n & ebLCase_a & ebLCase_l & ebLCase_y & ebLCase_s & ebLCase_i & ebLCase_s & ebDot & ebSpace & ebSpace & ebUCase_P & ebLCase_l & ebLCase_e & ebLCase_a & ebLCase_s & ebLCase_e & ebSpace & ebLCase_e & ebLCase_n & ebLCase_s & ebLCase_u & ebLCase_r & ebLCase_e & ebSpace & ebLCase_y & ebLCase_o & ebLCase_u & ebLCase_r & ebSpace & ebLCase_d & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebSpace & ebLCase_a & ebLCase_d & ebLCase_a & ebLCase_p & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_i & ebLCase_s & ebSpace & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_f & ebLCase_i & ebLCase_g & ebLCase_u & ebLCase_r & ebLCase_e & ebLCase_d & ebSpace & ebLCase_w & ebLCase_i & ebLCase_t & ebLCase_h & ebSpace & ebLCase_t & ebLCase_h & ebLCase_e & ebSpace & ebLCase_m & ebLCase_o & ebLCase_s & ebLCase_t & ebSpace & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_e & ebLCase_n & ebLCase_t & ebSpace & ebLCase_a & ebLCase_n & ebLCase_d & ebSpace & ebLCase_d & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebSpace & ebLCase_s & ebLCase_p & ebLCase_e & ebLCase_c & ebLCase_i & ebLCase_f & ebLCase_i & ebLCase_c & ebSpace & ebLCase_d & ebLCase_r & ebLCase_i & ebLCase_v & ebLCase_e & ebLCase_r & ebDot & ebLf & ebParenOpen & ebUCase_S & ebLCase_t & ebLCase_a & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_d & ebSpace & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebSpace & ebUCase_A & ebLCase_d & ebLCase_a & ebLCase_p & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_u & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_r & ebSpace & ebUCase_W & ebLCase_i & ebLCase_n & ebLCase_d & ebLCase_o & ebLCase_w & ebLCase_s & ebSpace & ebUCase_V & ebLCase_i & ebLCase_s & ebLCase_t & ebLCase_a & ebSpace & ebLCase_o & ebLCase_r & ebSpace & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_i & ebLCase_s & ebSpace & ebLCase_n & ebLCase_o & ebLCase_t & ebSpace & ebLCase_c & ebLCase_o & ebLCase_m & ebLCase_p & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_b & ebLCase_l & ebLCase_e & ebParenClose
			Debug.Print strDisplayError
			c.SetAttrib ebUCase_A & ebUCase_W & ebLCase_a & ebLCase_r & ebLCase_n & ebLCase_i & ebLCase_n & ebLCase_g & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e, strDisplayError
		End If

		'Determine RefreshRate range
		Dim dblDisplayMinRefreshRate As Double
		Dim dblDisplayMaxRefreshRate As Double
		dblDisplayMinRefreshRate = 39
		dblDisplayMaxRefreshRate = 201
		If c.AttribExists(Display.Name & ebDot & ebUCase_M & ebLCase_i & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e) Then dblDisplayMinRefreshRate = CDbl(c.GetAttrib(Display.Name & ebDot & ebUCase_M & ebLCase_i & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e))
		If c.AttribExists(Display.Name & ebDot & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e) Then dblDisplayMaxRefreshRate = CDbl(c.GetAttrib(Display.Name & ebDot & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e))

		'Ensure that the refresh rate is within range
		If Display.CalculatedRefreshRate < dblDisplayMinRefreshRate Or Display.CalculatedRefreshRate > dblDisplayMaxRefreshRate Then
			' Only throw error if running fullscreen.
			' If windowed, E-Prime timing isn't guaranteed so we may proceed.
			If Not CLogical(c.GetAttribOrDefault(ebUCase_E & ebLCase_x & ebLCase_p & ebLCase_e & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t & ebDot & ebUCase_W & ebLCase_i & ebLCase_n & ebLCase_d & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_d, ebDigit_0)) Then
				'Unable to obtain a valid refresh rate.\n\nPlease ensure your display adapter is configured with the most recent and device specific driver.\n(Standard Display Adapter under Windows Vista is not compatible)
				Rte.AbortExperiment -999, ebUCase_U & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebSpace & ebLCase_t & ebLCase_o & ebSpace & ebLCase_o & ebLCase_b & ebLCase_t & ebLCase_a & ebLCase_i & ebLCase_n & ebSpace & ebLCase_a & ebSpace & ebLCase_v & ebLCase_a & ebLCase_l & ebLCase_i & ebLCase_d & ebSpace & ebLCase_r & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebSpace & ebLCase_r & ebLCase_a & ebLCase_t & ebLCase_e & ebDot & ebLf & ebLf & ebUCase_P & ebLCase_l & ebLCase_e & ebLCase_a & ebLCase_s & ebLCase_e & ebSpace & ebLCase_e & ebLCase_n & ebLCase_s & ebLCase_u & ebLCase_r & ebLCase_e & ebSpace & ebLCase_y & ebLCase_o & ebLCase_u & ebLCase_r & ebSpace & ebLCase_d & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebSpace & ebLCase_a & ebLCase_d & ebLCase_a & ebLCase_p & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_i & ebLCase_s & ebSpace & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_f & ebLCase_i & ebLCase_g & ebLCase_u & ebLCase_r & ebLCase_e & ebLCase_d & ebSpace & ebLCase_w & ebLCase_i & ebLCase_t & ebLCase_h & ebSpace & ebLCase_t & ebLCase_h & ebLCase_e & ebSpace & ebLCase_m & ebLCase_o & ebLCase_s & ebLCase_t & ebSpace & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_e & ebLCase_n & ebLCase_t & ebSpace & ebLCase_a & ebLCase_n & ebLCase_d & ebSpace & ebLCase_d & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebSpace & ebLCase_s & ebLCase_p & ebLCase_e & ebLCase_c & ebLCase_i & ebLCase_f & ebLCase_i & ebLCase_c & ebSpace & ebLCase_d & ebLCase_r & ebLCase_i & ebLCase_v & ebLCase_e & ebLCase_r & ebDot & ebLf & ebParenOpen & ebUCase_S & ebLCase_t & ebLCase_a & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_d & ebSpace & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebSpace & ebUCase_A & ebLCase_d & ebLCase_a & ebLCase_p & ebLCase_t & ebLCase_e & ebLCase_r & ebSpace & ebLCase_u & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_r & ebSpace & ebUCase_W & ebLCase_i & ebLCase_n & ebLCase_d & ebLCase_o & ebLCase_w & ebLCase_s & ebSpace & ebUCase_V & ebLCase_i & ebLCase_s & ebLCase_t & ebLCase_a & ebSpace & ebLCase_i & ebLCase_s & ebSpace & ebLCase_n & ebLCase_o & ebLCase_t & ebSpace & ebLCase_c & ebLCase_o & ebLCase_m & ebLCase_p & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_b & ebLCase_l & ebLCase_e & ebParenClose
			End If
		End If
	End If
	'Assign the input device to filter for the ButtonDevice
	Button.AttachDevice CInputDevice(Rte.DeviceManager.GetDevice(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_I & ebLCase_n & ebLCase_p & ebLCase_u & ebLCase_t & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_T & ebLCase_o & ebUCase_F & ebLCase_i & ebLCase_l & ebLCase_t & ebLCase_e & ebLCase_r, Mouse.Name)))

	'Assign the DisplayName to filter for the ButtonDevice
	Button.DisplayName = c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e, ebEmptyText)

	Button.ReservedA = c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_A, ebEmptyText)
	Button.ReservedB = c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_B, ebEmptyText)
	Button.ReservedC = c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_C, ebEmptyText)
	Button.ReservedD = c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_e & ebLCase_r & ebLCase_v & ebLCase_e & ebLCase_d & ebUCase_D, ebEmptyText)
	Button.ShowHover = c.GetAttribOrDefault(CLogical(Button.Name & ebDot & ebUCase_S & ebLCase_h & ebLCase_o & ebLCase_w & ebUCase_H & ebLCase_o & ebLCase_v & ebLCase_e & ebLCase_r), True)
	Button.ShowDown = c.GetAttribOrDefault(CLogical(Button.Name & ebDot & ebUCase_S & ebLCase_h & ebLCase_o & ebLCase_w & ebUCase_D & ebLCase_o & ebLCase_w & ebLCase_n), True)
	Button.ShowFixated = c.GetAttribOrDefault(CLogical(Button.Name & ebDot & ebUCase_S & ebLCase_h & ebLCase_o & ebLCase_w & ebUCase_F & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_e & ebLCase_d), False)

End Sub



'--------------------------------------------------------------------------
' InitDevices
'
'--------------------------------------------------------------------------
Sub InitDevices(c As Context)

	PreInitDevices c


	Set Display = New DisplayDevice
	Display.Name = ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y

	Dim DisplayDisplayDeviceInfo As DisplayDeviceInfo
	DisplayDisplayDeviceInfo.XRes = 640
	DisplayDisplayDeviceInfo.YRes = 480
	DisplayDisplayDeviceInfo.ColorDepth = 32
	DisplayDisplayDeviceInfo.DisplayIndex = 1
	DisplayDisplayDeviceInfo.UseDesktopSettings = False
	DisplayDisplayDeviceInfo.DefaultColor = Color.White
	DisplayDisplayDeviceInfo.RefreshRateRequested = 0
	DisplayDisplayDeviceInfo.NumPages = 0
	
	'Load values from context if they exist
	If c.AttribExists(Display.Name & ebDot & ebUCase_X & ebUCase_R & ebLCase_e & ebLCase_s) Then DisplayDisplayDeviceInfo.XRes = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_X & ebUCase_R & ebLCase_e & ebLCase_s))
	If c.AttribExists(Display.Name & ebDot & ebUCase_Y & ebUCase_R & ebLCase_e & ebLCase_s) Then DisplayDisplayDeviceInfo.YRes = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_Y & ebUCase_R & ebLCase_e & ebLCase_s))
	If c.AttribExists(Display.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r & ebUCase_D & ebLCase_e & ebLCase_p & ebLCase_t & ebLCase_h) Then DisplayDisplayDeviceInfo.ColorDepth = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r & ebUCase_D & ebLCase_e & ebLCase_p & ebLCase_t & ebLCase_h))
	If c.AttribExists(Display.Name & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x) Then DisplayDisplayDeviceInfo.DisplayIndex = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x))
	If c.AttribExists(Display.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r) Then DisplayDisplayDeviceInfo.DefaultColor = CColor(c.GetAttrib(Display.Name & ebDot & ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r))
	If c.AttribExists(Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_d) Then DisplayDisplayDeviceInfo.RefreshRateRequested = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_R & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_R & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_d))
	If c.AttribExists(Display.Name & ebDot & ebUCase_N & ebLCase_u & ebLCase_m & ebUCase_P & ebLCase_a & ebLCase_g & ebLCase_e & ebLCase_s) Then DisplayDisplayDeviceInfo.NumPages = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_N & ebLCase_u & ebLCase_m & ebUCase_P & ebLCase_a & ebLCase_g & ebLCase_e & ebLCase_s))
	If c.AttribExists(Display.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_s & ebLCase_k & ebLCase_t & ebLCase_o & ebLCase_p & ebUCase_S & ebLCase_e & ebLCase_t & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s) Then DisplayDisplayDeviceInfo.UseDesktopSettings = CLogical(c.GetAttrib(Display.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_s & ebLCase_k & ebLCase_t & ebLCase_o & ebLCase_p & ebUCase_S & ebLCase_e & ebLCase_t & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_s))
	
	'Open the device, unless the context values indicate otherwise
	Dim DisplayOpen As Boolean
	DisplayOpen = True
	If c.AttribExists(Display.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then DisplayOpen = CLogical(c.GetAttrib(Display.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If DisplayOpen = True Then
		Display.Open DisplayDisplayDeviceInfo
		Display.RefreshAlignment = ebDigit_7 & ebDigit_5 & ebPercent
		If c.AttribExists(Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_A & ebLCase_l & ebLCase_i & ebLCase_g & ebLCase_n & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Display.RefreshAlignment = c.GetAttrib(Display.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_f & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebUCase_A & ebLCase_l & ebLCase_i & ebLCase_g & ebLCase_n & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t)
			Display.RTAdjustment = 0
		If c.AttribExists(Display.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Display.RTAdjustment = CLng(c.GetAttrib(Display.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t))
	End If

	'Enable flipping, if requested
	If c.AttribExists(Display.Name & ebDot & ebUCase_F & ebLCase_l & ebLCase_i & ebLCase_p & ebLCase_p & ebLCase_i & ebLCase_n & ebLCase_g & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d) Then
		Display.FlippingEnabled = CLogical(c.GetAttrib(Display.Name & ebDot & ebUCase_F & ebLCase_l & ebLCase_i & ebLCase_p & ebLCase_p & ebLCase_i & ebLCase_n & ebLCase_g & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d))
	Else
		Display.FlippingEnabled = True
	End If

	Set Keyboard = New KeyboardDevice
	Keyboard.Name = ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_b & ebLCase_o & ebLCase_a & ebLCase_r & ebLCase_d


	Dim KeyboardKeyboardDeviceInfo as KeyboardDeviceInfo
	KeyboardKeyboardDeviceInfo.CollectionMode = ebPressesOnly
	KeyboardKeyboardDeviceInfo.CapsLock = ebCapsLockOff
	KeyboardKeyboardDeviceInfo.NumLock = ebNumLockOn
	'Load values from context if they exist
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e) Then KeyboardKeyboardDeviceInfo.CollectionMode = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e))
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_C & ebLCase_a & ebLCase_p & ebLCase_s & ebUCase_L & ebLCase_o & ebLCase_c & ebLCase_k) Then KeyboardKeyboardDeviceInfo.CapsLock = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_C & ebLCase_a & ebLCase_p & ebLCase_s & ebUCase_L & ebLCase_o & ebLCase_c & ebLCase_k))
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_N & ebLCase_u & ebLCase_m & ebUCase_L & ebLCase_o & ebLCase_c & ebLCase_k) Then KeyboardKeyboardDeviceInfo.NumLock = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_N & ebLCase_u & ebLCase_m & ebUCase_L & ebLCase_o & ebLCase_c & ebLCase_k))
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e) Then KeyboardKeyboardDeviceInfo.EmulateDeviceName = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e)
	
	'Open the device, unless the context values indicate otherwise
	Dim KeyboardOpen As Boolean
	KeyboardOpen = True
	If c.AttribExists(Keyboard.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then KeyboardOpen = CLogical(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If KeyboardOpen = True Then
		Keyboard.Open KeyboardKeyboardDeviceInfo
		Keyboard.RTAdjustment = 0
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Keyboard.RTAdjustment = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t))
	
		Keyboard.AutoResponseEnabled = True
		Keyboard.AutoResponseTimeLimitLowerBound = ebDigit_2 & ebDigit_5 & ebPercent
		Keyboard.AutoResponseTimeLimitUpperBound = ebDigit_7 & ebDigit_5 & ebPercent
		Keyboard.AutoResponseTimeLimitWhenInfinite = 1000
		Keyboard.AutoResponseCorrectProbability = ebDigit_8 & ebDigit_0 & ebPercent
		Keyboard.AutoResponseAllowableOverride = ebEmptyText
		Keyboard.AutoResponseMaxCountLowerBound = ebDigit_2 & ebDigit_5 & ebPercent
		Keyboard.AutoResponseMaxCountUpperBound = ebDigit_7 & ebDigit_5 & ebPercent
		Keyboard.AutoResponseDelayBetweenResponses = 30
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d) Then Keyboard.AutoResponseEnabled = CLogical(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_E & ebLCase_n & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d))
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_L & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d) Then Keyboard.AutoResponseTimeLimitLowerBound = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_L & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_U & ebLCase_p & ebLCase_p & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d) Then Keyboard.AutoResponseTimeLimitUpperBound = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_U & ebLCase_p & ebLCase_p & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_W & ebLCase_h & ebLCase_e & ebLCase_n & ebUCase_I & ebLCase_n & ebLCase_f & ebLCase_i & ebLCase_n & ebLCase_i & ebLCase_t & ebLCase_e) Then Keyboard.AutoResponseTimeLimitWhenInfinite = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e & ebUCase_L & ebLCase_i & ebLCase_m & ebLCase_i & ebLCase_t & ebUCase_W & ebLCase_h & ebLCase_e & ebLCase_n & ebUCase_I & ebLCase_n & ebLCase_f & ebLCase_i & ebLCase_n & ebLCase_i & ebLCase_t & ebLCase_e))
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_b & ebLCase_a & ebLCase_b & ebLCase_i & ebLCase_l & ebLCase_i & ebLCase_t & ebLCase_y) Then Keyboard.AutoResponseCorrectProbability = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_b & ebLCase_a & ebLCase_b & ebLCase_i & ebLCase_l & ebLCase_i & ebLCase_t & ebLCase_y)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_A & ebLCase_l & ebLCase_l & ebLCase_o & ebLCase_w & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebUCase_O & ebLCase_v & ebLCase_e & ebLCase_r & ebLCase_r & ebLCase_i & ebLCase_d & ebLCase_e) Then Keyboard.AutoResponseAllowableOverride = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_A & ebLCase_l & ebLCase_l & ebLCase_o & ebLCase_w & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebUCase_O & ebLCase_v & ebLCase_e & ebLCase_r & ebLCase_r & ebLCase_i & ebLCase_d & ebLCase_e)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_C & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebUCase_L & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d) Then Keyboard.AutoResponseMaxCountLowerBound = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_C & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebUCase_L & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_C & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebUCase_U & ebLCase_p & ebLCase_p & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d) Then Keyboard.AutoResponseMaxCountUpperBound = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_M & ebLCase_a & ebLCase_x & ebUCase_C & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_t & ebUCase_U & ebLCase_p & ebLCase_p & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_o & ebLCase_u & ebLCase_n & ebLCase_d)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_B & ebLCase_e & ebLCase_t & ebLCase_w & ebLCase_e & ebLCase_e & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebLCase_s) Then Keyboard.AutoResponseDelayBetweenResponses = CLng(c.GetAttrib(Keyboard.Name & ebDot & ebUCase_A & ebLCase_u & ebLCase_t & ebLCase_o & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_B & ebLCase_e & ebLCase_t & ebLCase_w & ebLCase_e & ebLCase_e & ebLCase_n & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebLCase_s))
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_S & ebLCase_y & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_m & ebUCase_A & ebLCase_b & ebLCase_o & ebLCase_r & ebLCase_t & ebUCase_W & ebLCase_a & ebLCase_t & ebLCase_c & ebLCase_h & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Keyboard.SystemAbortWatchSequence = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_S & ebLCase_y & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_m & ebUCase_A & ebLCase_b & ebLCase_o & ebLCase_r & ebLCase_t & ebUCase_W & ebLCase_a & ebLCase_t & ebLCase_c & ebLCase_h & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l & ebUCase_E & ebLCase_x & ebLCase_i & ebLCase_t & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Keyboard.ConditionalExitSequence = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l & ebUCase_E & ebLCase_x & ebLCase_i & ebLCase_t & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
		If c.AttribExists(Keyboard.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Keyboard.UserBreakSequence = c.GetAttrib(Keyboard.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
	
	End If

	Set Mouse = New MouseDevice
	Mouse.Name = ebUCase_M & ebLCase_o & ebLCase_u & ebLCase_s & ebLCase_e


	Dim MouseMouseDeviceInfo as MouseDeviceInfo
	MouseMouseDeviceInfo.OpenMode = ebMouseOpenModeDirect
	MouseMouseDeviceInfo.CollectionMode = ebPressesOnly
	MouseMouseDeviceInfo.ShowCursor = False
	'Load values from context if they exist
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e) Then MouseMouseDeviceInfo.OpenMode = CLng(c.GetAttrib(Mouse.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e))
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e) Then MouseMouseDeviceInfo.CollectionMode = CLng(c.GetAttrib(Mouse.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_l & ebLCase_e & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_M & ebLCase_o & ebLCase_d & ebLCase_e))
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_S & ebLCase_h & ebLCase_o & ebLCase_w & ebUCase_C & ebLCase_u & ebLCase_r & ebLCase_s & ebLCase_o & ebLCase_r) Then MouseMouseDeviceInfo.ShowCursor = CLng(c.GetAttrib(Mouse.Name & ebDot & ebUCase_S & ebLCase_h & ebLCase_o & ebLCase_w & ebUCase_C & ebLCase_u & ebLCase_r & ebLCase_s & ebLCase_o & ebLCase_r))
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e) Then MouseMouseDeviceInfo.EmulateDeviceName = c.GetAttrib(Mouse.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e)
	
	'Open the device, unless the context values indicate otherwise
	Dim MouseOpen As Boolean
	MouseOpen = True
	If c.AttribExists(Mouse.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then MouseOpen = CLogical(c.GetAttrib(Mouse.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If MouseOpen = True Then
		Mouse.Open MouseMouseDeviceInfo
		If c.AttribExists(Mouse.Name & ebDot & ebUCase_S & ebLCase_y & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_m & ebUCase_A & ebLCase_b & ebLCase_o & ebLCase_r & ebLCase_t & ebUCase_W & ebLCase_a & ebLCase_t & ebLCase_c & ebLCase_h & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Mouse.SystemAbortWatchSequence = c.GetAttrib(Mouse.Name & ebDot & ebUCase_S & ebLCase_y & ebLCase_s & ebLCase_t & ebLCase_e & ebLCase_m & ebUCase_A & ebLCase_b & ebLCase_o & ebLCase_r & ebLCase_t & ebUCase_W & ebLCase_a & ebLCase_t & ebLCase_c & ebLCase_h & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
		If c.AttribExists(Mouse.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l & ebUCase_E & ebLCase_x & ebLCase_i & ebLCase_t & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Mouse.ConditionalExitSequence = c.GetAttrib(Mouse.Name & ebDot & ebUCase_C & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_a & ebLCase_l & ebUCase_E & ebLCase_x & ebLCase_i & ebLCase_t & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
		If c.AttribExists(Mouse.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e) Then Mouse.UserBreakSequence = c.GetAttrib(Mouse.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebLCase_r & ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebUCase_S & ebLCase_e & ebLCase_q & ebLCase_u & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e)
			Mouse.RTAdjustment = 0
		If c.AttribExists(Mouse.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t) Then Mouse.RTAdjustment = CLng(c.GetAttrib(Mouse.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t))
	
	End If

	Set Socket = New SocketDevice
	Socket.Name = "Socket"

	Dim SocketSocketDeviceInfo As SocketDeviceInfo
	SocketSocketDeviceInfo.Server = "10.48.88.226"
	SocketSocketDeviceInfo.Port = 5000
	SocketSocketDeviceInfo.SocketType = ebProtocolTcp
	SocketSocketDeviceInfo.ByteOrdering = ebByteOrderingNative
	'Load values from context if they exist
	If c.AttribExists(Socket.Name & ".Server") Then SocketSocketDeviceInfo.Server = c.GetAttrib(Socket.Name & ".Server")
	If c.AttribExists(Socket.Name & ".Port") Then SocketSocketDeviceInfo.Port = CLng(c.GetAttrib(Socket.Name & ".Port"))
	If c.AttribExists(Socket.Name & ".SocketType") Then SocketSocketDeviceInfo.SocketType = CLng(c.GetAttrib(Socket.Name & ".SocketType"))
	If c.AttribExists(Socket.Name & ".ByteOrdering") Then SocketSocketDeviceInfo.ByteOrdering = CLng(c.GetAttrib(Socket.Name & ".ByteOrdering"))
	
	'Open the device, unless the context values indicate otherwise
	Dim SocketOpen As Boolean
	SocketOpen = True
	If c.AttribExists(Socket.Name & ".Open") Then SocketOpen = CLogical(c.GetAttrib(Socket.Name & ".Open"))
	If SocketOpen = True Then
		Socket.Open SocketSocketDeviceInfo

	End If

	Set Button = New ButtonDevice
	Button.Name = ebUCase_B & ebLCase_u & ebLCase_t & ebLCase_t & ebLCase_o & ebLCase_n


	Dim ButtonButtonDeviceInfo as ButtonDeviceInfo
	ButtonButtonDeviceInfo.ResponseTypes = 196862
	ButtonButtonDeviceInfo.DblClickTime = 500
	ButtonButtonDeviceInfo.LongPressTime = 1000
	ButtonButtonDeviceInfo.FixationTime = 3000
	
	'Load values from context if they exist
	'Button.ResponseTypes
	ButtonButtonDeviceInfo.ResponseTypes = CLng(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebLCase_s, ButtonButtonDeviceInfo.ResponseTypes))

	'Button.ResponseTypeDown - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_D & ebLCase_o & ebLCase_w & ebLCase_n, False)), 2, 0))

	'Button.ResponseTypeClick - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_C & ebLCase_l & ebLCase_i & ebLCase_c & ebLCase_k, False)), 4, 0))

	'Button.ResponseTypeDblClick - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_D & ebLCase_b & ebLCase_l & ebUCase_C & ebLCase_l & ebLCase_i & ebLCase_c & ebLCase_k, False)), 8, 0))

	'Button.ResponseTypeHover - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_H & ebLCase_o & ebLCase_v & ebLCase_e & ebLCase_r, False)), 32, 0))

	'Button.ResponseTypeLongpress - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_L & ebLCase_o & ebLCase_n & ebLCase_g & ebLCase_p & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_s, False)), 16, 0))

	'Button.ResponseTypeFixation - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_F & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n, False)), 64, 0))

	'Button.ResponseTypeCheck - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_C & ebLCase_h & ebLCase_e & ebLCase_c & ebLCase_k, False)), 128, 0))

	'Button.ResponseTypeSecondary - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y, False)), 65536, 0))

	'Button.ResponseTypeInactive - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_I & ebLCase_n & ebLCase_a & ebLCase_c & ebLCase_t & ebLCase_i & ebLCase_v & ebLCase_e, False)), 131072, 0))

	'Button.ResponseTypeDisabled - BitMask
	ButtonButtonDeviceInfo.ResponseTypes = ButtonButtonDeviceInfo.ResponseTypes Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebLCase_e & ebLCase_s & ebLCase_p & ebLCase_o & ebLCase_n & ebLCase_s & ebLCase_e & ebUCase_T & ebLCase_y & ebLCase_p & ebLCase_e & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_a & ebLCase_b & ebLCase_l & ebLCase_e & ebLCase_d, False)), 262144, 0))

	'Button.DblClickTime
	ButtonButtonDeviceInfo.DblClickTime = CLng(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_D & ebLCase_b & ebLCase_l & ebUCase_C & ebLCase_l & ebLCase_i & ebLCase_c & ebLCase_k & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e, ButtonButtonDeviceInfo.DblClickTime))

	'Button.LongPressTime
	ButtonButtonDeviceInfo.LongPressTime = CLng(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_L & ebLCase_o & ebLCase_n & ebLCase_g & ebUCase_P & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_s & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e, ButtonButtonDeviceInfo.LongPressTime))

	'Button.FixationTime
	ButtonButtonDeviceInfo.FixationTime = CLng(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_F & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e, ButtonButtonDeviceInfo.FixationTime))

	'Button.EmulateDeviceName
	ButtonButtonDeviceInfo.EmulateDeviceName = CStr(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_E & ebLCase_m & ebLCase_u & ebLCase_l & ebLCase_a & ebLCase_t & ebLCase_e & ebUCase_D & ebLCase_e & ebLCase_v & ebLCase_i & ebLCase_c & ebLCase_e & ebUCase_N & ebLCase_a & ebLCase_m & ebLCase_e, ButtonButtonDeviceInfo.EmulateDeviceName))

	
	'Open the device, unless the context values indicate otherwise
	Dim ButtonOpen As Boolean
	ButtonOpen = True
	If c.AttribExists(Button.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n) Then ButtonOpen = CLogical(c.GetAttrib(Button.Name & ebDot & ebUCase_O & ebLCase_p & ebLCase_e & ebLCase_n))
	If ButtonOpen = True Then
		Button.Open ButtonButtonDeviceInfo

		'Button.RTAdjustment
		Button.RTAdjustment = CLng(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_R & ebUCase_T & ebUCase_A & ebLCase_d & ebLCase_j & ebLCase_u & ebLCase_s & ebLCase_t & ebLCase_m & ebLCase_e & ebLCase_n & ebLCase_t, 0))

		'Button.PrimaryKeys
		Button.PrimaryKeys = CLng(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s, 255))

		'Button.PrimaryKeys.1 - BitMask
		Button.PrimaryKeys = Button.PrimaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_1, False)), 1, 0))

		'Button.PrimaryKeys.2 - BitMask
		Button.PrimaryKeys = Button.PrimaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_2, False)), 2, 0))

		'Button.PrimaryKeys.3 - BitMask
		Button.PrimaryKeys = Button.PrimaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_3, False)), 4, 0))

		'Button.PrimaryKeys.4 - BitMask
		Button.PrimaryKeys = Button.PrimaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_4, False)), 8, 0))

		'Button.PrimaryKeys.5 - BitMask
		Button.PrimaryKeys = Button.PrimaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_5, False)), 16, 0))

		'Button.PrimaryKeys.6 - BitMask
		Button.PrimaryKeys = Button.PrimaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_6, False)), 32, 0))

		'Button.PrimaryKeys.7 - BitMask
		Button.PrimaryKeys = Button.PrimaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_7, False)), 64, 0))

		'Button.PrimaryKeys.8 - BitMask
		Button.PrimaryKeys = Button.PrimaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_P & ebLCase_r & ebLCase_i & ebLCase_m & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_8, False)), 128, 0))

		'Button.SecondaryKeys
		Button.SecondaryKeys = CLng(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s, 255))

		'Button.SecondaryKeys.1 - BitMask
		Button.SecondaryKeys = Button.SecondaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_1, False)), 1, 0))

		'Button.SecondaryKeys.2 - BitMask
		Button.SecondaryKeys = Button.SecondaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_2, False)), 2, 0))

		'Button.SecondaryKeys.3 - BitMask
		Button.SecondaryKeys = Button.SecondaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_3, False)), 4, 0))

		'Button.SecondaryKeys.4 - BitMask
		Button.SecondaryKeys = Button.SecondaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_4, False)), 8, 0))

		'Button.SecondaryKeys.5 - BitMask
		Button.SecondaryKeys = Button.SecondaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_5, False)), 16, 0))

		'Button.SecondaryKeys.6 - BitMask
		Button.SecondaryKeys = Button.SecondaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_6, False)), 32, 0))

		'Button.SecondaryKeys.7 - BitMask
		Button.SecondaryKeys = Button.SecondaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_7, False)), 64, 0))

		'Button.SecondaryKeys.8 - BitMask
		Button.SecondaryKeys = Button.SecondaryKeys Or CLng(IIf(CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_S & ebLCase_e & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_a & ebLCase_r & ebLCase_y & ebUCase_K & ebLCase_e & ebLCase_y & ebLCase_s & ebDot & ebDigit_8, False)), 128, 0))

		'Button.UseStartTime
		Button.UseStartTime = CLogical(c.GetAttribOrDefault(Button.Name & ebDot & ebUCase_U & ebLCase_s & ebLCase_e & ebUCase_S & ebLCase_t & ebLCase_a & ebLCase_r & ebLCase_t & ebUCase_T & ebLCase_i & ebLCase_m & ebLCase_e, False))

		
	End If

	Set Serial = New SerialDevice
	Serial.Name = ebUCase_S & ebLCase_e & ebLCase_r & ebLCase_i & ebLCase_a & ebLCase_l

	Dim SerialSerialDeviceInfo As SerialDeviceInfo
	SerialSerialDeviceInfo.CommPort = 3
	SerialSerialDeviceInfo.BaudRate = 115200
	SerialSerialDeviceInfo.DataBits = 8
	SerialSerialDeviceInfo.Parity = ebParityNo
	SerialSerialDeviceInfo.StopBits = ebStopBits1_0
	'Load values from context if they exist
	If c.AttribExists(Serial.Name & ".CommPort") Then SerialSerialDeviceInfo.CommPort = CLng(c.GetAttrib(Serial.Name & ".CommPort"))
	If c.AttribExists(Serial.Name & ".BaudRate") Then SerialSerialDeviceInfo.BaudRate = CLng(c.GetAttrib(Serial.Name & ".BaudRate"))
	If c.AttribExists(Serial.Name & ".DataBits") Then SerialSerialDeviceInfo.DataBits = CLng(c.GetAttrib(Serial.Name & ".DataBits"))
	If c.AttribExists(Serial.Name & ".Parity") Then SerialSerialDeviceInfo.Parity = CLng(c.GetAttrib(Serial.Name & ".Parity"))
	If c.AttribExists(Serial.Name & ".StopBits") Then SerialSerialDeviceInfo.StopBits = CLng(c.GetAttrib(Serial.Name & ".StopBits"))
	
	'Open the device, unless the context values indicate otherwise
	Dim SerialOpen As Boolean
	SerialOpen = True
	If c.AttribExists(Serial.Name & ".Open") Then SerialOpen = CLogical(c.GetAttrib(Serial.Name & ".Open"))
	If SerialOpen = True Then
		Serial.Open SerialSerialDeviceInfo

	End If

	'Init All Devices
	Rte.DeviceManager.Init


	Dim theTheme As SlideButtonTheme
	Dim theFeedback As SlideButtonFeedback

	Set theTheme = New SlideButtonTheme
	theTheme.Name = ebUCase_B & ebLCase_a & ebLCase_s & ebLCase_e & ebUCase_B & ebLCase_u & ebLCase_t & ebLCase_t & ebLCase_o & ebLCase_n
	theTheme.LoadProperties

	Set theTheme = New SlideButtonTheme
	theTheme.Name = ebUCase_B & ebLCase_a & ebLCase_s & ebLCase_e & ebUCase_C & ebLCase_h & ebLCase_o & ebLCase_i & ebLCase_c & ebLCase_e
	theTheme.LoadProperties

	Set theTheme = New SlideButtonTheme
	theTheme.Name = ebUCase_B & ebLCase_a & ebLCase_s & ebLCase_e & ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebLCase_r
	theTheme.LoadProperties

	GetSlideButtonTheme(ebUCase_B & ebLCase_a & ebLCase_s & ebLCase_e & ebUCase_B & ebLCase_u & ebLCase_t & ebLCase_t & ebLCase_o & ebLCase_n).Update
	GetSlideButtonTheme(ebUCase_B & ebLCase_a & ebLCase_s & ebLCase_e & ebUCase_C & ebLCase_h & ebLCase_o & ebLCase_i & ebLCase_c & ebLCase_e).Update
	GetSlideButtonTheme(ebUCase_B & ebLCase_a & ebLCase_s & ebLCase_e & ebUCase_S & ebLCase_l & ebLCase_i & ebLCase_d & ebLCase_e & ebLCase_r).Update
	
	PostInitDevices c

End Sub



'--------------------------------------------------------------------------
' PreInitObjects
'
'--------------------------------------------------------------------------
Sub PreInitObjects(c As Context)

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

End Sub


'--------------------------------------------------------------------------
' PostInitObjects
'
'--------------------------------------------------------------------------
Sub PostInitObjects(c As Context)

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

End Sub


'--------------------------------------------------------------------------
' InitObjects
'
'--------------------------------------------------------------------------
Sub InitObjects(c As Context)

	PreInitObjects c

	Set Plan = New Slide
	Plan.Name = ebUCase_P & ebLCase_l & ebLCase_a & ebLCase_n
	'{53811977-3B9C-4123-8E78-730AB666AACF}
	Plan.Guid = CGuid(&H53811977, &H3B9C, &H4123, &H8E78, &H730AB666, &HAACF)
	Plan.Tag = ebEmptyText

	Set PlanEchoClients = New EchoClientCollection

	Plan.LoadProperties

	Set SessionProc = New Procedure
	SessionProc.Name = ebUCase_S & ebLCase_e & ebLCase_s & ebLCase_s & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c
	'{5EF94FD5-B3DD-4FED-B811-87E93F622EBD}
	SessionProc.Guid = CGuid(&H5EF94FD5, &HB3DD, &H4FED, &HB811, &H87E93F62, &H2EBD)
	SessionProc.Tag = ebEmptyText

	SessionProc.LoadProperties
	SessionProc.Subroutine = ebUCase_S & ebLCase_e & ebLCase_s & ebLCase_s & ebLCase_i & ebLCase_o & ebLCase_n & ebUCase_P & ebLCase_r & ebLCase_o & ebLCase_c & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n

	Set planproc = New Procedure
	planproc.Name = ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_n & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c
	'{CA9D6584-C43D-422A-BC5A-A261B89D3E91}
	planproc.Guid = CGuid(&HCA9D6584, &HC43D, &H422A, &HBC5A, &HA261B89D, &H3E91)
	planproc.Tag = ebEmptyText

	planproc.LoadProperties
	planproc.Subroutine = ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_n & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n

	Set Fixation = New TextDisplay
	Fixation.Name = ebUCase_F & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n
	'{18506ACD-F7EF-4F6C-A5A0-152A6E9D692E}
	Fixation.Guid = CGuid(&H18506ACD, &HF7EF, &H4F6C, &HA5A0, &H152A6E9D, &H692E)
	Fixation.Tag = ebEmptyText

	Fixation.LoadProperties

	Set MenuList = New List
	MenuList.Name = ebUCase_M & ebLCase_e & ebLCase_n & ebLCase_u & ebUCase_L & ebLCase_i & ebLCase_s & ebLCase_t
	'{F3BE44C3-685C-4D08-8DAD-B0BB5A477EB5}
	MenuList.Guid = CGuid(&HF3BE44C3, &H685C, &H4D08, &H8DAD, &HB0BB5A47, &H7EB5)
	MenuList.Tag = ebEmptyText

	'Initialization for MenuList
	
	Set MenuList.Order = New SequentialOrder
	Set MenuList.Deletion = NoDeletion
	MenuList.ResetEveryRun = False

	MenuList.LoadProperties

	Set MenuList.TerminateCondition = Cycles(1)
	Set MenuList.ResetCondition = Samples(1)
	MenuList.Reset
	
	Set Menu = New Procedure
	Menu.Name = ebUCase_M & ebLCase_e & ebLCase_n & ebLCase_u
	'{93B8A601-9299-47B0-8BFC-F18BF729FF22}
	Menu.Guid = CGuid(&H93B8A601, &H9299, &H47B0, &H8BFC, &HF18BF729, &HFF22)
	Menu.Tag = ebEmptyText

	Menu.LoadProperties
	Menu.Subroutine = ebUCase_M & ebLCase_e & ebLCase_n & ebLCase_u & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n

	Set TowerTask = New Procedure
	TowerTask.Name = ebUCase_T & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_T & ebLCase_a & ebLCase_s & ebLCase_k
	'{602CCE11-9668-428A-8BB8-1542D9ED8DD0}
	TowerTask.Guid = CGuid(&H602CCE11, &H9668, &H428A, &H8BB8, &H1542D9ED, &H8DD0)
	TowerTask.Tag = ebEmptyText

	TowerTask.LoadProperties
	TowerTask.Subroutine = ebUCase_T & ebLCase_o & ebLCase_w & ebLCase_e & ebLCase_r & ebUCase_T & ebLCase_a & ebLCase_s & ebLCase_k & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n

	Set MenuText = New TextDisplay
	MenuText.Name = ebUCase_M & ebLCase_e & ebLCase_n & ebLCase_u & ebUCase_T & ebLCase_e & ebLCase_x & ebLCase_t
	'{92EE8EEE-B636-41BC-836D-9BD0104606ED}
	MenuText.Guid = CGuid(&H92EE8EEE, &HB636, &H41BC, &H836D, &H9BD01046, &H06ED)
	MenuText.Tag = ebEmptyText

	MenuText.LoadProperties

	Set goodbye = New Procedure
	goodbye.Name = ebLCase_g & ebLCase_o & ebLCase_o & ebLCase_d & ebLCase_b & ebLCase_y & ebLCase_e
	'{1FD6B49A-4364-47D6-B42C-41A413E5CE29}
	goodbye.Guid = CGuid(&H1FD6B49A, &H4364, &H47D6, &HB42C, &H41A413E5, &HCE29)
	goodbye.Tag = ebEmptyText

	goodbye.LoadProperties
	goodbye.Subroutine = ebLCase_g & ebLCase_o & ebLCase_o & ebLCase_d & ebLCase_b & ebLCase_y & ebLCase_e & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n

	Set Goodbyetxt = New TextDisplay
	Goodbyetxt.Name = ebUCase_G & ebLCase_o & ebLCase_o & ebLCase_d & ebLCase_b & ebLCase_y & ebLCase_e & ebLCase_t & ebLCase_x & ebLCase_t
	'{587D9018-2838-4635-B9E5-DF6B7FB4FF9E}
	Goodbyetxt.Guid = CGuid(&H587D9018, &H2838, &H4635, &HB9E5, &HDF6B7FB4, &HFF9E)
	Goodbyetxt.Tag = ebEmptyText

	Goodbyetxt.LoadProperties

	Set Breakproc = New Procedure
	Breakproc.Name = ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c
	'{009AEAD7-B31E-4AA0-BC46-6BBC5934E815}
	Breakproc.Guid = CGuid(&H009AEAD7, &HB31E, &H4AA0, &HBC46, &H6BBC5934, &HE815)
	Breakproc.Tag = ebEmptyText

	Breakproc.LoadProperties
	Breakproc.Subroutine = ebUCase_B & ebLCase_r & ebLCase_e & ebLCase_a & ebLCase_k & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n

	Set Standby = New TextDisplay
	Standby.Name = ebUCase_S & ebLCase_t & ebLCase_a & ebLCase_n & ebLCase_d & ebLCase_b & ebLCase_y
	'{87293BD6-5AD1-44B5-9A15-82558A876F0B}
	Standby.Guid = CGuid(&H87293BD6, &H5AD1, &H44B5, &H9A15, &H82558A87, &H6F0B)
	Standby.Tag = ebEmptyText

	Set StandbyEchoClients = New EchoClientCollection

	Standby.LoadProperties

	Set Waitingforpup = New TextDisplay
	Waitingforpup.Name = ebUCase_W & ebLCase_a & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_n & ebLCase_g & ebLCase_f & ebLCase_o & ebLCase_r & ebLCase_p & ebLCase_u & ebLCase_p
	'{B2BD1252-650B-44E5-AD71-EEFA41BE5CD9}
	Waitingforpup.Guid = CGuid(&HB2BD1252, &H650B, &H44E5, &HAD71, &HEEFA41BE, &H5CD9)
	Waitingforpup.Tag = ebEmptyText

	Set WaitingforpupEchoClients = New EchoClientCollection

	Waitingforpup.LoadProperties

	Set TOLconditions = New List
	TOLconditions.Name = ebUCase_T & ebUCase_O & ebUCase_L & ebLCase_c & ebLCase_o & ebLCase_n & ebLCase_d & ebLCase_i & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebLCase_s
	'{30118BD3-3D36-435B-9859-3EF0E350564B}
	TOLconditions.Guid = CGuid(&H30118BD3, &H3D36, &H435B, &H9859, &H3EF0E350, &H564B)
	TOLconditions.Tag = ebEmptyText

	'Initialization for TOLconditions
	
	Set TOLconditions.Order = New SequentialOrder
	Set TOLconditions.Deletion = NoDeletion
	TOLconditions.ResetEveryRun = False

	TOLconditions.LoadProperties

	Set TOLconditions.TerminateCondition = Cycles(1)
	Set TOLconditions.ResetCondition = Samples(52)
	TOLconditions.Reset
	
	Set Instruct = New TextDisplay
	Instruct.Name = ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t
	'{7C262C30-7B04-4AB3-BDFE-4F9F39C847BA}
	Instruct.Guid = CGuid(&H7C262C30, &H7B04, &H4AB3, &HBDFE, &H4F9F39C8, &H47BA)
	Instruct.Tag = ebEmptyText

	Set InstructEchoClients = New EchoClientCollection

	Instruct.LoadProperties

	Set mask = New TextDisplay
	mask.Name = ebLCase_m & ebLCase_a & ebLCase_s & ebLCase_k
	'{A49A5AB0-EF2E-4186-A10F-EAD603CB979D}
	mask.Guid = CGuid(&HA49A5AB0, &HEF2E, &H4186, &HA10F, &HEAD603CB, &H979D)
	mask.Tag = ebEmptyText

	mask.LoadProperties

	Set Intelligence = New TextDisplay
	Intelligence.Name = ebUCase_I & ebLCase_n & ebLCase_t & ebLCase_e & ebLCase_l & ebLCase_l & ebLCase_i & ebLCase_g & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e
	'{FB884FF0-D80C-461B-BF87-0DD1BE190B96}
	Intelligence.Guid = CGuid(&HFB884FF0, &HD80C, &H461B, &HBF87, &H0DD1BE19, &H0B96)
	Intelligence.Tag = ebEmptyText

	Set IntelligenceEchoClients = New EchoClientCollection

	Intelligence.LoadProperties

	Set Block1 = New List
	Block1.Name = ebUCase_B & ebLCase_l & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_1
	'{0E0133CE-047B-46EA-8DFF-41695109E9F0}
	Block1.Guid = CGuid(&H0E0133CE, &H047B, &H46EA, &H8DFF, &H41695109, &HE9F0)
	Block1.Tag = ebEmptyText

	'Initialization for Block1
	
	Set Block1.Order = New SequentialOrder
	Set Block1.Deletion = NoDeletion
	Block1.ResetEveryRun = False

	Block1.LoadProperties

	Set Block1.TerminateCondition = Cycles(1)
	Set Block1.ResetCondition = Samples(13)
	Block1.Reset
	
	Set Incorrect = New Slide
	Incorrect.Name = ebUCase_I & ebLCase_n & ebLCase_c & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t
	'{AA4CAD4C-73CB-4CC0-A460-BA28A469472E}
	Incorrect.Guid = CGuid(&HAA4CAD4C, &H73CB, &H4CC0, &HA460, &HBA28A469, &H472E)
	Incorrect.Tag = ebEmptyText

	Incorrect.LoadProperties

	Set Correct = New Slide
	Correct.Name = ebUCase_C & ebLCase_o & ebLCase_r & ebLCase_r & ebLCase_e & ebLCase_c & ebLCase_t
	'{B447E18D-B80B-4F97-AFE4-8281CA85ED4E}
	Correct.Guid = CGuid(&HB447E18D, &HB80B, &H4F97, &HAFE4, &H8281CA85, &HED4E)
	Correct.Tag = ebEmptyText

	Correct.LoadProperties

	Set Fixation2 = New Slide
	Fixation2.Name = ebUCase_F & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_2
	'{ABCAC668-081A-40CF-8273-3B90E665127C}
	Fixation2.Guid = CGuid(&HABCAC668, &H081A, &H40CF, &H8273, &H3B90E665, &H127C)
	Fixation2.Tag = ebEmptyText

	Fixation2.LoadProperties

	Set Block2 = New List
	Block2.Name = ebUCase_B & ebLCase_l & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_2
	'{D4A235C7-C89A-4E24-9D49-ED238CB3B3E0}
	Block2.Guid = CGuid(&HD4A235C7, &HC89A, &H4E24, &H9D49, &HED238CB3, &HB3E0)
	Block2.Tag = ebEmptyText

	'Initialization for Block2
	
	Set Block2.Order = New SequentialOrder
	Set Block2.Deletion = NoDeletion
	Block2.ResetEveryRun = False

	Block2.LoadProperties

	Set Block2.TerminateCondition = Cycles(1)
	Set Block2.ResetCondition = Samples(11)
	Block2.Reset
	
	Set Block3 = New List
	Block3.Name = ebUCase_B & ebLCase_l & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_3
	'{DC7D5CE3-0D57-41DA-943D-AEC48439406D}
	Block3.Guid = CGuid(&HDC7D5CE3, &H0D57, &H41DA, &H943D, &HAEC48439, &H406D)
	Block3.Tag = ebEmptyText

	'Initialization for Block3
	
	Set Block3.Order = New SequentialOrder
	Set Block3.Deletion = NoDeletion
	Block3.ResetEveryRun = False

	Block3.LoadProperties

	Set Block3.TerminateCondition = Cycles(1)
	Set Block3.ResetCondition = Samples(11)
	Block3.Reset
	
	Set Instruct2 = New TextDisplay
	Instruct2.Name = ebUCase_I & ebLCase_n & ebLCase_s & ebLCase_t & ebLCase_r & ebLCase_u & ebLCase_c & ebLCase_t & ebDigit_2
	'{FF55581E-59BA-413D-9505-A5EB3EA2D102}
	Instruct2.Guid = CGuid(&HFF55581E, &H59BA, &H413D, &H9505, &HA5EB3EA2, &HD102)
	Instruct2.Tag = ebEmptyText

	Set Instruct2EchoClients = New EchoClientCollection

	Instruct2.LoadProperties

	Set Beakprocshock = New Procedure
	Beakprocshock.Name = ebUCase_B & ebLCase_e & ebLCase_a & ebLCase_k & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k
	'{6430FE93-A543-40AE-98A3-3D543CDF4B58}
	Beakprocshock.Guid = CGuid(&H6430FE93, &HA543, &H40AE, &H98A3, &H3D543CDF, &H4B58)
	Beakprocshock.Tag = ebEmptyText

	Beakprocshock.LoadProperties
	Beakprocshock.Subroutine = ebUCase_B & ebLCase_e & ebLCase_a & ebLCase_k & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Beakprocshock_theCollection = New RteCollection

	Set Block4 = New List
	Block4.Name = ebUCase_B & ebLCase_l & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_4
	'{773CFA07-B193-4B49-97B9-4C2DF3C9FC27}
	Block4.Guid = CGuid(&H773CFA07, &HB193, &H4B49, &H97B9, &H4C2DF3C9, &HFC27)
	Block4.Tag = ebEmptyText

	'Initialization for Block4
	
	Set Block4.Order = New SequentialOrder
	Set Block4.Deletion = NoDeletion
	Block4.ResetEveryRun = False

	Block4.LoadProperties

	Set Block4.TerminateCondition = Cycles(1)
	Set Block4.ResetCondition = Samples(11)
	Block4.Reset
	
	Set SAMDdid = New Slide
	SAMDdid.Name = ebUCase_S & ebUCase_A & ebUCase_M & ebUCase_D & ebLCase_d & ebLCase_i & ebLCase_d
	'{CD998D2D-352D-4D5D-9860-58FD49994CC0}
	SAMDdid.Guid = CGuid(&HCD998D2D, &H352D, &H4D5D, &H9860, &H58FD4999, &H4CC0)
	SAMDdid.Tag = ebEmptyText

	Set SAMDdidEchoClients = New EchoClientCollection

	SAMDdid.LoadProperties

	Set Intelligence1 = New TextDisplay
	Intelligence1.Name = ebUCase_I & ebLCase_n & ebLCase_t & ebLCase_e & ebLCase_l & ebLCase_l & ebLCase_i & ebLCase_g & ebLCase_e & ebLCase_n & ebLCase_c & ebLCase_e & ebDigit_1
	'{9D43CF6B-2537-4FA1-98CE-0995EEC6F879}
	Intelligence1.Guid = CGuid(&H9D43CF6B, &H2537, &H4FA1, &H98CE, &H0995EEC6, &HF879)
	Intelligence1.Tag = ebEmptyText

	Set Intelligence1EchoClients = New EchoClientCollection

	Intelligence1.LoadProperties

	Set CD5 = New Slide
	CD5.Name = ebUCase_C & ebUCase_D & ebDigit_5
	'{6D609864-570C-4B71-975B-7F56CCF2B6FC}
	CD5.Guid = CGuid(&H6D609864, &H570C, &H4B71, &H975B, &H7F56CCF2, &HB6FC)
	CD5.Tag = ebEmptyText

	CD5.LoadProperties

	Set CD1 = New Slide
	CD1.Name = ebUCase_C & ebUCase_D & ebDigit_1
	'{5E44D51D-29AA-4225-BA00-6CA3D60DC3CA}
	CD1.Guid = CGuid(&H5E44D51D, &H29AA, &H4225, &HBA00, &H6CA3D60D, &HC3CA)
	CD1.Tag = ebEmptyText

	CD1.LoadProperties

	Set CD2 = New Slide
	CD2.Name = ebUCase_C & ebUCase_D & ebDigit_2
	'{3CAFBED6-EE49-4167-8D61-A7F5F370CA24}
	CD2.Guid = CGuid(&H3CAFBED6, &HEE49, &H4167, &H8D61, &HA7F5F370, &HCA24)
	CD2.Tag = ebEmptyText

	CD2.LoadProperties

	Set CD3 = New Slide
	CD3.Name = ebUCase_C & ebUCase_D & ebDigit_3
	'{72DB6BBC-BE24-4418-A609-7A514D8F3A1B}
	CD3.Guid = CGuid(&H72DB6BBC, &HBE24, &H4418, &HA609, &H7A514D8F, &H3A1B)
	CD3.Tag = ebEmptyText

	CD3.LoadProperties

	Set CD4 = New Slide
	CD4.Name = ebUCase_C & ebUCase_D & ebDigit_4
	'{5CC133B2-F748-4C73-9E47-515DF58B1E29}
	CD4.Guid = CGuid(&H5CC133B2, &HF748, &H4C73, &H9E47, &H515DF58B, &H1E29)
	CD4.Tag = ebEmptyText

	CD4.LoadProperties

	Set Fixation3 = New Slide
	Fixation3.Name = ebUCase_F & ebLCase_i & ebLCase_x & ebLCase_a & ebLCase_t & ebLCase_i & ebLCase_o & ebLCase_n & ebDigit_3
	'{047F1B9F-14EB-4297-8880-65AACFF3EAD0}
	Fixation3.Guid = CGuid(&H047F1B9F, &H14EB, &H4297, &H8880, &H65AACFF3, &HEAD0)
	Fixation3.Tag = ebEmptyText

	Fixation3.LoadProperties

	Set shockcheck = New TextDisplay
	shockcheck.Name = ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k & ebLCase_c & ebLCase_h & ebLCase_e & ebLCase_c & ebLCase_k
	'{22FBD368-E57B-435B-A02C-BD21F1796A3A}
	shockcheck.Guid = CGuid(&H22FBD368, &HE57B, &H435B, &HA02C, &HBD21F179, &H6A3A)
	shockcheck.Tag = ebEmptyText

	Set shockcheckEchoClients = New EchoClientCollection

	shockcheck.LoadProperties

	Set shockscale = New Slide
	shockscale.Name = ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k & ebLCase_s & ebLCase_c & ebLCase_a & ebLCase_l & ebLCase_e
	'{9F6B352F-AC8B-4601-8229-84E77EDFB083}
	shockscale.Guid = CGuid(&H9F6B352F, &HAC8B, &H4601, &H8229, &H84E77EDF, &HB083)
	shockscale.Tag = ebEmptyText

	Set shockscaleEchoClients = New EchoClientCollection

	shockscale.LoadProperties

	Set Moreshock = New TextDisplay
	Moreshock.Name = ebUCase_M & ebLCase_o & ebLCase_r & ebLCase_e & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k
	'{CBC91C6B-E505-47A1-87EA-ED12F435506F}
	Moreshock.Guid = CGuid(&HCBC91C6B, &HE505, &H47A1, &H87EA, &HED12F435, &H506F)
	Moreshock.Tag = ebEmptyText

	Set MoreshockEchoClients = New EchoClientCollection

	Moreshock.LoadProperties

	Set Beakprocshock3 = New Procedure
	Beakprocshock3.Name = ebUCase_B & ebLCase_e & ebLCase_a & ebLCase_k & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_3
	'{DE4C3005-15D2-4234-AD1C-32CE76E56FF6}
	Beakprocshock3.Guid = CGuid(&HDE4C3005, &H15D2, &H4234, &HAD1C, &H32CE76E5, &H6FF6)
	Beakprocshock3.Tag = ebEmptyText

	Beakprocshock3.LoadProperties
	Beakprocshock3.Subroutine = ebUCase_B & ebLCase_e & ebLCase_a & ebLCase_k & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_3 & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Beakprocshock3_theCollection = New RteCollection

	Set Beakprocshock4 = New Procedure
	Beakprocshock4.Name = ebUCase_B & ebLCase_e & ebLCase_a & ebLCase_k & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_4
	'{7631CFBE-4CA5-4A46-8989-38F9CA401F3D}
	Beakprocshock4.Guid = CGuid(&H7631CFBE, &H4CA5, &H4A46, &H8989, &H38F9CA40, &H1F3D)
	Beakprocshock4.Tag = ebEmptyText

	Beakprocshock4.LoadProperties
	Beakprocshock4.Subroutine = ebUCase_B & ebLCase_e & ebLCase_a & ebLCase_k & ebLCase_p & ebLCase_r & ebLCase_o & ebLCase_c & ebLCase_s & ebLCase_h & ebLCase_o & ebLCase_c & ebLCase_k & ebDigit_4 & ebUnderscore & ebUCase_R & ebLCase_u & ebLCase_n
Set Beakprocshock4_theCollection = New RteCollection

	PostInitObjects c


End Sub


'--------------------------------------------------------------------------
' InitPackages
'
'--------------------------------------------------------------------------
Sub InitPackages(c As Context)

End Sub



'--------------------------------------------------------------------------
' InitGlobals
'
'--------------------------------------------------------------------------
Sub InitGlobals(c As Context)


	'Assign Context to the StartupInfo object
	Set Rte.StartupInfo.Context = c

	'Load and Transfer external StartupInfo
	Rte.StartupInfo.Load
	Rte.StartupInfo.Transfer

End Sub



'--------------------------------------------------------------------------


'--------------------------------------------------------------------------
'--------------------------------------------------------------------------
' UnInitGlobals
'--------------------------------------------------------------------------
Sub UnInitGlobals()

	'Close the external StartupInfo
	Rte.StartupInfo.Close

End Sub
'--------------------------------------------------------------------------
' UnInitDevices
'--------------------------------------------------------------------------
Sub UnInitDevices()

	'UnInit All Devices
	Rte.DeviceManager.UnInit
	Display.Close
	Set Display = Nothing

	Keyboard.Close
	Set Keyboard = Nothing

	Mouse.Close
	Set Mouse = Nothing


	Socket.Close
	Set Socket = Nothing

	Button.Close
	Set Button = Nothing


	'Close the SerialDevice
	Serial.Close
	Set Serial = Nothing
End Sub


'--------------------------------------------------------------------------
'--------------------------------------------------------------------------
' UnInitPackages
'--------------------------------------------------------------------------
Sub UnInitPackages()
End Sub


'--------------------------------------------------------------------------
' UnInitObjects
'
'--------------------------------------------------------------------------
Sub UnInitObjects()

	Set Plan = Nothing

	Set PlanEchoClients = Nothing

	Set SessionProc = Nothing

	Set planproc = Nothing

	Set Fixation = Nothing

	Set MenuList = Nothing

	Set Menu = Nothing

	Set TowerTask = Nothing

	Set MenuText = Nothing

	Set goodbye = Nothing

	Set Goodbyetxt = Nothing

	Set Breakproc = Nothing

	Set Standby = Nothing

	Set StandbyEchoClients = Nothing

	Set Waitingforpup = Nothing

	Set WaitingforpupEchoClients = Nothing

	Set TOLconditions = Nothing

	Set Instruct = Nothing

	Set InstructEchoClients = Nothing

	Set mask = Nothing

	Set Intelligence = Nothing

	Set IntelligenceEchoClients = Nothing

	Set Block1 = Nothing

	Set Incorrect = Nothing

	Set Correct = Nothing

	Set Fixation2 = Nothing

	Set Block2 = Nothing

	Set Block3 = Nothing

	Set Instruct2 = Nothing

	Set Instruct2EchoClients = Nothing

	Set Beakprocshock = Nothing

	Set Block4 = Nothing

	Set SAMDdid = Nothing

	Set SAMDdidEchoClients = Nothing

	Set Intelligence1 = Nothing

	Set Intelligence1EchoClients = Nothing

	Set CD5 = Nothing

	Set CD1 = Nothing

	Set CD2 = Nothing

	Set CD3 = Nothing

	Set CD4 = Nothing

	Set Fixation3 = Nothing

	Set shockcheck = Nothing

	Set shockcheckEchoClients = Nothing

	Set shockscale = Nothing

	Set shockscaleEchoClients = Nothing

	Set Moreshock = Nothing

	Set MoreshockEchoClients = Nothing

	Set Beakprocshock3 = Nothing

	Set Beakprocshock4 = Nothing


End Sub


'--------------------------------------------------------------------------
' Main
'
'--------------------------------------------------------------------------
Sub Main()

	' Create and initialize the default context, data file,
	' and provide global access to the context.
	Dim c As Context
	Set c = New Context
	c.Name = "ebContext"
	Set c.DataFile = New DataFile
	c.PushNewFrame
	Set ebContext = c

	' Set the log level names
	c.SetLogLevelName 1, "Session"
	c.SetLogLevelName 2, "Block"
	c.SetLogLevelName 3, "Trial"
	c.SetLogLevelName 4, "SubTrial"
	c.SetLogLevelName 5, "LogLevel5"
	c.SetLogLevelName 6, "LogLevel6"
	c.SetLogLevelName 7, "LogLevel7"
	c.SetLogLevelName 8, "LogLevel8"
	c.SetLogLevelName 9, "LogLevel9"
	c.SetLogLevelName 10, "LogLevel10"

	' Set standard logging items
	ebContext.SetAttrib "Experiment", "TOL072723_EyeLink2024-02-20"
	ebContext.SetAttrib "SessionDate", Date$
	ebContext.SetAttrib "SessionTime", Time$
	ebContext.SetAttrib "SessionStartDateTimeUtc", NowUtc()

	'Initialize global variables for packages
	InitGlobals c

	' Initialize the Display Device(s) for runtime
	Dim DisplayDisplayDeviceInfo As DisplayDeviceInfo
	DisplayDisplayDeviceInfo.DefaultColor = Color.White
	DisplayDisplayDeviceInfo.DisplayIndex = 1
	If c.AttribExists(ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDot & ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r) Then DisplayDisplayDeviceInfo.DefaultColor = CColor(c.GetAttrib(ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDot & ebUCase_D & ebLCase_e & ebLCase_f & ebLCase_a & ebLCase_u & ebLCase_l & ebLCase_t & ebUCase_C & ebLCase_o & ebLCase_l & ebLCase_o & ebLCase_r))
	If c.AttribExists(ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x) Then DisplayDisplayDeviceInfo.DisplayIndex = CLng(c.GetAttrib(ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebDot & ebUCase_D & ebLCase_i & ebLCase_s & ebLCase_p & ebLCase_l & ebLCase_a & ebLCase_y & ebUCase_I & ebLCase_n & ebLCase_d & ebLCase_e & ebLCase_x))

	
	
	If CLogical(c.GetAttribOrDefault("Experiment.Windowed", "False")) Then
		CreateDefaultPortWindowed DisplayDisplayDeviceInfo.DisplayIndex
	Else
		CreateDefaultPort DisplayDisplayDeviceInfo.DefaultColor, "", DisplayDisplayDeviceInfo.DisplayIndex
	End If
	
	If Basic.OS = ebWin32 Then
		WinActivate "E-Run Experiment Window"
	End If

	' Get the StartupInfo

	' Set the defaults for all of the StartupInfo
	If Not c.AttribExists("Subject") Then c.SetAttrib "Subject", "1"
	If Not c.AttribExists("Session") Then c.SetAttrib "Session", "1"

	' Determine if StartupInfo.UseDefaults exists and is True/False to override prompts for StartupInfo parameters
	Dim bStartupInfoUseDefaults As Boolean
	bStartupInfoUseDefaults = False
	If c.AttribExists("StartupInfo.UseDefaults") Then bStartupInfoUseDefaults = CLogical(c.GetAttrib("StartupInfo.UseDefaults"))
	If Not bStartupInfoUseDefaults Then

		Dim vAnswer As Variant
StartupInfo_Begin:

StartupInfoPrompt_Subject:
		vAnswer = AskBox("Please enter the Subject Number (1-32767, 0=No Data Logging):", c.GetAttrib("Subject"))
		If Not IsEmpty(vAnswer) then
			If Not IsNumeric(vAnswer) then
				MsgBox "Please enter an integer value"
				GoTo StartupInfoPrompt_Subject
			ElseIf CLng(vAnswer) < 0 Then
				MsgBox "The value for Subject must not be less than 0"
				GoTo StartupInfoPrompt_Subject
			ElseIf CLng(vAnswer) > 999999 Then
				MsgBox "The value for Subject must not be greater than 999999"
				GoTo StartupInfoPrompt_Subject
			End If
		Else
			GoTo ExperimentAbort
		End if

		c.SetAttrib "Subject", CStr(vAnswer)

StartupInfoPrompt_Session:
		vAnswer = AskBox("Please enter the Session Number (1-32767):", c.GetAttrib("Session"))
		If Not IsEmpty(vAnswer) then
			If Not IsNumeric(vAnswer) then
				MsgBox "Please enter an integer value"
				GoTo StartupInfoPrompt_Session
			ElseIf CLng(vAnswer) < 1 Then
				MsgBox "The value for Session must not be less than 1"
				GoTo StartupInfoPrompt_Session
			ElseIf CLng(vAnswer) > 32767 Then
				MsgBox "The value for Session must not be greater than 32767"
				GoTo StartupInfoPrompt_Session
			End If
		Else
			GoTo ExperimentAbort
		End if

		c.SetAttrib "Session", CStr(vAnswer)

		' Display the summary
		Dim strSummary As String
		strSummary = "Subject:    " & c.GetAttrib("Subject") & "\n"
		strSummary = strSummary & "Session:    " & c.GetAttrib("Session") & "\n"
		strSummary = strSummary & "\nContinue with the above startup info?"

		Dim nSummaryAnswer As Integer
		nSummaryAnswer = MsgBox(strSummary, ebYesNoCancel, "Summary of Startup Info")
		If nSummaryAnswer = ebNo Then
				GoTo StartupInfo_Begin
		ElseIf nSummaryAnswer = ebCancel Then
				GoTo ExperimentAbort
		End If

	End If


	'Assign the Clock.Scale value
	Clock.Scale = 1.000000

	'If the attribute Clock.Scale.Override exists
	'  then use it for to set the Clock.Scale value
	If c.AttribExists("Clock.Scale.Override") Then
		Clock.Scale = CDbl(c.GetAttrib("Clock.Scale.Override"))
	End If

	' Set the Filenames for the data files
	Dim strFilenameBase As String
	Dim strFilenameRecovery As String
	Dim strFilenameEDAT As String
	Dim strFileNameTXT As String

	'If the attribute DataFile.Filename.Override exists
	'  then use it for the .txt and .edat3 filenames
	If c.AttribExists("DataFile.Filename.Override") Then

		' Set the default Data Filename
		strFilenameBase = CStr(c.GetAttrib("DataFile.Filename.Override"))

	Else

		' Set the default Data Filename
		strFilenameBase = CStr(c.GetAttrib("Experiment")) & "-" & CStr(c.GetAttrib("Subject")) & "-" & CStr(c.GetAttrib("Session"))

	End If

	'Set the name of the data file
	strFilenameRecovery = strFilenameBase & ".txt"
	strFilenameEDAT = strFilenameBase & ".edat3"
	strFileNameTXT = strFilenameBase & "-Export.txt"
	c.DataFile.Filename = strFilenameRecovery
	c.SetAttrib "DataFile.Basename", strFilenameBase

	' If we are logging data, then prompt to overwrite the data file if it exists
	If CLng(c.GetAttrib("Subject")) <> 0 Then
		If FileExists(c.DataFile.Filename) Or FileExists(strFilenameEDAT) Or FileExists(strFileNameTXT) Then
			If ebYes <> MsgBox("WARNING: The data file and/or recovery file already exists:\nFILE: " & c.DataFile.Filename & "\n\nDo you want to overwrite?", ebYesNo) Then
				GoTo ExperimentAbort
			End If
			' If you receive an error here then ensure that your E-Recovery (txt) file or 
			' the edat3 file is not open and then try the experiment run again.
			If FileExists(strFilenameEDAT) Then Kill strFilenameEDAT
			If FileExists(strFileNameTXT) Then Kill strFileNameTXT
			If FileExists(c.DataFile.Filename) Then Kill c.DataFile.Filename
		End If
	End If

	' Set defaults for RandomSeed and GroupNumber if StartupInfo did not assign their values
	If Not c.AttribExists("RandomSeed") Then c.SetAttrib "RandomSeed", PRNG.GetSeed()
	If Not c.AttribExists("Group") Then c.SetAttrib "Group", "1"

	'Set the random seed
	Randomize CLng(c.GetAttrib("RandomSeed"))

	' Initialize Experiment Advisor Properties
	Rte.ExperimentAdvisor.LoadProperties
	If c.AttribExists("Rte.ExperimentAdvisor.Enabled") Then Rte.ExperimentAdvisor.Enabled = CLogical(c.GetAttrib("Rte.ExperimentAdvisor.Enabled"))
	If c.AttribExists("Rte.ExperimentAdvisor.Filename") Then Rte.ExperimentAdvisor.Filename = CStr(c.GetAttrib("Rte.ExperimentAdvisor.Filename"))


	Dim nPriority As Long
	'Priority for init routines
	nPriority = 3

	'Determine if the priority should use the override value
	If c.AttribExists("SetOSThreadPriority.Init.Override") Then
		nPriority = c.GetAttrib("SetOSThreadPriority.Init.Override")
	End If

	'Update E-Prime Priority for INIT routines
	SetOSThreadPriority nPriority

	' Initialize all system devices, packages, and objects
	InitDevices c
	InitPackages c
	InitObjects c

	'Priority for start of experiment
	nPriority = -1

	'Determine if the priority should use the override value
	If c.AttribExists("SetOSThreadPriority.Override") Then
		nPriority = c.GetAttrib("SetOSThreadPriority.Override")
	End If

	'Update E-Prime Priority for start of experiment
	SetOSThreadPriority nPriority

	'Disable System power save mode
	Rte.PreventSystemIdle = True

	If CLng(c.GetAttrib("Subject")) < 0 Then
		Rte.AbortExperiment 12102, ebUCase_S & ebLCase_u & ebLCase_b & ebLCase_j & ebLCase_e & ebLCase_c & ebLCase_t & ebSpace & ebLCase_c & ebLCase_a & ebLCase_n & ebLCase_n & ebLCase_o & ebLCase_t & ebSpace & ebLCase_b & ebLCase_e & ebSpace & ebLCase_l & ebLCase_e & ebLCase_s & ebLCase_s & ebSpace & ebLCase_t & ebLCase_h & ebLCase_a & ebLCase_n & ebSpace & ebDigit_0 & ebDot
	End If

	If CLng(c.GetAttrib("Session")) < 1 Then
		Rte.AbortExperiment 12103, ebUCase_S & ebLCase_e & ebLCase_s & ebLCase_s & ebLCase_i & ebLCase_o & ebLCase_n & ebSpace & ebLCase_c & ebLCase_a & ebLCase_n & ebLCase_n & ebLCase_o & ebLCase_t & ebSpace & ebLCase_b & ebLCase_e & ebSpace & ebLCase_l & ebLCase_e & ebLCase_s & ebLCase_s & ebSpace & ebLCase_t & ebLCase_h & ebLCase_a & ebLCase_n & ebSpace & ebDigit_1 & ebDot
	End If

	' If we are logging data, then open the datafile
	If CLng(c.GetAttrib("Subject")) <> 0 Then
		c.DataFile.Open
		c.LogHeader
	End If


	'Setup the DataFile.BaseName attribute
	c.SetAttrib "DataFile.BaseName", Replace(c.DataFile.Filename, ".txt", ebEmptyText)

	' Log clock timing information
	c.SetAttrib "Clock.Information", Clock.Information

	' Log E-Studio version
	c.SetAttrib "StudioVersion", "3.0.3.214"

	' Log runtime version.
	c.SetAttrib "RuntimeVersion", Rte.Version.Major & ebDot & Rte.Version.Minor & ebDot & Rte.Version.Internal & ebDot & Rte.Version.Build
	c.SetAttrib "RuntimeVersionExpected", 3 & ebDot & 0 & ebDot & 3 & ebDot & 214
	c.SetAttrib "RuntimeCapabilities", ebUCase_F & ebLCase_u & ebLCase_l & ebLCase_l

	' Log experiment version
	c.SetAttrib "ExperimentVersion", "1.0.0.1112"

	' ExperimentStart
	 Rte.ExperimentStart
	' Start the running of the Experiment
	SessionProc.Run c
	' ExperimentFinish
	 Rte.ExperimentFinish

	' Clean up the context and close the datafile
	If CLng(c.GetAttrib("Subject")) <> 0 Then
		Dim nDataFileConvertProgress As Long
		nDataFileConvertProgress = ebProgressSimple
		If c.AttribExists("DataFile.ConvertProgress") Then nDataFileConvertProgress = CLng(c.GetAttrib("DataFile.ConvertProgress"))
		c.DataFile.Close
		' Attempt to convert the recovery file into a data file
		Dim nConvert As Long
		nConvert = c.DataFile.Convert(nDataFileConvertProgress, False)

		If nConvert = 0 Then
			' Settings in E-Studio are set to not remove E-Recovery file
		Else
			' The datafile failed to convert!
			MsgBox "ERROR: The datafile did not convert!\nFILE: " & c.DataFile.Filename & "\n\nIt is recommended that you recover your data with the E-Recovery utility"
			MsgBox c.DataFile.GetLastErrorMessage()
		End If
	End If
ExperimentFinish:

	UnInitObjects

	UnInitPackages
	UnInitDevices

	UnInitGlobals

	' Experiment Advisor Report Generation
	If Rte.ExperimentAdvisor.Enabled = True Then
		If Len(Rte.ExperimentAdvisor.Filename) = 0 Then Rte.ExperimentAdvisor.Filename = Replace(c.DataFile.Filename, ".txt", "-ExperimentAdvisorReport.xml")
		Rte.ExperimentAdvisor.GenerateReport


	End If


ExperimentAbort:

	' Clean up the context
	c.PopFrame
	Set c = Nothing
	Set ebContext = Nothing

	DestroyDefaultPort

End Sub

